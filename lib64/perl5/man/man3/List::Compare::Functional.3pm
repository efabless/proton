.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "List::Compare::Functional 3"
.TH List::Compare::Functional 3 "2015-05-21" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
List::Compare::Functional \- Compare elements of two or more lists
.SH "VERSION"
.IX Header "VERSION"
This document refers to version 0.52 of List::Compare::Functional.
This version was released May 21 2015.  The first released
version of List::Compare::Functional was v0.21.  Its version numbers
are set to be consistent with the other parts of the List::Compare
distribution.
.SS "Notice of Interface Changes"
.IX Subsection "Notice of Interface Changes"
Certain significant changes to the interface to List::Compare::Functional
were made with the introduction of Version 0.25 in April 2004.  The
documentation immediately below reflects those changes, so if you are
first using this module with that or a later version, simply read and
follow the documentation below.  If, however, you used List::Compare::Functional
prior to that version, see the discussion of interface changes farther
below: April 2004 Change of Interface.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Getting Started"
.IX Subsection "Getting Started"
List::Compare::Functional exports no subroutines by default.
.PP
.Vb 1
\&    use List::Compare::Functional qw(:originals :aliases);
.Ve
.PP
will import all publicly available subroutines from
List::Compare::Functional.  The model for importing just one subroutine from
List::Compare::Functional is:
.PP
.Vb 1
\&    use List::Compare::Functional qw( get_intersection );
.Ve
.PP
It will probably be most convenient for the user to import functions by
using one of the two following export tags:
.PP
.Vb 1
\&    use List::Compare::Functional qw(:main :mainrefs);
.Ve
.PP
The assignment of the various comparison functions to export tags is
discussed below.
.PP
For clarity, we shall begin by discussing comparisons of just two lists at
a time.  Farther below, we shall discuss comparisons among three or more
lists at a time.
.SS "Comparing Two Lists Held in Arrays"
.IX Subsection "Comparing Two Lists Held in Arrays"
.IP "\(bu" 4
Given two lists:
.Sp
.Vb 2
\&    @Llist = qw(abel abel baker camera delta edward fargo golfer);
\&    @Rlist = qw(baker camera delta delta edward fargo golfer hilton);
.Ve
.IP "\(bu" 4
Get those items which appear at least once in both lists (their intersection).
.Sp
.Vb 1
\&    @intersection = get_intersection( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
Note that you could place the references to the lists being compared into
a named array and then pass \f(CW\*(C`get_intersection()\*(C'\fR a reference to that array.
.Sp
.Vb 2
\&    @to_be_compared = ( \e@Llist, \e@Rlist );
\&    @intersection = get_intersection( \e@to_be_compared );
.Ve
.Sp
Beginning with version 0.29 (May 2004), List::Compare::Functional now offers
an additional way of passing arguments to its various functions.  If you
prefer to see a more explicit delineation among the types of arguments passed
to a function, pass a single hash reference which holds the lists being
compared in an anonymous array which is the value corresponding to key \f(CW\*(C`lists\*(C'\fR:
.Sp
.Vb 3
\&    @intersection = get_intersection( {
\&       lists => [ \e@Llist, \e@Rlist ],
\&    } );
.Ve
.IP "\(bu" 4
Get those items which appear at least once in either list (their union).
.Sp
.Vb 1
\&    @union = get_union( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    @union = get_union( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Get those items which appear (at least once) only in the first list.
.Sp
.Vb 1
\&    @Lonly = get_unique( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    @Lonly = get_unique( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Get those items which appear (at least once) only in the second list.
.Sp
.Vb 1
\&    @Ronly = get_complement( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    @Ronly = get_complement( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4

.Sp
.Vb 1
\&    @LorRonly = get_symmetric_difference( [ \e@Llist, \e@Rlist ] );
\&
\&    @LorRonly = get_symdiff( [ \e@Llist, \e@Rlist ] );       # alias
.Ve
.Sp
or
.Sp
.Vb 1
\&    @LorRonly = get_symmetric_difference( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Make a bag of all those items in both lists.  The bag differs from the
union of the two lists in that it holds as many copies of individual
elements as appear in the original lists.
.Sp
.Vb 1
\&    @bag = get_bag( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    @bag = get_bag( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
An alternative approach to the above functions:  If you do not immediately
require an array as the return value of the function call, but simply need
a \fIreference\fR to an (anonymous) array, use one of the following
parallel functions:
.Sp
.Vb 8
\&    $intersection_ref = get_intersection_ref(         [ \e@Llist, \e@Rlist ] );
\&    $union_ref        = get_union_ref(                [ \e@Llist, \e@Rlist ] );
\&    $Lonly_ref        = get_unique_ref(               [ \e@Llist, \e@Rlist ] );
\&    $Ronly_ref        = get_complement_ref(           [ \e@Llist, \e@Rlist ] );
\&    $LorRonly_ref     = get_symmetric_difference_ref( [ \e@Llist, \e@Rlist ] );
\&    $LorRonly_ref     = get_symdiff_ref(              [ \e@Llist, \e@Rlist ] );
\&                            # alias
\&    $bag_ref          = get_bag_ref(                  [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 10
\&    $intersection_ref =
\&        get_intersection_ref(         { lists => [ \e@Llist, \e@Rlist ] } );
\&    $union_ref        =
\&        get_union_ref(                { lists => [ \e@Llist, \e@Rlist ] } );
\&    $Lonly_ref        =
\&        get_unique_ref(               { lists => [ \e@Llist, \e@Rlist ] } );
\&    $Ronly_ref        =
\&        get_complement_ref(           { lists => [ \e@Llist, \e@Rlist ] } );
\&    $LorRonly_ref     =
\&        get_symmetric_difference_ref( { lists => [ \e@Llist, \e@Rlist ] } );
\&    $LorRonly_ref     =
\&        get_symdiff_ref(              { lists => [ \e@Llist, \e@Rlist ] } );
\&        # alias
\&    $bag_ref          =
\&        get_bag_ref(                  { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Return a true value if the first list ('L' for 'left') is a subset of the
second list ('R' for 'right').
.Sp
.Vb 1
\&    $LR = is_LsubsetR( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    $LR = is_LsubsetR( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Return a true value if R is a subset of L.
.Sp
.Vb 1
\&    $RL = is_RsubsetL( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    $RL = is_RsubsetL( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Return a true value if L and R are equivalent, \fIi.e.,\fR if every element
in L appears at least once in R and \fIvice versa\fR.
.Sp
.Vb 2
\&    $eqv = is_LequivalentR( [ \e@Llist, \e@Rlist ] );
\&    $eqv = is_LeqvlntR( [ \e@Llist, \e@Rlist ] );            # alias
.Ve
.Sp
or
.Sp
.Vb 1
\&    $eqv = is_LequivalentR( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Return a true value if L and R are disjoint, \fIi.e.,\fR if L and R have
no common elements.
.Sp
.Vb 1
\&    $disj = is_LdisjointR( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    $disj = is_LdisjointR( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Pretty-print a chart showing whether one list is a subset of the other.
.Sp
.Vb 1
\&    print_subset_chart( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    print_subset_chart( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Pretty-print a chart showing whether the two lists are equivalent (same
elements found at least once in both).
.Sp
.Vb 1
\&    print_equivalence_chart( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    print_equivalence_chart( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Determine in \fIwhich\fR (if any) of the lists a given string can be found.
In list context, return a list of those indices in the argument list
corresponding to lists holding the string being tested.
.Sp
.Vb 1
\&    @memb_arr = is_member_which( [ \e@Llist, \e@Rlist ] , [ \*(Aqabel\*(Aq ] );
.Ve
.Sp
or
.Sp
.Vb 4
\&    @memb_arr = is_member_which( {
\&        lists => [ \e@Llist, \e@Rlist ],  # value is array reference
\&        item  => \*(Aqabel\*(Aq,                # value is string
\&    } );
.Ve
.Sp
In the example above, \f(CW@memb_arr\fR will be:
.Sp
.Vb 1
\&    ( 0 )
.Ve
.Sp
because \f(CW\*(Aqabel\*(Aq\fR is found only in \f(CW@Al\fR which holds position \f(CW0\fR in the
list of arguments passed to \f(CW\*(C`new()\*(C'\fR.
.IP "\(bu" 4
As with other List::Compare::Functional functions which return a list, you
may wish the above function returned a (scalar) reference to an array
holding the list:
.Sp
.Vb 1
\&    $memb_arr_ref = is_member_which_ref( [ \e@Llist, \e@Rlist ] , [ \*(Aqbaker\*(Aq ] );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $memb_arr_ref = is_member_which_ref( {
\&        lists => [ \e@Llist, \e@Rlist ],  # value is array reference
\&        item  => \*(Aqbaker\*(Aq,               # value is string
\&    } );
.Ve
.Sp
In the example above, \f(CW$memb_arr_ref\fR will be:
.Sp
.Vb 1
\&    [ 0, 1 ]
.Ve
.Sp
because \f(CW\*(Aqbaker\*(Aq\fR is found in \f(CW@Llist\fR and \f(CW@Rlist\fR, which hold positions
\&\f(CW0\fR and \f(CW1\fR, respectively, in the list of arguments passed to \f(CW\*(C`new()\*(C'\fR.
.Sp
\&\fBNote:\fR  functions \f(CW\*(C`is_member_which()\*(C'\fR and \f(CW\*(C`is_member_which_ref\*(C'\fR test
only one string at a time and hence take only one argument.  To test more
than one string at a time see the next function, \f(CW\*(C`are_members_which()\*(C'\fR.
.IP "\(bu" 4
Determine in \f(CW\*(C`which\*(C'\fR (if any) of the lists passed as arguments one or
more given strings can be found.  The lists beings searched are placed in an
array, a reference to which is the first argument passed to
\&\f(CW\*(C`are_members_which()\*(C'\fR.  The strings to be tested are also placed in an
array, a reference to which is the second argument passed to that function.
.Sp
.Vb 4
\&    $memb_hash_ref =
\&        are_members_which( [ \e@Llist, \e@Rlist ] ,
\&                           [ qw| abel baker fargo hilton zebra | ]
\&                         );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $memb_hash_ref = are_members_which( {
\&        lists => [ \e@Llist, \e@Rlist ],                    # value is arrayref
\&        items => [ qw| abel baker fargo hilton zebra | ], # value is arrayref
\&    } );
.Ve
.Sp
The return value is a reference to a hash of arrays.  The
key for each element in this hash is the string being tested.  Each element's
value is a reference to an anonymous array whose elements are those indices in
the constructor's argument list corresponding to lists holding the strings
being tested.  In the examples above, \f(CW$memb_hash_ref\fR will be:
.Sp
.Vb 7
\&    {
\&         abel     => [ 0    ],
\&         baker    => [ 0, 1 ],
\&         fargo    => [ 0, 1 ],
\&         hilton   => [    1 ],
\&         zebra    => [      ],
\&    };
.Ve
.Sp
\&\fBNote:\fR  \f(CW\*(C`are_members_which()\*(C'\fR can take more than one argument;
\&\f(CW\*(C`is_member_which()\*(C'\fR and \f(CW\*(C`is_member_which_ref()\*(C'\fR each take only one argument.
Unlike those functions, \f(CW\*(C`are_members_which()\*(C'\fR returns a hash reference.
.IP "\(bu" 4
Determine whether a given string can be found in \fIany\fR of the lists passed as
arguments.  Return \f(CW1\fR if a specified string can be found in any of the lists
and \f(CW0\fR if not.
.Sp
.Vb 1
\&    $found = is_member_any( [ \e@Llist, \e@Rlist ] , [ \*(Aqabel\*(Aq ] );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $found = is_member_any( {
\&        lists => [ \e@Llist, \e@Rlist ], # value is array reference
\&        item  => \*(Aqabel\*(Aq,               # value is string
\&    } );
.Ve
.Sp
In the example above, \f(CW$found\fR will be \f(CW1\fR because \f(CW\*(Aqabel\*(Aq\fR is found in one
or more of the lists passed as arguments to \f(CW\*(C`new()\*(C'\fR.
.IP "\(bu" 4
Determine whether a specified string or strings can be found in \fIany\fR of the
lists passed as arguments. The lists beings searched are placed in an
array, a reference to which is the first argument passed to
\&\f(CW\*(C`are_members_any()\*(C'\fR.  The strings to be tested are also placed in an
array, a reference to which is the second argument passed to that function.
.Sp
.Vb 4
\&    $memb_hash_ref =
\&        are_members_any( [ \e@Llist, \e@Rlist ] ,
\&                         [ qw| abel baker fargo hilton zebra | ]
\&                       );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $memb_hash_ref = are_members_any( {
\&        lists => [ \e@Llist, \e@Rlist ],                    # value is arrayref
\&        items => [ qw| abel baker fargo hilton zebra | ], # value is arrayref
\&    } );
.Ve
.Sp
The return value is a reference to a hash where an element's key is the
string being tested and the element's value is \f(CW1\fR if the string can be
found in \fIany\fR of the lists and \f(CW0\fR if not.  In the examples above,
\&\f(CW$memb_hash_ref\fR will be:
.Sp
.Vb 7
\&    {
\&         abel     => 1,
\&         baker    => 1,
\&         fargo    => 1,
\&         hilton   => 1,
\&         zebra    => 0,
\&    };
.Ve
.Sp
\&\f(CW\*(C`zebra\*(C'\fR's value is \f(CW0\fR because \f(CW\*(C`zebra\*(C'\fR is not found in either of the lists
passed as arguments to \f(CW\*(C`are_members_any()\*(C'\fR.
.IP "\(bu" 4
Return current List::Compare::Functional version number.
.Sp
.Vb 1
\&    $vers = get_version;
.Ve
.SS "Comparing Three or More Lists Held in Arrays"
.IX Subsection "Comparing Three or More Lists Held in Arrays"
Given five lists:
.PP
.Vb 5
\&    @Al     = qw(abel abel baker camera delta edward fargo golfer);
\&    @Bob    = qw(baker camera delta delta edward fargo golfer hilton);
\&    @Carmen = qw(fargo golfer hilton icon icon jerky kappa);
\&    @Don    = qw(fargo icon jerky);
\&    @Ed     = qw(fargo icon icon jerky);
.Ve
.IP "\(bu" 4
Get those items which appear at least once in \fIeach\fR list (their intersection).
.Sp
.Vb 1
\&    @intersection = get_intersection( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
or
.Sp
.Vb 3
\&    @intersection = get_intersection( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&    } );
.Ve
.IP "\(bu" 4
Get those items which appear at least once in \fIany\fR of the lists (their union).
.Sp
.Vb 1
\&    @union = get_union( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
or
    \f(CW@union\fR = get_union( {
        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
    } );
.IP "\(bu" 4
To get those items which are unique to a particular list, provide \f(CW\*(C`get_unique()\*(C'\fR
with two array references.  The first holds references to the arrays
which in turn hold the individual lists being compared.  The second holds
the index position in the first reference of the particular list under
consideration.  Example:  To get elements unique to \f(CW@Carmen\fR:
.Sp
.Vb 4
\&    @Lonly = get_unique(
\&                 [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&                 [ 2 ]
\&             );
.Ve
.Sp
or
.Sp
.Vb 4
\&    @Lonly = get_unique( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], # value is arrayref
\&        item  => 2,                                      # value is number
\&    } );
.Ve
.Sp
If no index position is passed to \f(CW\*(C`get_unique()\*(C'\fR it will default to \f(CW0\fR
and report items unique to the first list passed to the function.  Hence,
.Sp
.Vb 1
\&    @Lonly = get_unique( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
is same as:
.Sp
.Vb 1
\&    @Lonly = get_unique( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], [ 0 ] );
.Ve
.IP "\(bu" 4
Should you need to identify the items unique to \fIeach\fR of the lists under
consideration, call \f(CW\*(C`get_unique_all\*(C'\fR and get a reference to an array of
array references:
.Sp
.Vb 3
\&    $unique_all_ref = get_unique_all(
\&        [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ]
\&    );
.Ve
.Sp
or
.Sp
.Vb 3
\&    $unique_all_ref = get_unique_all( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&    } );
.Ve
.IP "\(bu" 4
To get those items which appear only in lists \fIother than\fR one particular
list, pass two array references to the \f(CW\*(C`get_complement()\*(C'\fR  function.
The first holds references to the arrays which in turn hold the individual lists
being compared.  The second holds the index position in the first reference
of the particular list under consideration.  Example:  to get all the
elements found in lists other than \f(CW@Don\fR:
.Sp
.Vb 4
\&    @Ronly = get_complement(
\&                 [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&                 [ 3 ]
\&             );
.Ve
.Sp
or
.Sp
.Vb 4
\&    @Ronly = get_complement( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], # value is arrayref
\&        item  => 3,                                      # value is number
\&    } );
.Ve
.Sp
If no index position is passed to \f(CW\*(C`get_complement()\*(C'\fR it will default to \f(CW0\fR
and report items found in all lists \fIother than\fR the first list passed to
\&\f(CW\*(C`get_complement()\*(C'\fR.
.Sp
.Vb 1
\&    @Lonly = get_complement( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
is same as:
.Sp
.Vb 1
\&    @Lonly = get_complement( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], [ 0 ] );
.Ve
.IP "\(bu" 4
Should you need to identify the items not found in \fIeach\fR of the lists under
consideration, call \f(CW\*(C`get_complement_all\*(C'\fR and get a reference to an array of
array references:
.Sp
.Vb 3
\&    $complement_all_ref = get_complement_all(
\&        [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ]
\&    );
.Ve
.Sp
or
.Sp
.Vb 3
\&    $complement_all_ref = get_complement_all( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&    } );
.Ve
.IP "\(bu" 4
Get those items which do \fInot\fR appear in \fImore than one\fR of several lists
(their symmetric_difference);
.Sp
.Vb 2
\&    @LorRonly = get_symmetric_difference( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    @LorRonly = get_symdiff( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] ); # alias
.Ve
.Sp
or
.Sp
.Vb 3
\&    @LorRonly = get_symmetric_difference( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&    } );
.Ve
.IP "\(bu" 4
Get those items found in \fIany\fR of several lists which do \fInot\fR appear
in \f(CW\*(C`all\*(C'\fR of the lists (\fIi.e.,\fR all items except those found in the
intersection of the lists):
.Sp
.Vb 2
\&    @nonintersection = get_nonintersection(
\&                           [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
or
.Sp
.Vb 3
\&    @nonintersection = get_nonintersection( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&    } );
.Ve
.IP "\(bu" 4
Get those items which appear in \fImore than one\fR of several lists
(\fIi.e.,\fR all items except those found in their symmetric difference);
.Sp
.Vb 1
\&    @shared = get_shared( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
or
.Sp
.Vb 3
\&    @shared = get_shared( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&    } );
.Ve
.IP "\(bu" 4
Make a bag of every item found in every list.  The bag differs from the
union of the two lists in that it holds as many copies of individual
elements as appear in the original lists.
.Sp
.Vb 1
\&    @bag = get_bag( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
or
.Sp
.Vb 3
\&    @bag = get_bag( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&    } );
.Ve
.IP "\(bu" 4
An alternative approach to the above functions:  If you do not immediately
require an array as the return value of the function, but simply need
a \fIreference\fR to an array, use one of the following parallel functions:
.Sp
.Vb 10
\&    $intersection_ref    = get_intersection_ref(
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $union_ref           = get_union_ref(
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $Lonly_ref           = get_unique_ref(
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $Ronly_ref           = get_complement_ref(
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $LorRonly_ref        = get_symmetric_difference_ref(
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $LorRonly_ref        = get_symdiff_ref(            # alias
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $nonintersection_ref = get_nonintersection_ref(
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $shared_ref          = get_shared_ref(
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $bag_ref             = get_bag_ref(
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.IP "\(bu" 4
To determine whether one particular list is a subset of another of the
lists passed to the function, pass to \f(CW\*(C`is_LsubsetR()\*(C'\fR two array references.
The first of these is a reference to an array of array
references, the arrays holding the lists under consideration.  The
second is a reference to a two-element array consisting of the
index of the presumed subset, followed by the index position of the presumed
superset.  A true value (\f(CW1\fR) is returned if the first (left-hand) element
in the second reference list is a subset of the second (right-hand) element;
a false value (\f(CW0\fR) is returned otherwise.
.Sp
Example:  To determine whether \f(CW@Ed\fR is a subset of \f(CW@Carmen\fR, call:
.Sp
.Vb 4
\&    $LR = is_LsubsetR(
\&              [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&              [ 4, 2 ]
\&          );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $LR = is_LsubsetR( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], # value is arrayref
\&        pair  => [ 4, 2 ],                               # value is arrayref
\&    } );
.Ve
.Sp
If only the first reference (to the array of lists) is passed to
\&\f(CW\*(C`is_LsubsetR\*(C'\fR, then the function's second argument defaults to \f(CW\*(C`(0,1)\*(C'\fR and
compares the first two lists passed to the constructor.  So,
.Sp
.Vb 1
\&    $LR = is_LsubsetR([ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
\&... is equivalent to:
.Sp
.Vb 1
\&    $LR = is_LsubsetR([ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], [0,1] );
.Ve
.IP "\(bu" 4
To reverse the order in which the particular lists are evaluated for
superset/subset status, call \f(CW\*(C`is_RsubsetL\*(C'\fR:
.Sp
.Vb 1
\&    $RL = is_RsubsetL([ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], [2,4] );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $RL = is_RsubsetL( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&        pair  => [ 2, 4 ],
\&    } );
.Ve
.IP "\(bu" 4
List::Compare::Functional considers two lists to be equivalent if
every element in one list appears at least once in R and \fIvice versa\fR.
To determine whether one particular list passed to the function is
equivalent to another of the lists passed to the function, provide
\&\f(CW\*(C`is_LequivalentR()\*(C'\fR with two array references.
The first is a reference to an array of array
references, the arrays holding the lists under consideration.  The
second of these is a reference to a two-element array consisting of the
two lists being tested for equivalence.  A true value (\f(CW1\fR) is returned if
the lists are equivalent; a false value (\f(CW0\fR) is returned otherwise.
.Sp
Example:  To determine whether \f(CW@Don\fR and \f(CW@Ed\fR are equivalent, call:
.Sp
.Vb 4
\&    $eqv = is_LequivalentR(
\&               [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&               [3,4]
\&           );
\&
\&    $eqv = is_LeqvlntR(                                # alias
\&               [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&               [3,4]
\&           );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $eqv = is_LequivalentR( {
\&        items => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&        pair  => [3,4],
\&    } );
.Ve
.Sp
If no arguments are passed, \f(CW\*(C`is_LequivalentR\*(C'\fR defaults to \f(CW\*(C`[0,1]\*(C'\fR and
compares the first two lists passed to the function. So,
.Sp
.Vb 1
\&    $eqv = is_LequivalentR( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
\&... translates to:
.Sp
.Vb 1
\&    $eqv = is_LequivalentR( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], [0,1] );
.Ve
.IP "\(bu" 4
To determine whether any two of the lists passed to the function are
disjoint from one another (\fIi.e.,\fR have no common members), provide
\&\f(CW\*(C`is_LdisjointR()\*(C'\fR with two array references.
The first is a reference to an array of array
references, the arrays holding the lists under consideration.  The
second of these is a reference to a two-element array consisting of the
two lists being tested for disjointedness.  A true value (\f(CW1\fR) is returned if
the lists are disjoint; a false value (\f(CW0\fR) is returned otherwise.
.Sp
Example:  To determine whether \f(CW@Don\fR and \f(CW@Ed\fR are disjoint, call:
.Sp
.Vb 4
\&    $disj = is_LdisjointR(
\&               [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&               [3,4]
\&           );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $disj = is_LdisjointR( {
\&        items => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&        pair  => [3,4]
\&    } );
.Ve
.IP "\(bu" 4
Pretty-print a chart showing the subset relationships among the various
source lists:
.Sp
.Vb 1
\&    print_subset_chart( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    print_subset_chart( { lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] } );
.Ve
.IP "\(bu" 4
Pretty-print a chart showing the equivalence relationships among the
various source lists:
.Sp
.Vb 1
\&    print_equivalence_chart( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    print_equivalence_chart( { lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] } );
.Ve
.IP "\(bu" 4
Determine in \fIwhich\fR (if any) of several lists a given string can be found.
Pass two array references, the first of which holds references to arrays
holding the lists under consideration, and the second of which holds a
single-item list consisting of the string being tested.
.Sp
.Vb 4
\&    @memb_arr = is_member_which(
\&                    [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&                    [ \*(Aqabel\*(Aq ]
\&                );
.Ve
.Sp
or
.Sp
.Vb 4
\&    @memb_arr = is_member_which( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], # value is arrayref
\&        item  => \*(Aqabel\*(Aq,                                 # value is string
\&    } );
.Ve
.Sp
In list context, return a list of those indices in the function's
argument list corresponding to lists holding the string being tested.
In the example above, \f(CW@memb_arr\fR will be:
.Sp
.Vb 1
\&    ( 0 )
.Ve
.Sp
because \f(CW\*(Aqabel\*(Aq\fR is found only in \f(CW@Al\fR which holds position \f(CW0\fR in the
list of arguments passed to \f(CW\*(C`is_member_which()\*(C'\fR.
.IP "\(bu" 4
As with other List::Compare::Functional functions which return a list, you may
wish the above function returned a reference to an array holding the list:
.Sp
.Vb 4
\&    $memb_arr_ref = is_member_which_ref(
\&                        [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&                        [ \*(Aqjerky\*(Aq ]
\&                    );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $memb_arr_ref = is_member_which_ref( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], # value is arrayref
\&        item  => \*(Aqjerky\*(Aq,                                # value is string
\&    } );
.Ve
.Sp
In the example above, \f(CW$memb_arr_ref\fR will be:
.Sp
.Vb 1
\&    [ 3, 4 ]
.Ve
.Sp
because \f(CW\*(Aqjerky\*(Aq\fR is found in \f(CW@Don\fR and \f(CW@Ed\fR, which hold positions
\&\f(CW3\fR and \f(CW4\fR, respectively, in the list of arguments passed to
\&\f(CW\*(C`is_member_which()\*(C'\fR.
.Sp
\&\fBNote:\fR  functions \f(CW\*(C`is_member_which()\*(C'\fR and \f(CW\*(C`is_member_which_ref\*(C'\fR test
only one string at a time and hence take only one element in the second
array reference argument.  To test more than one string at a time see
the next function, \f(CW\*(C`are_members_which()\*(C'\fR.
.IP "\(bu" 4
Determine in \f(CW\*(C`which\*(C'\fR (if any) of several lists one or more given strings
can be found.  Pass two array references, the first of which holds references
to arrays holding the lists under consideration, and the second of which
holds a list of the strings being tested.
.Sp
.Vb 4
\&    $memb_hash_ref = are_members_which(
\&                         [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&                         [ qw| abel baker fargo hilton zebra | ]
\&                     );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $memb_hash_ref = are_members_which( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],  # value is arrayref
\&        items => [ qw| abel baker fargo hilton zebra | ], # value is arrayref
\&    } );
.Ve
.Sp
The return valus is a reference to a hash of arrays.  In this hash,
each element's value is a reference to an anonymous array whose
elements are those indices in the argument list corresponding to
lists holding the strings being tested.  In the two examples above,
\&\f(CW$memb_hash_ref\fR will be:
.Sp
.Vb 7
\&    {
\&         abel     => [ 0             ],
\&         baker    => [ 0, 1          ],
\&         fargo    => [ 0, 1, 2, 3, 4 ],
\&         hilton   => [    1, 2       ],
\&         zebra    => [               ],
\&    };
.Ve
.Sp
\&\fBNote:\fR  \f(CW\*(C`are_members_which()\*(C'\fR tests more than one string at a time.  Hence,
its second array reference argument can take more than one element.
\&\f(CW\*(C`is_member_which()\*(C'\fR and \f(CW\*(C`is_member_which_ref()\*(C'\fR each take only one element
in their second array reference arguments.  \f(CW\*(C`are_members_which()\*(C'\fR returns a
hash reference; the other functions return either a list or a reference to an
array holding that list, depending on context.
.IP "\(bu" 4
Determine whether a given string can be found in \fIany\fR of several lists.
Pass two array references, the first of which holds references
to arrays holding the lists under consideration, and the second of which
holds a single-item list of the string being tested.
.Sp
.Vb 4
\&    $found = is_member_any(
\&                    [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&                    [ \*(Aqabel\*(Aq ]
\&                );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $found = is_member_any( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], # value is arrayref
\&        item  => \*(Aqabel\*(Aq,                                 # value is string
\&    } );
.Ve
.Sp
The return value is \f(CW1\fR if a specified string can be found in \fIany\fR of
the lists and \f(CW0\fR if not.  In the example above, \f(CW$found\fR will be
\&\f(CW1\fR because \f(CW\*(C`abel\*(C'\fR is found in one or more of the lists passed as
arguments to \f(CW\*(C`is_member_any()\*(C'\fR.
.IP "\(bu" 4
Determine whether a specified string or strings can be found in \fIany\fR of
several lists.  Pass two array references, the first of which holds references
to arrays holding the lists under consideration, and the second of which
holds a list of the strings being tested.
.Sp
.Vb 4
\&    $memb_hash_ref = are_members_any(
\&                         [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&                         [ qw| abel baker fargo hilton zebra | ]
\&                     );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $memb_hash_ref = are_members_any( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],  # value is arrayref
\&        items => [ qw| abel baker fargo hilton zebra | ], # value is arrayref
\&    } );
.Ve
.Sp
The return value is a reference to a hash where an element's key is the
string being tested and the element's value is \f(CW1\fR if the string can be
found in any of the lists and \f(CW0\fR if not.  In the example above,
\&\f(CW$memb_hash_ref\fR will be:
.Sp
.Vb 7
\&    {
\&         abel     => 1,
\&         baker    => 1,
\&         fargo    => 1,
\&         hilton   => 1,
\&         zebra    => 0,
\&    };
.Ve
.Sp
\&\f(CW\*(C`zebra\*(C'\fR's value is \f(CW0\fR because \f(CW\*(C`zebra\*(C'\fR is not found in any of the lists
passed as arguments to \f(CW\*(C`are_members_any()\*(C'\fR.
.IP "\(bu" 4
Return current List::Compare::Functional version number:
.Sp
.Vb 1
\&    $vers = get_version;
.Ve
.SS "Comparing Lists Held in Seen-Hashes"
.IX Subsection "Comparing Lists Held in Seen-Hashes"
What is a seen-hash?  A seen-hash is a typical Perl implementation of a
look-up table:  a hash where the value for a given element represents the number
of times the element's key is observed in a list.  For the purposes of
List::Compare::Functional, what is crucial is whether an item is observed in a
list or not; how many times the item occurs in a list is, \fIwith one exception,\fR
irrelevant.  (That exception is the \f(CW\*(C`get_bag()\*(C'\fR function and its fraternal
twin \f(CW\*(C`get_bag_ref()\*(C'\fR.  In this case only, the key in each element of the
seen-hash is placed in the bag the number of times indicated by the value of
that element.)  The value of an element in a List::Compare seen-hash must be
a positive integer, but whether that integer is 1 or 1,000,001 is immaterial for
all List::Compare::Functional functions \fIexcept\fR forming a bag.
.PP
The two lists compared above were represented by arrays; references to
those arrays were passed to the various List::Compare::Functional functions.
They could, however, have been represented by seen-hashes such as the following
and passed in exactly the same manner to the various functions.
.PP
.Vb 10
\&    %Llist = (
\&        abel   => 2,
\&        baker  => 1,
\&        camera => 1,
\&        delta  => 1,
\&        edward => 1,
\&        fargo  => 1,
\&        golfer => 1,
\&    );
\&    %Rlist = (
\&        baker  => 1,
\&        camera => 1,
\&        delta  => 2,
\&        edward => 1,
\&        fargo  => 1,
\&        golfer => 1,
\&        hilton => 1,
\&    );
\&
\&    @intersection = get_intersection( [ \e%Llist, \e%Rlist ] );
\&    @union        = get_union(        [ \e%Llist, \e%Rlist ] );
\&    @complement   = get_complement(   [ \e%Llist, \e%Rlist ] );
.Ve
.PP
and so forth.
.PP
To compare three or more lists simultaneously, provide the appropriate
List::Compare::Functional function with a first array reference holding a
list of three or more references to seen-hashes.  Thus,
.PP
.Vb 1
\&    @union = get_intersection( [ \e%Alpha, \e%Beta, \e%Gamma ] );
.Ve
.PP
The 'single hashref' format for List::Compare::Functional functions is
also available when passing seen-hashes as arguments.  Examples:
.PP
.Vb 3
\&    @intersection = get_intersection( {
\&        lists => [ \e%Alpha, \e%Beta, \e%Gamma ],
\&    } );
\&
\&    @Ronly = get_complement( {
\&        lists => [ \e%Alpha, \e%Beta, \e%Gamma ],
\&        item  => 3,
\&    } );
\&
\&    $LR = is_LsubsetR( {
\&        lists => [ \e%Alpha, \e%Beta, \e%Gamma ],
\&        pair  => [ 4, 2 ],
\&    } );
\&
\&    $memb_hash_ref = are_members_any( {
\&        lists => [ \e%Alpha, \e%Beta, \e%Gamma ],
\&        items => [ qw| abel baker fargo hilton zebra | ],
\&    } );
.Ve
.SS "Faster Results with the Unsorted Option"
.IX Subsection "Faster Results with the Unsorted Option"
By default, List::Compare::Function functions return lists sorted in Perl's
default ASCII-betical mode.  Sorting entails a performance cost, and if you
do not need a sorted list and do not wish to pay this performance cost, you
may call the following List::Compare::Function functions with the 'unsorted'
option:
.PP
.Vb 6
\&    @intersection = get_intersection(        \*(Aq\-u\*(Aq,  [ \e@Llist, \e@Rlist ] );
\&    @union        = get_union(               \*(Aq\-u\*(Aq,  [ \e@Llist, \e@Rlist ] );
\&    @Lonly        = get_unique(              \*(Aq\-u\*(Aq,  [ \e@Llist, \e@Rlist ] );
\&    @Ronly        = get_complement(          \*(Aq\-u\*(Aq,  [ \e@Llist, \e@Rlist ] );
\&    @LorRonly     = get_symmetric_difference(\*(Aq\-u\*(Aq,  [ \e@Llist, \e@Rlist ] );
\&    @bag          = get_bag(                 \*(Aq\-u\*(Aq,  [ \e@Llist, \e@Rlist ] );
.Ve
.PP
For greater readability, the option may be spelled out:
.PP
.Vb 1
\&    @intersection = get_intersection(\*(Aq\-\-unsorted\*(Aq,  [ \e@Llist, \e@Rlist ] );
.Ve
.PP
or
.PP
.Vb 4
\&    @intersection = get_intersection( {
\&        unsorted => 1,
\&        lists    => [ \e@Llist, \e@Rlist ],
\&    } );
.Ve
.PP
Should you need a reference to an unsorted list as the return value, you
may call the unsorted option as follows:
.PP
.Vb 4
\&    $intersection_ref = get_intersection_ref(
\&                            \*(Aq\-u\*(Aq,         [ \e@Llist, \e@Rlist ] );
\&    $intersection_ref = get_intersection_ref(
\&                            \*(Aq\-\-unsorted\*(Aq, [ \e@Llist, \e@Rlist ] );
.Ve
.SH "DISCUSSION"
.IX Header "DISCUSSION"
.SS "General Comments"
.IX Subsection "General Comments"
List::Compare::Functional is a non-object-oriented implementation of very
common Perl code used to determine interesting relationships between two
or more lists at a time.  List::Compare::Functional is based on the same
author's List::Compare module found in the same \s-1CPAN\s0 distribution.
List::Compare::Functional is closely modeled on the ''Accelerated''
mode in List::Compare.
.PP
For a discussion of the antecedents of this module, see the discussion of the
history and development of this module in the documentation to List::Compare.
.SS "List::Compare::Functional's Export Tag Groups"
.IX Subsection "List::Compare::Functional's Export Tag Groups"
By default, List::Compare::Functional exports no functions.  You may import
individual functions into your main package but may find it more convenient to
import via export tag groups.  Four such groups are currently defined:
.PP
.Vb 4
\&    use List::Compare::Functional qw(:main)
\&    use List::Compare::Functional qw(:mainrefs)
\&    use List::Compare::Functional qw(:originals)
\&    use List::Compare::Functional qw(:aliases)
.Ve
.IP "\(bu" 4
Tag group \f(CW\*(C`:main\*(C'\fR includes what, in the author's opinion, are the six
List::Compare::Functional subroutines mostly likely to be used:
.Sp
.Vb 6
\&    get_intersection()
\&    get_union()
\&    get_unique()
\&    get_complement()
\&    get_symmetric_difference()
\&    is_LsubsetR()
.Ve
.IP "\(bu" 4
Tag group \f(CW\*(C`:mainrefs\*(C'\fR includes five of the six subroutines found in
\&\f(CW\*(C`:main\*(C'\fR \*(-- all except \f(CW\*(C`is_LsubsetR()\*(C'\fR \*(-- in the form in which they
return references to arrays rather than arrays proper:
.Sp
.Vb 5
\&    get_intersection_ref()
\&    get_union_ref()
\&    get_unique_ref()
\&    get_complement_ref()
\&    get_symmetric_difference_ref()
.Ve
.IP "\(bu" 4
Tag group \f(CW\*(C`:originals\*(C'\fR includes all List::Compare::Functional subroutines
in their 'original' form, \fIi.e.\fR, no aliases for those subroutines:
.Sp
.Vb 10
\&    get_intersection
\&    get_intersection_ref
\&    get_union
\&    get_union_ref
\&    get_unique
\&    get_unique_ref
\&    get_unique_all
\&    get_complement
\&    get_complement_ref
\&    get_complement_all
\&    get_symmetric_difference
\&    get_symmetric_difference_ref
\&    get_shared
\&    get_shared_ref
\&    get_nonintersection
\&    get_nonintersection_ref
\&    is_LsubsetR
\&    is_RsubsetL
\&    is_LequivalentR
\&    is_LdisjointR
\&    is_member_which
\&    is_member_which_ref
\&    are_members_which
\&    is_member_any
\&    are_members_any
\&    print_subset_chart
\&    print_equivalence_chart
\&    get_bag
\&    get_bag_ref
.Ve
.IP "\(bu" 4
Tag group \f(CW\*(C`:aliases\*(C'\fR contains all List::Compare::Functional subroutines
which are aliases for subroutines found in tag group \f(CW\*(C`:originals\*(C'\fR.  These
are provided simply for less typing.
.Sp
.Vb 3
\&    get_symdiff
\&    get_symdiff_ref
\&    is_LeqvlntR
.Ve
.SS "April 2004 Change of Interface"
.IX Subsection "April 2004 Change of Interface"
\&\fBNote:\fR  You can skip this section unless you used List::Compare::Functional
prior to the release of Version 0.25 in April 2004.
.PP
Version 0.25 initiated a significant change in the interface to
this module's various functions.  In order to be able to accommodate
comparisons among more than two lists, it was necessary to change the type
of arguments passed to the various functions.  Whereas previously a
typical List::Compare::Functional function would be called like this:
.PP
.Vb 1
\&    @intersection = get_intersection( \e@Llist, \e@Rlist ); # SUPERSEDED
.Ve
.PP
\&... now the references to the lists being compared must now be placed
within a wrapper array (anonymous or named), a reference to which is
now passed to the function, like so:
.PP
.Vb 1
\&    @intersection = get_intersection( [ \e@Llist, \e@Rlist ] );
.Ve
.PP
\&... or, alternatively:
.PP
.Vb 2
\&    @to_be_compared = (\e@Llist, \e@Rlist);
\&    @intersection = get_intersection( \e@to_be_compared );
.Ve
.PP
In a similar manner, List::Compare::Functional functions could previously
take arguments in the form of references to 'seen\-hashes' instead of
references to arrays:
.PP
.Vb 1
\&    @intersection = get_intersection( \e%h0, \e%h1 );
.Ve
.PP
(See above for discussion of seen-hashes.)  Now, those references to
seen-hashes must be placed within a wrapper array (anonymous or named),
a reference to which is passed to the function, like so:
.PP
.Vb 1
\&    @intersection = get_intersection( [ \e%h0, \e%h1 ] );
.Ve
.PP
Also, in a similar manner, some List::Compare::Functional functions
previously took arguments in addition to the lists being compared.
These arguments were simply passed as scalars, like this:
.PP
.Vb 1
\&    @memb_arr = is_member_which(\e@Llist, \e@Rlist, \*(Aqabel\*(Aq);
.Ve
.PP
Now these arguments must also be placed within a wrapper array
(anonymous or named), a reference to which is now passed to the function,
like so:
.PP
.Vb 1
\&    @memb_arr = is_member_which( [ \e@Llist, \e@Rlist ], [ \*(Aqabel\*(Aq ] );
.Ve
.PP
\&... or, alternatively:
.PP
.Vb 3
\&    @to_be_compared = (\e@Llist, \e@Rlist);
\&    @opts = ( \*(Aqabel\*(Aq );
\&    @memb_arr = is_member_which( \e@to_be_compared, \e@opts );
.Ve
.PP
As in previous versions, for a speed boost the user may provide the
\&\f(CW\*(Aq\-u\*(Aq\fR or \f(CW\*(Aq\-\-unsorted\*(Aq\fR option as the \fIfirst\fR argument to some
List::Compare::Functional functions.  Using this option, the
\&\f(CW\*(C`get_intersection()\*(C'\fR function above would appear as:
.PP
.Vb 1
\&    @intersection = get_intersection( \*(Aq\-u\*(Aq, [ \e@Llist, \e@Rlist ] );
.Ve
.PP
\&... or, alternatively:
.PP
.Vb 1
\&    @intersection = get_intersection( \*(Aq\-\-unsorted\*(Aq, [ \e@Llist, \e@Rlist ] );
.Ve
.PP
The arguments to \fIany\fR List::Compare::Functional function will therefore
consist possibly of the unsorted option, and then of either one or two
references to arrays, the first of which is a reference to an array of
arrays or an array of seen-hashes.
.SH "AUTHOR"
.IX Header "AUTHOR"
James E. Keenan (jkeenan@cpan.org).  When sending correspondence, please
include 'List::Compare::Functional' or 'List\-Compare\-Functional' in your
subject line.
.PP
Creation date:  May 20, 2002.  Last modification date:  May 21 2015.
Copyright (c) 2002\-15 James E. Keenan.  United States.  All rights reserved.
This is free software and may be distributed under the same terms as Perl
itself.
