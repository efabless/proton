.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Netlist 3"
.TH Netlist 3 "2015-03-16" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Verilog::Netlist \- Verilog Netlist
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Verilog::Netlist;
\&
\&    # Setup options so files can be found
\&    use Verilog::Getopt;
\&    my $opt = new Verilog::Getopt;
\&    $opt\->parameter( "+incdir+verilog",
\&                     "\-y","verilog",
\&                     );
\&
\&    # Prepare netlist
\&    my $nl = new Verilog::Netlist (options => $opt,);
\&    foreach my $file (\*(Aqtestnetlist.v\*(Aq) {
\&        $nl\->read_file (filename=>$file);
\&    }
\&    # Read in any sub\-modules
\&    $nl\->link();
\&    #$nl\->lint();  # Optional, see docs; probably not wanted
\&    $nl\->exit_if_error();
\&
\&    foreach my $mod ($nl\->top_modules_sorted) {
\&        show_hier ($mod, "  ", "", "");
\&    }
\&
\&    sub show_hier {
\&        my $mod = shift;
\&        my $indent = shift;
\&        my $hier = shift;
\&        my $cellname = shift;
\&        if (!$cellname) {$hier = $mod\->name;} #top modules get the design name
\&        else {$hier .= ".$cellname";} #append the cellname
\&        printf ("%\-45s %s\en", $indent."Module ".$mod\->name,$hier);
\&        foreach my $sig ($mod\->ports_sorted) {
\&            printf ($indent."     %sput %s\en", $sig\->direction, $sig\->name);
\&        }
\&        foreach my $cell ($mod\->cells_sorted) {
\&            printf ($indent. "    Cell %s\en", $cell\->name);
\&            foreach my $pin ($cell\->pins_sorted) {
\&                printf ($indent."     .%s(%s)\en", $pin\->name, $pin\->netname);
\&            }
\&            show_hier ($cell\->submod, $indent."  ", $hier, $cell\->name) if $cell\->submod;
\&        }
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Verilog::Netlist reads and holds interconnect information about a whole
design database.
.PP
See the \*(L"Which Package\*(R" section of Verilog::Language if you are unsure
which parsing package to use for a new application.
.PP
A Verilog::Netlist is composed of files, which contain the text read from
each file.
.PP
A file may contain modules, which are individual blocks that can be
instantiated (designs, in Synopsys terminology.)
.PP
Modules have ports, which are the interconnection between nets in that
module and the outside world.  Modules also have nets, (aka signals), which
interconnect the logic inside that module.
.PP
Modules can also instantiate other modules.  The instantiation of a module
is a Cell.  Cells have pins that interconnect the referenced module's pin
to a net in the module doing the instantiation.
.PP
Each of these types, files, modules, ports, nets, cells and pins have a
class.  For example Verilog::Netlist::Cell has the list of
Verilog::Netlist::Pin (s) that interconnect that cell.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
See also Verilog::Netlist::Subclass for additional accessors and methods.
.ie n .IP "$netlist\->lint" 4
.el .IP "\f(CW$netlist\fR\->lint" 4
.IX Item "$netlist->lint"
Error checks the entire netlist structure.  Currently there are only two
checks, that modules are bound to instantiations (which is also checked by
\&\f(CW$netlist\fR\->link), and that signals aren't multiply driven.  Note that as
there is no elaboration you may get false errors about multiple drivers
from generate statements that are mutually exclusive.  For this reason and
the few lint checks you may not want to use this method.  Alternatively to
avoid pin interconnect checks, set the \f(CW$netlist\fR\->new
(...use_vars=>0...) option.
.ie n .IP "$netlist\->\fIlink()\fR" 4
.el .IP "\f(CW$netlist\fR\->\fIlink()\fR" 4
.IX Item "$netlist->link()"
Resolves references between the different modules.
.Sp
If link_read=>1 is passed when netlist\->new is called (it is by default),
undefined modules will be searched for using the Verilog::Getopt package,
passed by a reference in the creation of the netlist.  To suppress errors
in any missing references, set link_read_nonfatal=>1 also.
.ie n .IP "$netlist\->new" 4
.el .IP "\f(CW$netlist\fR\->new" 4
.IX Item "$netlist->new"
Creates a new netlist structure.  Pass optional parameters by name,
with the following parameters:
.RS 4
.ie n .IP "implicit_wires_ok => $true_or_false" 8
.el .IP "implicit_wires_ok => \f(CW$true_or_false\fR" 8
.IX Item "implicit_wires_ok => $true_or_false"
Indicates whether to allow undeclared wires to be used.
.ie n .IP "include_open_nonfatal => $true_or_false" 8
.el .IP "include_open_nonfatal => \f(CW$true_or_false\fR" 8
.IX Item "include_open_nonfatal => $true_or_false"
Indicates that include files that do not exist should be ignored.
.ie n .IP "keep_comments => $true_or_false" 8
.el .IP "keep_comments => \f(CW$true_or_false\fR" 8
.IX Item "keep_comments => $true_or_false"
Indicates that comment fields should be preserved and on net declarations
into the Vtest::Netlist::Net structures.  Otherwise all comments are
stripped for speed.
.ie n .IP "link_read => $true_or_false" 8
.el .IP "link_read => \f(CW$true_or_false\fR" 8
.IX Item "link_read => $true_or_false"
Indicates whether or not the parser should automatically search for
undefined modules through the \*(L"options\*(R" object.
.ie n .IP "link_read_nonfatal => $true_or_false" 8
.el .IP "link_read_nonfatal => \f(CW$true_or_false\fR" 8
.IX Item "link_read_nonfatal => $true_or_false"
Indicates that modules that referenced but not found should be ignored,
rather than causing an error message.
.IP "logger => object" 8
.IX Item "logger => object"
Specify a message handler object to be used for error handling, this class
should be a Verilog::Netlist::Logger object, or derived from one.  If
unspecified, a Verilog::Netlist::Logger local to this netlist will be
used.
.ie n .IP "options => $opt_object" 8
.el .IP "options => \f(CW$opt_object\fR" 8
.IX Item "options => $opt_object"
An optional pointer to a Verilog::Getopt object, to be used for locating
files.
.ie n .IP "parser => $package_name" 8
.el .IP "parser => \f(CW$package_name\fR" 8
.IX Item "parser => $package_name"
The name of the parser class. Defaults to \*(L"Verilog::Netlist::File::Parser\*(R".
.ie n .IP "preproc => $package_name" 8
.el .IP "preproc => \f(CW$package_name\fR" 8
.IX Item "preproc => $package_name"
The name of the preprocessor class. Defaults to \*(L"Verilog::Preproc\*(R".
.ie n .IP "synthesis => $true_or_false" 8
.el .IP "synthesis => \f(CW$true_or_false\fR" 8
.IX Item "synthesis => $true_or_false"
With synthesis set, define \s-1SYNTHESIS,\s0 and ignore text bewteen \*(L"ambit\*(R",
\&\*(L"pragma\*(R", \*(L"synopsys\*(R" or \*(L"synthesis\*(R" translate_off and translate_on meta
comments.  Note using metacomments is discouraged as they have led to
silicon bugs (versus ifdef \s-1SYNTHESIS\s0); see
<http://www.veripool.org/papers/TenIPEdits_SNUGBos07_paper.pdf>.
.ie n .IP "use_vars => $true_or_false" 8
.el .IP "use_vars => \f(CW$true_or_false\fR" 8
.IX Item "use_vars => $true_or_false"
Indicates that signals, variables, and pin interconnect information is
needed; set by default.  If clear do not read it, nor report lint related
pin warnings, which can greatly improve performance.
.RE
.RS 4
.RE
.ie n .IP "$netlist\->dump" 4
.el .IP "\f(CW$netlist\fR\->dump" 4
.IX Item "$netlist->dump"
Prints debugging information for the entire netlist structure.
.SH "INTERFACE FUNCTIONS"
.IX Header "INTERFACE FUNCTIONS"
.ie n .IP "$netlist\->find_interface($name)" 4
.el .IP "\f(CW$netlist\fR\->find_interface($name)" 4
.IX Item "$netlist->find_interface($name)"
Returns Verilog::Netlist::Interface matching given name.
.ie n .IP "$netlist\->interfaces" 4
.el .IP "\f(CW$netlist\fR\->interfaces" 4
.IX Item "$netlist->interfaces"
Returns list of Verilog::Netlist::Interface.
.ie n .IP "$netlist\->interfaces_sorted" 4
.el .IP "\f(CW$netlist\fR\->interfaces_sorted" 4
.IX Item "$netlist->interfaces_sorted"
Returns name sorted list of Verilog::Netlist::Interface.
.ie n .IP "$netlist\->new_interface" 4
.el .IP "\f(CW$netlist\fR\->new_interface" 4
.IX Item "$netlist->new_interface"
Creates a new Verilog::Netlist::Interface.
.SH "MODULE FUNCTIONS"
.IX Header "MODULE FUNCTIONS"
.ie n .IP "$netlist\->find_module($name)" 4
.el .IP "\f(CW$netlist\fR\->find_module($name)" 4
.IX Item "$netlist->find_module($name)"
Returns Verilog::Netlist::Module matching given name.
.ie n .IP "$netlist\->modules" 4
.el .IP "\f(CW$netlist\fR\->modules" 4
.IX Item "$netlist->modules"
Returns list of Verilog::Netlist::Module.
.ie n .IP "$netlist\->modules_sorted" 4
.el .IP "\f(CW$netlist\fR\->modules_sorted" 4
.IX Item "$netlist->modules_sorted"
Returns name sorted list of Verilog::Netlist::Module.
.ie n .IP "$netlist\->modules_sorted_level" 4
.el .IP "\f(CW$netlist\fR\->modules_sorted_level" 4
.IX Item "$netlist->modules_sorted_level"
Returns level sorted list of Verilog::Netlist::Module.  Leaf modules will
be first, the top most module will be last.
.ie n .IP "$netlist\->new_module" 4
.el .IP "\f(CW$netlist\fR\->new_module" 4
.IX Item "$netlist->new_module"
Creates a new Verilog::Netlist::Module.
.ie n .IP "$netlist\->new_root_module" 4
.el .IP "\f(CW$netlist\fR\->new_root_module" 4
.IX Item "$netlist->new_root_module"
Creates a new Verilog::Netlist::Module for \f(CW$root\fR, if one doesn't already
exist.
.ie n .IP "$netlist\->top_modules_sorted" 4
.el .IP "\f(CW$netlist\fR\->top_modules_sorted" 4
.IX Item "$netlist->top_modules_sorted"
Returns name sorted list of Verilog::Netlist::Module, only for those
modules which have no children and are not unused library cells.
.SH "FILE FUNCTIONS"
.IX Header "FILE FUNCTIONS"
.ie n .IP "$netlist\->dependency_write(\fIfilename\fR)" 4
.el .IP "\f(CW$netlist\fR\->dependency_write(\fIfilename\fR)" 4
.IX Item "$netlist->dependency_write(filename)"
Writes a dependency file for make, listing all input and output files.
.ie n .IP "$netlist\->defvalue_nowarn (\fIdefine\fR)" 4
.el .IP "\f(CW$netlist\fR\->defvalue_nowarn (\fIdefine\fR)" 4
.IX Item "$netlist->defvalue_nowarn (define)"
Return the value of the specified define or undef.
.ie n .IP "$netlist\->dependency_in(\fIfilename\fR)" 4
.el .IP "\f(CW$netlist\fR\->dependency_in(\fIfilename\fR)" 4
.IX Item "$netlist->dependency_in(filename)"
Adds an additional input dependency for dependency_write.
.ie n .IP "$netlist\->dependency_out(\fIfilename\fR)" 4
.el .IP "\f(CW$netlist\fR\->dependency_out(\fIfilename\fR)" 4
.IX Item "$netlist->dependency_out(filename)"
Adds an additional output dependency for dependency_write.
.ie n .IP "$netlist\->delete" 4
.el .IP "\f(CW$netlist\fR\->delete" 4
.IX Item "$netlist->delete"
Delete the netlist, reclaim memory.  Unfortunately netlists will not
disappear simply with normal garbage collection from leaving of scope due
to complications with reference counting and weaking Class::Struct
structures; solutions welcome.
.ie n .IP "$netlist\->files" 4
.el .IP "\f(CW$netlist\fR\->files" 4
.IX Item "$netlist->files"
Returns list of Verilog::Netlist::File.
.ie n .IP "$netlist\->files_sorted" 4
.el .IP "\f(CW$netlist\fR\->files_sorted" 4
.IX Item "$netlist->files_sorted"
Returns a name sorted list of Verilog::Netlist::File.
.ie n .IP "$netlist\->find_file($name)" 4
.el .IP "\f(CW$netlist\fR\->find_file($name)" 4
.IX Item "$netlist->find_file($name)"
Returns Verilog::Netlist::File matching given name.
.ie n .IP "$netlist\->read_file( filename=>$name)" 4
.el .IP "\f(CW$netlist\fR\->read_file( filename=>$name)" 4
.IX Item "$netlist->read_file( filename=>$name)"
Reads the given Verilog file, and returns a Verilog::Netlist::File
reference.
.Sp
Generally called as \f(CW$netlist\fR\->read_file.  Pass a hash of parameters.  Reads
the filename=> parameter, parsing all instantiations, ports, and signals,
and creating Verilog::Netlist::Module structures.
.ie n .IP "$netlist\->read_libraries ()" 4
.el .IP "\f(CW$netlist\fR\->read_libraries ()" 4
.IX Item "$netlist->read_libraries ()"
Read any libraries specified in the options=> argument passed with the
netlist constructor.  Automatically invoked when netlist linking results in
a module that wasn't found, and thus might be inside the libraries.
.ie n .IP "$netlist\->remove_defines (\fIstring\fR)" 4
.el .IP "\f(CW$netlist\fR\->remove_defines (\fIstring\fR)" 4
.IX Item "$netlist->remove_defines (string)"
Expand any `defines in the string and return the results.  Undefined
defines will remain in the returned string.
.ie n .IP "$netlist\->resolve_filename (\fIstring\fR, [\fIlookup_type\fR])" 4
.el .IP "\f(CW$netlist\fR\->resolve_filename (\fIstring\fR, [\fIlookup_type\fR])" 4
.IX Item "$netlist->resolve_filename (string, [lookup_type])"
Convert a module name to a filename.  Optional lookup_type is 'module',
\&'include', or 'all', to use only module_dirs, incdirs, or both for the
lookup.  Return undef if not found.
.ie n .IP "$self\->verilog_text" 4
.el .IP "\f(CW$self\fR\->verilog_text" 4
.IX Item "$self->verilog_text"
Returns verilog code which represents the netlist.  The netlist must be
already \->link'ed for this to work correctly.
.SH "BUGS"
.IX Header "BUGS"
Cell instantiations without any arguments are not supported, a empty set of
parenthesis are required.  (Use \*(L"cell \fIcell()\fR;\*(R", not \*(L"cell cell;\*(R".)
.PP
Order based pin interconnect is not supported, use name based connections.
.SH "DISTRIBUTION"
.IX Header "DISTRIBUTION"
Verilog-Perl is part of the <http://www.veripool.org/> free Verilog \s-1EDA\s0
software tool suite.  The latest version is available from \s-1CPAN\s0 and from
<http://www.veripool.org/verilog\-perl>.
.PP
Copyright 2000\-2015 by Wilson Snyder.  This package is free software; you
can redistribute it and/or modify it under the terms of either the \s-1GNU\s0
Lesser General Public License Version 3 or the Perl Artistic License Version 2.0.
.SH "AUTHORS"
.IX Header "AUTHORS"
Wilson Snyder <wsnyder@wsnyder.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Verilog-Perl,
Verilog::Netlist::Cell,
Verilog::Netlist::File,
Verilog::Netlist::Interface,
Verilog::Netlist::Logger,
Verilog::Netlist::ModPort,
Verilog::Netlist::Module,
Verilog::Netlist::Net,
Verilog::Netlist::Pin,
Verilog::Netlist::Port,
Verilog::Netlist::Subclass
.PP
And the <http://www.veripool.org/verilog\-mode>Verilog-Mode package for Emacs.
