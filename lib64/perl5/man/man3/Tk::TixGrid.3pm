.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TixGrid 3"
.TH TixGrid 3 "2013-11-15" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tk::TixGrid \- Create and manipulate Tix Grid widgets
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\ \ \ \ \fI\f(CI$tixgrid\fI\fR = \fI\f(CI$parent\fI\fR\->\fBTixGrid\fR?(\fIoptions\fR)?;
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This widget is intended as the basis of \*(L"spread sheet\*(R" like interfaces.
The widget displays its contents in a two dimensional \*(L"grid\*(R" of cells.
Each cell may contain one Tix display item, which may be in text,
graphics or other formats. See Tk::DItem for more information
about Tix display items. Because these \*(L"items\*(R" need not be \*(L"windows\*(R" large
grids can be handled  without consuming excessive display system resources.
.PP
Individual cells, or groups of cells, can be formatted with a wide range of
attributes, such as its color, relief and border. However because the
widget is intended to handle large grids the mechanisms to achieve these
are lower level, and more callback oriented than for other widgets. The
assumption is that to avoid storing display details of a large number
of cells, the data will be re-computed as needed.
.PP
The port of Tix C code and some of the bindings to perl/Tk is done but still
need further work. In several places the intent of the Tix code is not
yet understood. For example the 'edit' interface is clearly intended
for spread-sheet like cell content editing in an auxillary \*(L"entry\*(R" widget
or similar, but how that should work is not yet clear.
.PP
The \fBTixGrid\fR method creates a new TixGrid window and returns a
blessed reference of this TixGrid widget.  Additional options,
described below, may be specified on the command line or in the
option database to configure aspects of the \fBTixGrid\fR widget.
.SH "STANDARD OPTIONS"
.IX Header "STANDARD OPTIONS"
\&\fB\-background\fR
	\fB\-borderwidth\fR
	\fB\-cursor\fR
	\fB\-font\fR
	\fB\-foreground\fR
	\fB\-height\fR
	\fB\-highlightbackground\fR
	\fB\-highlightcolor\fR
	\fB\-highlightthickness\fR
	\fB\-padx\fR
	\fB\-pady\fR
	\fB\-relief\fR
	\fB\-selectbackground\fR
	\fB\-selectborderwidth\fR
	\fB\-selectforeground\fR
	\fB\-state\fR
	\fB\-takefocus\fR
	\fB\-width\fR
	\fB\-xscrollcommand\fR
	\fB\-yscrollcommand\fR
.PP
See Tk::options for details of the standard options.
.SH "WIDGET-SPECIFIC OPTIONS"
.IX Header "WIDGET-SPECIFIC OPTIONS"
.IP "Name:	\fBbrowseCmd\fR" 4
.IX Item "Name: browseCmd"
.PD 0
.IP "Class:	\fBBrowseCmd\fR" 4
.IX Item "Class: BrowseCmd"
.IP "Switch:	\fB\-browsecmd\fR" 4
.IX Item "Switch: -browsecmd"
.PD
If defined, gives a perl/Tk callback to be executed when the
user browses a grid cell (This is normally the case when the user clicks on an
entry).  When this callback is called, it is passed with two additional
parameters: \fIx\fR \fIy\fR, where (\fIx\fR,\fIy\fR) is the location of the cell that has
just been clicked.
.IP "Name:	\fBCommand\fR" 4
.IX Item "Name: Command"
.PD 0
.IP "Class:	\fBCommand\fR" 4
.IX Item "Class: Command"
.IP "Switch:	\fB\-command\fR" 4
.IX Item "Switch: -command"
.PD
If defined, gives a perl/Tk callback to be executed when the
user double-clicks a grid cell.  When this callback is called, it is passed
with two additional parameters: \fIx\fR \fIy\fR, where (\fIx\fR,\fIy\fR) is the location of
the cell that has just been clicked.
.IP "Name:	\fBeditDoneCmd\fR" 4
.IX Item "Name: editDoneCmd"
.PD 0
.IP "Class:	\fBEditDoneCmd\fR" 4
.IX Item "Class: EditDoneCmd"
.IP "Switch:	\fB\-editdonecmd\fR" 4
.IX Item "Switch: -editdonecmd"
.PD
If defined, gives a perl/Tk callback
to be executed when the
user has edited grid cell. When this callback is called, it is
passed with two additional parameters: \fIx\fR \fIy\fR, where (\fIx\fR,\fIy\fR)
is the location of the cell that has just been edited.
.IP "Name:	\fBeditNotifyCmd\fR" 4
.IX Item "Name: editNotifyCmd"
.PD 0
.IP "Class:	\fBEditNotifyCmd\fR" 4
.IX Item "Class: EditNotifyCmd"
.IP "Switch:	\fB\-editnotifycmd\fR" 4
.IX Item "Switch: -editnotifycmd"
.PD
If defined gives a perl/Tk callback
to be executed when the user tries to edit a grid cell.
When this callback is called, it is passed with two additional
parameters: \fIx\fR \fIy\fR, where (\fIx\fR,\fIy\fR,) is the location
of the cell. This callback should return a boolean value: \fBtrue\fR
indicates that the cell is editable and \fBfalse\fR otherwise.
.IP "Name:	\fBFloatingCols\fR" 4
.IX Item "Name: FloatingCols"
.PD 0
.IP "Class:	\fBfloatingCols\fR" 4
.IX Item "Class: floatingCols"
.IP "Switch:	\fB\-floatingcols\fR" 4
.IX Item "Switch: -floatingcols"
.PD
Defines the number of extra columns beyond the existing grid
that can be brought into view by scrolling.
.IP "Name:	\fBFloatingRows\fR" 4
.IX Item "Name: FloatingRows"
.PD 0
.IP "Class:	\fBfloatingRows\fR" 4
.IX Item "Class: floatingRows"
.IP "Switch:	\fB\-floatingrows\fR" 4
.IX Item "Switch: -floatingrows"
.PD
Defines the number of extra rows beyond the the existing grid
that can be brought into view by scrolling.
.IP "Name:	\fBformatCmd\fR" 4
.IX Item "Name: formatCmd"
.PD 0
.IP "Class:	\fBFormatCmd\fR" 4
.IX Item "Class: FormatCmd"
.IP "Switch:	\fB\-formatcmd\fR" 4
.IX Item "Switch: -formatcmd"
.PD
If defined, gives a perl/Tk callback to be
executed when the grid cells need to be displayed on the screen.
Its primary purpose is to draw the background of the region
before the cells are rendered on top. This is normally
achieved by calling \fBformatGrid\fR or \fBformatBorder\fR (see below).
However other uses can  be made of this low-level callback. For example it can be used
to \*(L"lazily\*(R" populate the grid by calling the \fBset\fR method only as cells come
into view.
.Sp
When this callback is called, it is passed with five additional
parameters: \fItype\fR \fIx1\fR \fIy1\fR \fIx2\fR \fIy2\fR.
.Sp
\&\fIx1\fR \fIy1\fR \fIx2\fR \fIy2\fR gives the extent of the region that needs
formatting.
.Sp
\&\fItype\fR gives the logical type of the region in the grid. It may be one of the
following.
.RS 4
.IP "\fBx_margin\fR" 8
.IX Item "x_margin"
The horizontal margin.
.IP "\fBy_margin\fR" 8
.IX Item "y_margin"
The vertical margin.
.IP "\fBs_margin\fR" 8
.IX Item "s_margin"
The area in the top left corner where the horizontal and vertical margins
are joined.
.IP "\fBmain\fR" 8
.IX Item "main"
The main body i.e. all the cells that do not fall into the above three types.
.RE
.RS 4
.RE
.IP "Name:	\fBleftMargin\fR" 4
.IX Item "Name: leftMargin"
.PD 0
.IP "Class:	\fBLeftMargin\fR" 4
.IX Item "Class: LeftMargin"
.IP "Switch:	\fB\-leftmargin\fR" 4
.IX Item "Switch: -leftmargin"
.PD
Gives the width of vertical margin in cells (columns).
A zero indicates that no vertical margin exists. A positive value \fIN\fR
indicates that first \fIN\fR columns are \*(L"labels\*(R" and are always displayed
and not scrolled.
.IP "Name:	\fBitemType\fR" 4
.IX Item "Name: itemType"
.PD 0
.IP "Class:	\fBItemType\fR" 4
.IX Item "Class: ItemType"
.IP "Switch:	\fB\-itemtype\fR" 4
.IX Item "Switch: -itemtype"
.PD
Default item type for cells.
.IP "Name:	\fBselectMode\fR" 4
.IX Item "Name: selectMode"
.PD 0
.IP "Class:	\fBSelectMode\fR" 4
.IX Item "Class: SelectMode"
.IP "Switch:	\fB\-selectmode\fR" 4
.IX Item "Switch: -selectmode"
.PD
Specifies one of several styles for manipulating the selection.
The value of the option may be arbitrary, but the default bindings
expect it to be either \fBsingle\fR, \fBbrowse\fR, \fBmultiple\fR, or \fBextended\fR;
the default value is \fBsingle\fR.
.IP "Name:	\fBselectUnit\fR" 4
.IX Item "Name: selectUnit"
.PD 0
.IP "Class:	\fBSelectUnit\fR" 4
.IX Item "Class: SelectUnit"
.IP "Switch:	\fB\-selectunit\fR" 4
.IX Item "Switch: -selectunit"
.PD
Specifies the selection unit. Valid values are \fBcell\fR, \fBcolumn\fR or \fBrow\fR.
.IP "Name:	\fBsizeCmd\fR" 4
.IX Item "Name: sizeCmd"
.PD 0
.IP "Class:	\fBSizeCmd\fR" 4
.IX Item "Class: SizeCmd"
.IP "Switch:	\fB\-sizecmd\fR" 4
.IX Item "Switch: -sizecmd"
.PD
Callback is called (with no extra arguments) when grid sizes are
re-computed. For example if window changes size, a different font
is specified etc.
.Sp
It is called just after scrollbars (if present) are updated.
.IP "Name:	\fBtopMargin\fR" 4
.IX Item "Name: topMargin"
.PD 0
.IP "Class:	\fBTopMargin\fR" 4
.IX Item "Class: TopMargin"
.IP "Switch:	\fB\-topmargin\fR" 4
.IX Item "Switch: -topmargin"
.PD
Gives the width of horizontal margin in cells (rows).
A zero indicates that no horizontal margin exists. A positive value
\&\fIN\fR indicates that first \fIN\fR rows are \*(L"labels\*(R" and are always
displayed and not scrolled.
.SH "WIDGET METHODS"
.IX Header "WIDGET METHODS"
The \fBTixGrid\fR method creates a TixGrid widget and returns a blessed
reference of this TixGrid widget.  This reference may be used to
invoke various operations on the widget.  It has the following general
form:
.PP
\&\ \ \ \ \fI\f(CI$tixgrid\fI\fR\->\fBmethod\fR?(\fIarg, arg, ...\fR)?
.PP
\&\fIarg\fRs determine the exact behavior of the method.
.PP
This object supports the \fBconfigure\fR and \fBcget\fR methods
described in Tk::options which can be used to enquire and
modify the options described above.
The widget also inherits all the methods provided by the generic
Tk::Widget class.
.PP
The following additional methods are possible for \fBTixGrid\fR widgets:
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBanchorGet\fR(\fIx\fR, \fIy\fR)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBanchorGet\fR(\fIx\fR, \fIy\fR)" 4
.IX Item "$tixgrid->anchorGet(x, y)"
.PD 0
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBanchorSet\fR(\fIx\fR, \fIy\fR)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBanchorSet\fR(\fIx\fR, \fIy\fR)" 4
.IX Item "$tixgrid->anchorSet(x, y)"
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBanchorClear\fR" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBanchorClear\fR" 4
.IX Item "$tixgrid->anchorClear"
.PD
Manipulates the \fBanchor cell\fR of the \fBTixGrid\fR widget.
The anchor cell is the end of the selection that is fixed
while the user is dragging out a selection with the mouse.
.ie n .IP "($bd,$col,$row) = \fI\fI$tixgrid\fI\fR\->\fBbdtype\fR(\fIx,y\fR ?,\fIxDelta\fR,\fIyDelta\fR?)" 4
.el .IP "($bd,$col,$row) = \fI\f(CI$tixgrid\fI\fR\->\fBbdtype\fR(\fIx,y\fR ?,\fIxDelta\fR,\fIyDelta\fR?)" 4
.IX Item "($bd,$col,$row) = $tixgrid->bdtype(x,y ?,xDelta,yDelta?)"
Determines if the the screen (pixel) position \fIx,y\fR is in a border.
This is useful for changing the mouse cursor when the user points at a
border \- e.g. to indicate that the border can be adjusted
interactively.
.Sp
If in a border returns a list of three elements. First element
is 'xy', 'x' or 'y', second two elements are integers.
(Value of these are not understood, seem to indicate which
column and row of the border the screen position corresponds to?)
.Sp
If not in a border returns an empty list.
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBdelete\fR(\fIdim\fR, \fIfrom\fR?, \fIto\fR?)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBdelete\fR(\fIdim\fR, \fIfrom\fR?, \fIto\fR?)" 4
.IX Item "$tixgrid->delete(dim, from?, to?)"
.PD 0
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBdeleteColumn\fR(\fIfrom\fR?, \fIto\fR?)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBdeleteColumn\fR(\fIfrom\fR?, \fIto\fR?)" 4
.IX Item "$tixgrid->deleteColumn(from?, to?)"
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBdeleteRow\fR(\fIfrom\fR?, \fIto\fR?)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBdeleteRow\fR(\fIfrom\fR?, \fIto\fR?)" 4
.IX Item "$tixgrid->deleteRow(from?, to?)"
.PD
\&\fIDim\fR may be \fBrow\fR or \fBcolumn\fR. If \fIto\fR is not given,
deletes a single row (or column) at the position \fIfrom\fR.
If \fIto\fR is given, deletes the range of rows (or columns)
from position \fIfrom\fR through \fIto\fR.
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBdragsite\fR(\fIoption\fR, \fIx\fR, \fIy\fR)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBdragsite\fR(\fIoption\fR, \fIx\fR, \fIy\fR)" 4
.IX Item "$tixgrid->dragsite(option, x, y)"
.PD 0
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBdropsite\fR(\fIoption\fR, \fIx\fR, \fIy\fR)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBdropsite\fR(\fIoption\fR, \fIx\fR, \fIy\fR)" 4
.IX Item "$tixgrid->dropsite(option, x, y)"
.PD
Tcl/Tix has (or was going to have) Drag&Drop support.
Meaning for perl/Tk is not clear yet.
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBeditApply\fR" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBeditApply\fR" 4
.IX Item "$tixgrid->editApply"
If any cell is being edited, de-highlight the cell and
applies the changes.
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBeditSet\fR(\fIx\fR, \fIy\fR)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBeditSet\fR(\fIx\fR, \fIy\fR)" 4
.IX Item "$tixgrid->editSet(x, y)"
Highlights the cell at (\fIx\fR,\fIy\fR) for editing,
if the \fB\-editnotify\fR callback returns true for this cell.
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBentrycget\fR(\fIx\fR, \fIy\fR, '\fI\-option\fR')" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBentrycget\fR(\fIx\fR, \fIy\fR, '\fI\-option\fR')" 4
.IX Item "$tixgrid->entrycget(x, y, '-option')"
.PD 0
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBentryconfigure\fR(\fIx\fR, \fIy\fR?, \fI\-option\fR??=>\fIvalue\fR, \fI\-option\fR=>\fIvalue\fR, \fI...\fR?)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBentryconfigure\fR(\fIx\fR, \fIy\fR?, \fI\-option\fR??=>\fIvalue\fR, \fI\-option\fR=>\fIvalue\fR, \fI...\fR?)" 4
.IX Item "$tixgrid->entryconfigure(x, y?, -option??=>value, -option=>value, ...?)"
.PD
Provide a configue interface to cells in the grid.
The \fI\-option\fRs depend on the item type of the cell.
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBformatBorder\fR(\fIx1,y1\fR, \fIx2,y2\fR, \fIoptions\fR);" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBformatBorder\fR(\fIx1,y1\fR, \fIx2,y2\fR, \fIoptions\fR);" 4
.IX Item "$tixgrid->formatBorder(x1,y1, x2,y2, options);"
.PD 0
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBformatGrid\fR(\fIx1,y1\fR, \fIx2,y2\fR, \fIoptions\fR);" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBformatGrid\fR(\fIx1,y1\fR, \fIx2,y2\fR, \fIoptions\fR);" 4
.IX Item "$tixgrid->formatGrid(x1,y1, x2,y2, options);"
.PD
The \fBformatBorder\fR and \fBformatBorder\fR methods can only be called by the
\&\fB\-formatcmd\fR callback of the tixGrid widget. They draw the background of
the region described by \fIx1,y1\fR, \fIx2,y2\fR according the the supplied
\&\fIoptions\fR. One call to \fB\-formatcmd\fR callback can make multiple
calls to \fBformatBorder\fR and/or \fBformatBorder\fR for different
sub-regions.
.Sp
\&\fBformatBorder\fR draws the background using Tk relief style,
\&\fBformatGrid\fR also draws grid lines between the cells.
It only makes sense to call one or the other for a particular
sub-region as one will over-write the other.
.Sp
The options allowed are:
.RS 4
.IP "\-background / \-bg" 8
.IX Item "-background / -bg"
.PD 0
.IP "\-borderwidth / \-bd" 8
.IX Item "-borderwidth / -bd"
.IP "\-filled" 8
.IX Item "-filled"
.IP "\-relief" 8
.IX Item "-relief"
.IP "\-selectbackground" 8
.IX Item "-selectbackground"
.IP "\-xoff" 8
.IX Item "-xoff"
.IP "\-xon" 8
.IX Item "-xon"
.IP "\-yoff" 8
.IX Item "-yoff"
.IP "\-yon" 8
.IX Item "-yon"
.RE
.RS 4
.PD
.Sp
The \fB\-xon/\-xoff and \-yon/\-yoff\fR options are obscure. If anyone
can figure out how to do something interesting given what
\&\fIpTk/tixGrFmt.c\fR is doing with them please let Nick know!.
.RE
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBgeometryinfo\fR(?\fIwidth\fR, \fIheight\fR?)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBgeometryinfo\fR(?\fIwidth\fR, \fIheight\fR?)" 4
.IX Item "$tixgrid->geometryinfo(?width, height?)"
Returns list of four values \- two sets of two floating point numbers.
First set is the scrollbar fractions for x direction, second set
is scrollbar fractions for y direction. If \fIwidth\fR and \fIheight\fR
are specified then fractions are based on as if window size was of
specified size (in pixels, but not allowing normal GetPixels units).
Otherwise fractions are based on current size of the window.
.Sp
Usage obscure.
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBindex\fR(\fIxcoord\fR, \fIycoord\fR)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBindex\fR(\fIxcoord\fR, \fIycoord\fR)" 4
.IX Item "$tixgrid->index(xcoord, ycoord)"
Retuns \fI(x, y)\fR of entry at position (\fI\f(CI$coordx\fI\fR, \fI\f(CI$coordy\fI\fR).
Either coordinate may be \fB'max'\fR which is largest existing entry
in that direction, \fB'end'\fR which is one \fIbeyond\fR largest existing
entry, or a number. (This is how you find out how big the grid is.)
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBinfoBbox\fR(\fIx\fR,\fIy\fR)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBinfoBbox\fR(\fIx\fR,\fIy\fR)" 4
.IX Item "$tixgrid->infoBbox(x,y)"
Return the pixel bounding box of the cell at \fIx,y\fR.
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBinfoExists\fR(\fIx\fR,\fIy\fR)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBinfoExists\fR(\fIx\fR,\fIy\fR)" 4
.IX Item "$tixgrid->infoExists(x,y)"
Returns true if there is an item in the cell at \fIx,y\fR.
Throws an exception (dies) if \fIx,y\fR is outside the
grid \- this may change (Nick doesn't like it).
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBmove\fR(\fIdim\fR, \fIfrom\fR, \fIto\fR, \fIoffset\fR)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBmove\fR(\fIdim\fR, \fIfrom\fR, \fIto\fR, \fIoffset\fR)" 4
.IX Item "$tixgrid->move(dim, from, to, offset)"
.PD 0
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBmoveColumn\fR(\fIfrom\fR, \fIto\fR, \fIoffset\fR)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBmoveColumn\fR(\fIfrom\fR, \fIto\fR, \fIoffset\fR)" 4
.IX Item "$tixgrid->moveColumn(from, to, offset)"
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBmoveRow\fR(\fIfrom\fR, \fIto\fR, \fIoffset\fR)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBmoveRow\fR(\fIfrom\fR, \fIto\fR, \fIoffset\fR)" 4
.IX Item "$tixgrid->moveRow(from, to, offset)"
.PD
\&\fIDim\fR may be \fBrow\fR or \fBcolumn\fR. Moves the range of rows
(or columns) from position \fIfrom\fR through \fIto\fR by the distance
indicated by \fIoffset\fR. For example,
\&\fI\f(CI$tixgrid\fI\fR\->\fBmoveRow\fR(\fB2\fR, \fB4\fR, \fB1\fR) moves the rows 2,3,4
to rows 3,4,5.
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBnearest\fR(\fIx\fR, \fIy\fR)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBnearest\fR(\fIx\fR, \fIy\fR)" 4
.IX Item "$tixgrid->nearest(x, y)"
Screen pos (pixels) to entry (nx,ny) translation.
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBselectionAdjust\fR(\fIx1\fR, \fIy1\fR ?,\fIx2\fR, \fIy2\fR?)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBselectionAdjust\fR(\fIx1\fR, \fIy1\fR ?,\fIx2\fR, \fIy2\fR?)" 4
.IX Item "$tixgrid->selectionAdjust(x1, y1 ?,x2, y2?)"
.PD 0
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBselectionClear\fR(\fIx1\fR, \fIy1\fR ?,\fIx2\fR, \fIy2\fR?)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBselectionClear\fR(\fIx1\fR, \fIy1\fR ?,\fIx2\fR, \fIy2\fR?)" 4
.IX Item "$tixgrid->selectionClear(x1, y1 ?,x2, y2?)"
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBselectionIncludes\fR(\fIx1\fR, \fIy1\fR ?,\fIx2\fR, \fIy2\fR?)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBselectionIncludes\fR(\fIx1\fR, \fIy1\fR ?,\fIx2\fR, \fIy2\fR?)" 4
.IX Item "$tixgrid->selectionIncludes(x1, y1 ?,x2, y2?)"
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBselectionSet\fR(\fIx1\fR, \fIy1\fR ?,\fIx2\fR, \fIy2\fR?)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBselectionSet\fR(\fIx1\fR, \fIy1\fR ?,\fIx2\fR, \fIy2\fR?)" 4
.IX Item "$tixgrid->selectionSet(x1, y1 ?,x2, y2?)"
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBselectionToggle\fR(\fIx1\fR, \fIy1\fR ?,\fIx2\fR, \fIy2\fR?)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBselectionToggle\fR(\fIx1\fR, \fIy1\fR ?,\fIx2\fR, \fIy2\fR?)" 4
.IX Item "$tixgrid->selectionToggle(x1, y1 ?,x2, y2?)"
.PD
Selection support methods \- probably buggy.
.Sp
x1 (y1) has not to be greater than x2 (y2), but only x2 and y2 can be 'max'.
.Sp
\&\s-1BUG: \s0\fIselectionIncludes\fR: has no visible effect (as in Tix). Eh???
.Sp
\&\s-1BUG: \s0\fIselectionClear\fR: only works for 0, 0, max, max (as in Tix). Eh???
.Sp
When \fIx2, y2\fR are not given they default to \fIx1, y1\fR, respectively.
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBset\fR(\fIx\fR, \fIy\fR?, \fB\-itemtype\fR=>\fItype\fR??, \fI\-option\fR=>\fIvalue\fR, \fI...\fR?)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBset\fR(\fIx\fR, \fIy\fR?, \fB\-itemtype\fR=>\fItype\fR??, \fI\-option\fR=>\fIvalue\fR, \fI...\fR?)" 4
.IX Item "$tixgrid->set(x, y?, -itemtype=>type??, -option=>value, ...?)"
Creates a new display item at the cell at (\fIx\fR,\fIy\fR). The optional
\&\fB\-itemtype\fR parameter gives the type of the display item.
An additional list of \fIoption-value\fR pairs specify options
of the display item. If a display item already exists at this cell,
the old item will be deleted automatically.
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBsize\fR(\fIdim\fR, \fIindex\fR?, \fI\-option\fR??=>\fIvalue\fR, \fI...\fR?)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBsize\fR(\fIdim\fR, \fIindex\fR?, \fI\-option\fR??=>\fIvalue\fR, \fI...\fR?)" 4
.IX Item "$tixgrid->size(dim, index?, -option??=>value, ...?)"
.PD 0
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBsizeColumn\fR(\fIindex\fR?, \fI\-option\fR??=>\fIvalue\fR, \fI...\fR?)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBsizeColumn\fR(\fIindex\fR?, \fI\-option\fR??=>\fIvalue\fR, \fI...\fR?)" 4
.IX Item "$tixgrid->sizeColumn(index?, -option??=>value, ...?)"
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBsizeRow\fR(\fIindex\fR?, \fI\-option\fR??=>\fIvalue\fR, \fI...\fR?)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBsizeRow\fR(\fIindex\fR?, \fI\-option\fR??=>\fIvalue\fR, \fI...\fR?)" 4
.IX Item "$tixgrid->sizeRow(index?, -option??=>value, ...?)"
.PD
Queries or sets the size of the row or column given by \fIdim\fR and
\&\fIindex\fR. \fIDim\fR may be \fBrow\fR or \fBcolumn\fR.  \fIIndex\fR may be any
non-negative integer that gives the position of a given row (or column).
\&\fIIndex\fR can also be the string \fBdefault\fR; in this case, this method
queries or sets the default size of all rows (or columns).
When no \fIoption-value\fR pair is given, this method returns
a list containing the current size setting of the given row (or column).
When \fIoption-value\fR pairs are given, the corresponding options
of the size setting of the given row are changed. \fI\-option\fR may be
one of the following:
.RS 4
.IP "\fB\-pad0\fR => \fIpixels\fR" 8
.IX Item "-pad0 => pixels"
Specifies the paddings to the left of a column or the top of a row.
.IP "\fB\-pad1\fR => \fIpixels\fR" 8
.IX Item "-pad1 => pixels"
Specifies the paddings to the right of a column or the bottom of a row.
.IP "\fB\-size\fR => \fIval\fR" 8
.IX Item "-size => val"
Specifies the width of a column or the height of a row.
\&\fIVal\fR may be: \fBauto\fR \*(-- the width of the column is set
the widest cell in the column; a valid Tk screen distance
unit (see \fBTk_GetPixels\fR); or a real number following by the
word \fBchars\fR (e.g. \fB3.4chars\fR) that sets the width of the
column to the given number of characters.
.RE
.RS 4
.RE
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBsort\fR(\fIdimension\fR, \fIstart\fR, \fIend\fR, ?\fIargs ...\fR?)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBsort\fR(\fIdimension\fR, \fIstart\fR, \fIend\fR, ?\fIargs ...\fR?)" 4
.IX Item "$tixgrid->sort(dimension, start, end, ?args ...?)"
?docu here? (not supported on Win* OSs up to now)
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBunset\fR(\fIx\fR, \fIy\fR)" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBunset\fR(\fIx\fR, \fIy\fR)" 4
.IX Item "$tixgrid->unset(x, y)"
Clears the cell at (\fIx\fR,\fIy\fR) by removing its display item.
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fBxview\fR" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fBxview\fR" 4
.IX Item "$tixgrid->xview"
Normal horizontal scrollbar method.
.ie n .IP "\fI\fI$tixgrid\fI\fR\->\fByview\fR" 4
.el .IP "\fI\f(CI$tixgrid\fI\fR\->\fByview\fR" 4
.IX Item "$tixgrid->yview"
Normal vertical scrollbar method.
.SH "BINDINGS"
.IX Header "BINDINGS"
To be done \- only most obvious basic bindings work. The Tcl/Tix code
was coded as a \*(L"state machine\*(R" which is not easy to follow.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Tk::DItem
Tk::callbacks
Tk::FloatEntry
.SH "BUGS"
.IX Header "BUGS"
Tcl/Tix was/is not finished and both C code and bindings of TixGrid
have some bugs.
.SH "KEYWORDS"
.IX Header "KEYWORDS"
tix, tixgrid, table, display item, spreadsheet
