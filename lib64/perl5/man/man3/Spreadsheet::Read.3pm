.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Read 3"
.TH Read 3 "2015-03-26" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\& Spreadsheet::Read \- Read the data from a spreadsheet
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& use Spreadsheet::Read;
\& my $book  = ReadData ("test.csv", sep => ";");
\& my $book  = ReadData ("test.sxc");
\& my $book  = ReadData ("test.ods");
\& my $book  = ReadData ("test.xls");
\& my $book  = ReadData ("test.xlsx");
\& my $book  = ReadData ($fh, parser => "xls");
\&
\& my $sheet = $book\->[1];             # first datasheet
\& my $cell  = $book\->[1]{A3};         # content of field A3 of sheet 1
\& my $cell  = $book\->[1]{cell}[1][3]; # same, unformatted
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Spreadsheet::Read tries to transparently read *any* spreadsheet and
return its content in a universal manner independent of the parsing
module that does the actual spreadsheet scanning.
.PP
For OpenOffice and/or LibreOffice this module uses Spreadsheet::ReadSXC
.PP
For Microsoft Excel this module uses Spreadsheet::ParseExcel,
Spreadsheet::ParseXLSX, or Spreadsheet::XLSX.
.PP
For \s-1CSV\s0 this module uses Text::CSV_XS or Text::CSV_PP.
.PP
For SquirrelCalc there is a very simplistic built-in parser
.SS "Data structure"
.IX Subsection "Data structure"
The data is returned as an array reference:
.PP
.Vb 10
\&  $book = [
\&      # Entry 0 is the overall control hash
\&      { sheets  => 2,
\&        sheet   => {
\&          "Sheet 1"  => 1,
\&          "Sheet 2"  => 2,
\&          },
\&        type    => "xls",
\&        parser  => "Spreadsheet::ParseExcel",
\&        version => 0.59,
\&        error   => undef,
\&        },
\&      # Entry 1 is the first sheet
\&      { label   => "Sheet 1",
\&        maxrow  => 2,
\&        maxcol  => 4,
\&        cell    => [ undef,
\&          [ undef, 1 ],
\&          [ undef, undef, undef, undef, undef, "Nugget" ],
\&          ],
\&        attr    => [],
\&        merged  => [],
\&        A1      => 1,
\&        B5      => "Nugget",
\&        },
\&      # Entry 2 is the second sheet
\&      { label   => "Sheet 2",
\&        :
\&        :
.Ve
.PP
To keep as close contact to spreadsheet users, row and column 1 have
index 1 too in the \f(CW\*(C`cell\*(C'\fR element of the sheet hash, so cell \*(L"A1\*(R" is
the same as \f(CW\*(C`cell\*(C'\fR [1, 1] (column first). To switch between the two,
there are two helper functions available: \f(CW\*(C`cell2cr ()\*(C'\fR and \f(CW\*(C`cr2cell ()\*(C'\fR.
.PP
The \f(CW\*(C`cell\*(C'\fR hash entry contains unformatted data, while the hash entries
with the traditional labels contain the formatted values (if applicable).
.PP
The control hash (the first entry in the returned array ref), contains
some spreadsheet meta-data. The entry \f(CW\*(C`sheet\*(C'\fR is there to be able to find
the sheets when accessing them by name:
.PP
.Vb 1
\&  my %sheet2 = %{$book\->[$book\->[0]{sheet}{"Sheet 2"}]};
.Ve
.SS "Functions"
.IX Subsection "Functions"
.ie n .IP "my $book = ReadData ($source [, option => value [, ... ]]);" 2
.el .IP "my \f(CW$book\fR = ReadData ($source [, option => value [, ... ]]);" 2
.IX Item "my $book = ReadData ($source [, option => value [, ... ]]);"
.PD 0
.ie n .IP "my $book = ReadData (""file.csv"", sep => ',', quote => '""');" 2
.el .IP "my \f(CW$book\fR = ReadData (``file.csv'', sep => ',', quote => '""');" 2
.IX Item "my $book = ReadData (file.csv, sep => ',', quote => '""');"
.ie n .IP "my $book = ReadData (""file.xls"", dtfmt => ""yyyy-mm-dd"");" 2
.el .IP "my \f(CW$book\fR = ReadData (``file.xls'', dtfmt => ``yyyy-mm-dd'');" 2
.IX Item "my $book = ReadData (file.xls, dtfmt => yyyy-mm-dd);"
.ie n .IP "my $book = ReadData (""file.ods"");" 2
.el .IP "my \f(CW$book\fR = ReadData (``file.ods'');" 2
.IX Item "my $book = ReadData (file.ods);"
.ie n .IP "my $book = ReadData (""file.sxc"");" 2
.el .IP "my \f(CW$book\fR = ReadData (``file.sxc'');" 2
.IX Item "my $book = ReadData (file.sxc);"
.ie n .IP "my $book = ReadData (""content.xml"");" 2
.el .IP "my \f(CW$book\fR = ReadData (``content.xml'');" 2
.IX Item "my $book = ReadData (content.xml);"
.ie n .IP "my $book = ReadData ($content);" 2
.el .IP "my \f(CW$book\fR = ReadData ($content);" 2
.IX Item "my $book = ReadData ($content);"
.ie n .IP "my $book = ReadData ($fh, parser => ""xls"");" 2
.el .IP "my \f(CW$book\fR = ReadData ($fh, parser => ``xls'');" 2
.IX Item "my $book = ReadData ($fh, parser => xls);"
.PD
Tries to convert the given file, string, or stream to the data
structure described above.
.Sp
Processing Excel data from a stream or content is supported through
a File::Temp temporary file or IO::Scalar when available.
.Sp
ReadSXC does preserve sheet order as of version 0.20.
.Sp
Currently supported options are:
.RS 2
.IP "parser" 2
.IX Item "parser"
Force the data to be parsed by a specific format. Possible values are
\&\f(CW\*(C`csv\*(C'\fR, \f(CW\*(C`prl\*(C'\fR (or \f(CW\*(C`perl\*(C'\fR), \f(CW\*(C`sc\*(C'\fR (or \f(CW\*(C`squirelcalc\*(C'\fR), \f(CW\*(C`sxc\*(C'\fR (or \f(CW\*(C`oo\*(C'\fR,
\&\f(CW\*(C`ods\*(C'\fR, \f(CW\*(C`openoffice\*(C'\fR, \f(CW\*(C`libreoffice\*(C'\fR) \f(CW\*(C`xls\*(C'\fR (or \f(CW\*(C`excel\*(C'\fR), and \f(CW\*(C`xlsx\*(C'\fR
(or \f(CW\*(C`excel2007\*(C'\fR).
.Sp
When parsing streams, instead of files, it is highly recommended to pass
this option.
.IP "cells" 2
.IX Item "cells"
Control the generation of named cells (\*(L"A1\*(R" etc). Default is true.
.IP "rc" 2
.IX Item "rc"
Control the generation of the {cell}[c][r] entries. Default is true.
.IP "attr" 2
.IX Item "attr"
Control the generation of the {attr}[c][r] entries. Default is false.
See \*(L"Cell Attributes\*(R" below.
.IP "clip" 2
.IX Item "clip"
If set, \f(CW\*(C`ReadData ()\*(C'\fR will remove all trailing rows and columns per
sheet that have no visual data. If a sheet has no data at all, the
sheet will be skipped entirely when this attribute is true.
.Sp
This option is only valid if \f(CW\*(C`cells\*(C'\fR is true. The default value is
true if \f(CW\*(C`cells\*(C'\fR is true, and false otherwise.
.IP "strip" 2
.IX Item "strip"
If set, \f(CW\*(C`ReadData ()\*(C'\fR will remove trailing\- and/or leading-whitespace
from every field.
.Sp
.Vb 6
\&  strip  leading  strailing
\&  \-\-\-\-\-  \-\-\-\-\-\-\-  \-\-\-\-\-\-\-\-\-
\&    0      n/a      n/a
\&    1     strip     n/a
\&    2      n/a     strip
\&    3     strip    strip
.Ve
.IP "sep" 2
.IX Item "sep"
Set separator for \s-1CSV.\s0 Default is comma \f(CW\*(C`,\*(C'\fR.
.IP "quote" 2
.IX Item "quote"
Set quote character for \s-1CSV.\s0 Default is \f(CW\*(C`"\*(C'\fR.
.IP "dtfmt" 2
.IX Item "dtfmt"
Set the format for M$Excel date fields that are set to use the default
date format. The default format in Excel is 'm\-d\-yy', which is both
not year 2000 safe, nor very useful. The default is now 'yyyy\-mm\-dd',
which is more ISO-like.
.Sp
Note that date formatting in M$Excel is not reliable at all, as it will
store/replace/change the date field separator in already stored formats
if you change your locale settings. So the above mentioned default can
be either \*(L"m\-d-yy\*(R" \s-1OR \s0\*(L"m/d/yy\*(R" depending on what that specific character
happened to be at the time the user saved the file.
.IP "debug" 2
.IX Item "debug"
Enable some diagnostic messages to \s-1STDERR.\s0
.Sp
The value determines how much diagnostics are dumped (using Data::Peek).
A value of 9 and higher will dump the entire structure from the back-end
parser.
.RE
.RS 2
.Sp
All other attributes/options will be passed to the underlying parser if
that parser supports attributes.
.RE
.SS "Using \s-1CSV\s0"
.IX Subsection "Using CSV"
In case of \s-1CSV\s0 parsing, \f(CW\*(C`ReadData ()\*(C'\fR will use the first line of the file
to auto-detect the separation character if the first argument is a file and
both \f(CW\*(C`sep\*(C'\fR and \f(CW\*(C`quote\*(C'\fR are not passed as attributes. Text::CSV_XS (or
Text::CSV_PP) is able to automatically detect and use \f(CW\*(C`\er\*(C'\fR line endings).
.PP
\&\s-1CSV\s0 can parse streams too, but be sure to pass \f(CW\*(C`sep\*(C'\fR and/or \f(CW\*(C`quote\*(C'\fR if
these do not match the default \f(CW\*(C`,\*(C'\fR and \f(CW\*(C`"\*(C'\fR.
.PP
When an error is found in the \s-1CSV,\s0 it is automatically reported (to \s-1STDERR\s0).
The structure will store the error in \f(CW\*(C`$ss\->[0]{error}\*(C'\fR as anonymous
list returned by \f(CW\*(C`$csv\->error_diag\*(C'\fR. See Text::CSV_XS for documentation.
.PP
.Vb 2
\& my $ss = ReadData ("bad.csv");
\& $ss\->[0]{error} and say $ss\->[0]{error}[1];
.Ve
.SS "Functions"
.IX Subsection "Functions"
.ie n .IP "my $cell = cr2cell (col, row)" 4
.el .IP "my \f(CW$cell\fR = cr2cell (col, row)" 4
.IX Item "my $cell = cr2cell (col, row)"
\&\f(CW\*(C`cr2cell ()\*(C'\fR converts a \f(CW\*(C`(column, row)\*(C'\fR pair (1 based) to the
traditional cell notation:
.Sp
.Vb 2
\&  my $cell = cr2cell ( 4, 14); # $cell now "D14"
\&  my $cell = cr2cell (28,  4); # $cell now "AB4"
.Ve
.ie n .IP "my ($col, $row) = cell2cr ($cell)" 4
.el .IP "my ($col, \f(CW$row\fR) = cell2cr ($cell)" 4
.IX Item "my ($col, $row) = cell2cr ($cell)"
\&\f(CW\*(C`cell2cr ()\*(C'\fR converts traditional cell notation to a \f(CW\*(C`(column, row)\*(C'\fR
pair (1 based):
.Sp
.Vb 2
\&  my ($col, $row) = cell2cr ("D14"); # returns ( 4, 14)
\&  my ($col, $row) = cell2cr ("AB4"); # returns (28,  4)
.Ve
.ie n .IP "my @row = row ($sheet, $row)" 4
.el .IP "my \f(CW@row\fR = row ($sheet, \f(CW$row\fR)" 4
.IX Item "my @row = row ($sheet, $row)"
.PD 0
.ie n .IP "my @row = Spreadsheet::Read::row ($book\->[1], 3)" 4
.el .IP "my \f(CW@row\fR = Spreadsheet::Read::row ($book\->[1], 3)" 4
.IX Item "my @row = Spreadsheet::Read::row ($book->[1], 3)"
.PD
Get full row of formatted values (like \f(CW\*(C`$sheet\->{A3} .. $sheet\->{G3}\*(C'\fR)
.Sp
Note that the indexes in the returned list are 0\-based.
.Sp
\&\f(CW\*(C`row ()\*(C'\fR is not imported by default, so either specify it in the
use argument list, or call it fully qualified.
.ie n .IP "my @row = cellrow ($book, $row)" 4
.el .IP "my \f(CW@row\fR = cellrow ($book, \f(CW$row\fR)" 4
.IX Item "my @row = cellrow ($book, $row)"
.PD 0
.ie n .IP "my @row = Spreadsheet::Read::cellrow ($book\->[1], 3)" 4
.el .IP "my \f(CW@row\fR = Spreadsheet::Read::cellrow ($book\->[1], 3)" 4
.IX Item "my @row = Spreadsheet::Read::cellrow ($book->[1], 3)"
.PD
Get full row of unformatted values (like \f(CW\*(C`$sheet\->{cell}[1][3] .. $sheet\->{cell}[7][3]\*(C'\fR)
.Sp
Note that the indexes in the returned list are 0\-based.
.Sp
\&\f(CW\*(C`cellrow ()\*(C'\fR is not imported by default, so either specify it in the
use argument list, or call it fully qualified.
.ie n .IP "my @rows = rows ($book)" 4
.el .IP "my \f(CW@rows\fR = rows ($book)" 4
.IX Item "my @rows = rows ($book)"
.PD 0
.ie n .IP "my @rows = Spreadsheet::Read::rows ($book\->[1])" 4
.el .IP "my \f(CW@rows\fR = Spreadsheet::Read::rows ($book\->[1])" 4
.IX Item "my @rows = Spreadsheet::Read::rows ($book->[1])"
.PD
Convert \f(CW\*(C`{cell}\*(C'\fR's \f(CW\*(C`[column][row]\*(C'\fR to a \f(CW\*(C`[row][column]\*(C'\fR list.
.Sp
Note that the indexes in the returned list are 0\-based, where the
index in the \f(CW\*(C`{cell}\*(C'\fR entry is 1\-based.
.Sp
\&\f(CW\*(C`rows ()\*(C'\fR is not imported by default, so either specify it in the
use argument list, or call it fully qualified.
.IP "parses ($format)" 4
.IX Item "parses ($format)"
.PD 0
.ie n .IP "Spreadsheet::Read::parses (""\s-1CSV""\s0)" 4
.el .IP "Spreadsheet::Read::parses (``\s-1CSV''\s0)" 4
.IX Item "Spreadsheet::Read::parses (CSV)"
.PD
\&\f(CW\*(C`parses ()\*(C'\fR returns Spreadsheet::Read's capability to parse the
required format.
.Sp
\&\f(CW\*(C`parses ()\*(C'\fR is not imported by default, so either specify it in the
use argument list, or call it fully qualified.
.ie n .IP "my $rs_version = Version ()" 4
.el .IP "my \f(CW$rs_version\fR = Version ()" 4
.IX Item "my $rs_version = Version ()"
.PD 0
.ie n .IP "my $v = Spreadsheet::Read::Version ()" 4
.el .IP "my \f(CW$v\fR = Spreadsheet::Read::Version ()" 4
.IX Item "my $v = Spreadsheet::Read::Version ()"
.PD
Returns the current version of Spreadsheet::Read.
.Sp
\&\f(CW\*(C`Version ()\*(C'\fR is not imported by default, so either specify it in the
use argument list, or call it fully qualified.
.SS "Cell Attributes"
.IX Subsection "Cell Attributes"
If the constructor was called with \f(CW\*(C`attr\*(C'\fR having a true value, effort
is made to analyze and store field attributes like this:
.PP
.Vb 10
\&    { label  => "Sheet 1",
\&      maxrow => 5,
\&      maxcol => 2,
\&      cell   => [ undef,
\&        [ undef, 1 ],
\&        [ undef, undef, undef, undef, undef, "Nugget" ],
\&        ],
\&      attr   => [ undef,
\&        [ undef, {
\&          type    => "numeric",
\&          fgcolor => "#ff0000",
\&          bgcolor => undef,
\&          font    => "Arial",
\&          size    => undef,
\&          format  => "## ##0.00",
\&          halign  => "right",
\&          valign  => "top",
\&          uline   => 0,
\&          bold    => 0,
\&          italic  => 0,
\&          wrap    => 0,
\&          merged  => 0,
\&          hidden  => 0,
\&          locked  => 0,
\&          enc     => "utf\-8",
\&          }, ]
\&        [ undef, undef, undef, undef, undef, {
\&          type    => "text",
\&          fgcolor => "#e2e2e2",
\&          bgcolor => undef,
\&          font    => "Letter Gothic",
\&          size    => 15,
\&          format  => undef,
\&          halign  => "left",
\&          valign  => "top",
\&          uline   => 0,
\&          bold    => 0,
\&          italic  => 0,
\&          wrap    => 0,
\&          merged  => 0,
\&          hidden  => 0,
\&          locked  => 0,
\&          enc     => "iso8859\-1",
\&          }, ]
\&      merged => [],
\&      A1     => 1,
\&      B5     => "Nugget",
\&      },
.Ve
.PP
This has now been partially implemented, mainly for Excel, as the other
parsers do not (yet) support all of that. \s-1YMMV.\s0
.PP
\fIMerged cells\fR
.IX Subsection "Merged cells"
.PP
Note that only [Spreadsheet::ReadSXC] documents the use of merged cells,
and not in a way useful for the spreadsheet consumer.
.PP
\&\s-1CSV\s0 does not support merged cells (though future implementations of \s-1CSV\s0
for the web might).
.PP
The documentation of merged areas in [Spreadsheet::ParseExcel] and
[Spreadsheet::ParseXLSX] can be found in [Spreadsheet::ParseExcel::Worksheet]
and [Spreadsheet::ParseExcel::Cell].
.PP
None of basic [Spreadsheet::XLSX], [Spreadsheet::ParseExcel], and
[Spreadsheet::ParseXLSX] manual pages mention merged cells at all.
.PP
This module just tries to return the information in a generic way.
.PP
Given this spreadsheet as an example
.PP
.Vb 1
\& merged.xlsx:
\& 
\&     A     B     C
\&  +\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+
\& 1|     | foo       |
\&  +\-\-\-\-\-+           +
\& 2| bar |           |
\&  |     +\-\-\-\-\-+\-\-\-\-\-+
\& 3|     | urg | orc |
\&  +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+
.Ve
.PP
the information extracted from that undocumented information is
returned in the \f(CW\*(C`merged\*(C'\fR entry of the sheet's hash as a list of
top-left, bottom-right coordinate pars (col, row, col, row). For
given example, that would be:
.PP
.Vb 4
\& $ss\->{merged} = [
\&    [ 1, 2, 1, 3 ], # A2\-A3
\&    [ 2, 1, 3, 2 ], # B1\-C2
\&    ];
.Ve
.PP
When the attributes are also enabled, there is some merge information
copied directly from the cell information, but again, that stems from
code analysis and not from documentation:
.PP
.Vb 9
\& my $ss = ReadData ("merged.xlsx", attr => 1)\->[1];
\& foreach my $row (1 .. $ss\->{maxrow}) {
\&     foreach my $col (1 .. $ss\->{maxcol}) {
\&         my $cell = cr2cell ($col, $row);
\&         printf "%s %\-3s %d  ", $cell, $ss\->{$cell},
\&             $ss\->{attr}[$col][$row]{merged};
\&         }
\&     print "\en";
\&     }
\&
\& A1     0  B1 foo 1  C1     1
\& A2 bar 1  B2     1  C2     1
\& A3     1  B3 urg 0  C3 orc 0
.Ve
.PP
In this example, there is no way to see if B2 is merged to A2 or
to B1 without analyzing all surrounding cells. This could as well
mean A2:A3, B1:C1, B2: C2, as A2:A3, B1:B2, C1:C2, as A2:A3, B1:C2.
Use the \f(CW\*(C`merged\*(C'\fR entry described above to find out what fields are
merged to what other fields.
.SH "TOOLS"
.IX Header "TOOLS"
This modules comes with a few tools that perform tasks from the \s-1FAQ,\s0 like
\&\*(L"How do I select only column D through F from sheet 2 into a \s-1CSV\s0 file?\*(R"
.PP
If the module was installed without the tools, you can find them here:
  https://github.com/Tux/Spreadsheet\-Read/tree/master/examples
.ie n .SS """xlscat"""
.el .SS "\f(CWxlscat\fP"
.IX Subsection "xlscat"
Show (parts of) a spreadsheet in plain text, \s-1CSV,\s0 or \s-1HTML\s0
.PP
.Vb 10
\& usage: xlscat   [\-s <sep>] [\-L] [\-n] [\-A] [\-u] [Selection] file.xls
\&                 [\-c | \-m]                 [\-u] [Selection] file.xls
\&                  \-i                            [\-S sheets] file.xls
\&     Generic options:
\&        \-v[#]       Set verbose level (xlscat/xlsgrep)
\&        \-d[#]       Set debug   level (Spreadsheet::Read)
\&        \-u          Use unformatted values
\&        \-\-noclip    Do not strip empty sheets and
\&                    trailing empty rows and columns
\&        \-e <enc>    Set encoding for input and output
\&        \-b <enc>    Set encoding for input
\&        \-a <enc>    Set encoding for output
\&     Input CSV:
\&        \-\-in\-sep=c  Set input sep_char for CSV
\&     Input XLS:
\&        \-\-dtfmt=fmt Specify the default date format to replace \*(Aqm\-d\-yy\*(Aq
\&                    the default replacement is \*(Aqyyyy\-mm\-dd\*(Aq
\&     Output Text (default):
\&        \-s <sep>    Use separator <sep>. Default \*(Aq|\*(Aq, \en allowed
\&        \-L          Line up the columns
\&        \-n          Number lines (prefix with column number)
\&        \-A          Show field attributes in ANSI escapes
\&     Output Index only:
\&        \-i          Show sheet names and size only
\&     Output CSV:
\&        \-c          Output CSV, separator = \*(Aq,\*(Aq
\&        \-m          Output CSV, separator = \*(Aq;\*(Aq
\&     Output HTML:
\&        \-H          Output HTML
\&     Selection:
\&        \-S <sheets> Only print sheets <sheets>. \*(Aqall\*(Aq is a valid set
\&                    Default only prints the first sheet
\&        \-R <rows>   Only print rows    <rows>. Default is \*(Aqall\*(Aq
\&        \-C <cols>   Only print columns <cols>. Default is \*(Aqall\*(Aq
\&        \-F <flds>   Only fields <flds> e.g. \-FA3,B16
.Ve
.ie n .SS """xlsgrep"""
.el .SS "\f(CWxlsgrep\fP"
.IX Subsection "xlsgrep"
Show (parts of) a spreadsheet that match a pattern in plain text, \s-1CSV,\s0 or \s-1HTML\s0
.PP
.Vb 10
\& usage: xlsgrep  [\-s <sep>] [\-L] [\-n] [\-A] [\-u] [Selection] pattern file.xls
\&                 [\-c | \-m]                 [\-u] [Selection] pattern file.xls
\&                  \-i                            [\-S sheets] pattern file.xls
\&     Generic options:
\&        \-v[#]       Set verbose level (xlscat/xlsgrep)
\&        \-d[#]       Set debug   level (Spreadsheet::Read)
\&        \-u          Use unformatted values
\&        \-\-noclip    Do not strip empty sheets and
\&                    trailing empty rows and columns
\&        \-e <enc>    Set encoding for input and output
\&        \-b <enc>    Set encoding for input
\&        \-a <enc>    Set encoding for output
\&     Input CSV:
\&        \-\-in\-sep=c  Set input sep_char for CSV
\&     Input XLS:
\&        \-\-dtfmt=fmt Specify the default date format to replace \*(Aqm\-d\-yy\*(Aq
\&                    the default replacement is \*(Aqyyyy\-mm\-dd\*(Aq
\&     Output Text (default):
\&        \-s <sep>    Use separator <sep>. Default \*(Aq|\*(Aq, \en allowed
\&        \-L          Line up the columns
\&        \-n          Number lines (prefix with column number)
\&        \-A          Show field attributes in ANSI escapes
\&     Grep options:
\&        \-i          Ignore case
\&        \-w          Match whole words only
\&        \-h[#]       Show # header lines
\&     Output CSV:
\&        \-c          Output CSV, separator = \*(Aq,\*(Aq
\&        \-m          Output CSV, separator = \*(Aq;\*(Aq
\&     Output HTML:
\&        \-H          Output HTML
\&     Selection:
\&        \-S <sheets> Only print sheets <sheets>. \*(Aqall\*(Aq is a valid set
\&                    Default only prints the first sheet
\&        \-R <rows>   Only print rows    <rows>. Default is \*(Aqall\*(Aq
\&        \-C <cols>   Only print columns <cols>. Default is \*(Aqall\*(Aq
\&        \-F <flds>   Only fields <flds> e.g. \-FA3,B16
.Ve
.ie n .SS """ss2tk"""
.el .SS "\f(CWss2tk\fP"
.IX Subsection "ss2tk"
Show a spreadsheet in a perl/Tk spreadsheet widget
.PP
.Vb 2
\& usage: ss2tk [\-w <width>] [X11 options] file.xls [<pattern>]
\&        \-w <width> use <width> as default column width (4)
.Ve
.ie n .SS """xls2csv"""
.el .SS "\f(CWxls2csv\fP"
.IX Subsection "xls2csv"
Convert a spreadsheet to \s-1CSV.\s0 This is just a small wrapper over \f(CW\*(C`xlscat\*(C'\fR.
.PP
.Vb 1
\& usage: xls2csv [ \-o file.csv ] file.xls
.Ve
.SH "TODO"
.IX Header "TODO"
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.IP "Module Options" 2
.IX Item "Module Options"
.PD
New Spreadsheet::Read options are bound to happen. I'm thinking of an
option that disables the reading of the data entirely to speed up an
index request (how many sheets/fields/columns). See \f(CW\*(C`xlscat \-i\*(C'\fR.
.IP "Parser options" 2
.IX Item "Parser options"
Try to transparently support as many options as the encapsulated modules
support regarding (un)formatted values, (date) formats, hidden columns
rows or fields etc. These could be implemented like \f(CW\*(C`attr\*(C'\fR above but
names \f(CW\*(C`meta\*(C'\fR, or just be new values in the \f(CW\*(C`attr\*(C'\fR hashes.
.RE
.RS 4
.RE
.IP "Other spreadsheet formats" 4
.IX Item "Other spreadsheet formats"
I consider adding any spreadsheet interface that offers a usable \s-1API.\s0
.IP "Add an \s-1OO\s0 interface" 4
.IX Item "Add an OO interface"
Consider making the ref an object, though I currently don't see the big
advantage (yet). Maybe I'll make it so that it is a hybrid functional /
\&\s-1OO\s0 interface.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Text::CSV_XS, Text::CSV_PP" 2
.IX Item "Text::CSV_XS, Text::CSV_PP"
http://metacpan.org/release/Text\-CSV_XS ,
http://metacpan.org/release/Text\-CSV_PP , and
http://metacpan.org/release/Text\-CSV .
.Sp
Text::CSV is a wrapper over Text::CSV_XS (the fast \s-1XS\s0 version) and/or
Text::CSV_PP (the pure perl version)
.IP "Spreadsheet::ParseExcel" 2
.IX Item "Spreadsheet::ParseExcel"
http://metacpan.org/release/Spreadsheet\-ParseExcel
.IP "Spreadsheet::ParseXLSX" 2
.IX Item "Spreadsheet::ParseXLSX"
http://metacpan.org/release/Spreadsheet\-ParseXLSX
.IP "Spreadsheet::XLSX" 2
.IX Item "Spreadsheet::XLSX"
http://metacpan.org/release/Spreadsheet\-XLSX
.IP "Spreadsheet::ReadSXC" 2
.IX Item "Spreadsheet::ReadSXC"
http://metacpan.org/release/Spreadsheet\-ReadSXC
.IP "Spreadsheet::BasicRead" 2
.IX Item "Spreadsheet::BasicRead"
http://metacpan.org/release/Spreadsheet\-BasicRead
for xlscat likewise functionality (Excel only)
.IP "Spreadsheet::ConvertAA" 2
.IX Item "Spreadsheet::ConvertAA"
http://metacpan.org/release/Spreadsheet\-ConvertAA
for an alternative set of cell2cr () / cr2cell () pair
.IP "Spreadsheet::Perl" 2
.IX Item "Spreadsheet::Perl"
http://metacpan.org/release/Spreadsheet\-Perl
offers a Pure Perl implementation of a spreadsheet engine. Users that want
this format to be supported in Spreadsheet::Read are hereby motivated to
offer patches. It's not high on my TODO-list.
.IP "Spreadsheet::CSV" 2
.IX Item "Spreadsheet::CSV"
http://metacpan.org/release/Spreadsheet\-CSV
offers the interesting approach of seeing all supported spreadsheet formats
as if it were \s-1CSV,\s0 mimicking the Text::CSV_XS interface.
.IP "xls2csv" 2
.IX Item "xls2csv"
http://metacpan.org/release/xls2csv offers an alternative for my \f(CW\*(C`xlscat \-c\*(C'\fR,
in the xls2csv tool, but this tool focuses on character encoding
transparency, and requires some other modules.
.SH "AUTHOR"
.IX Header "AUTHOR"
H.Merijn Brand, <h.m.brand@xs4all.nl>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005\-2015 H.Merijn Brand
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
