.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Language 3"
.TH Language 3 "2015-03-16" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Verilog::Language \- Verilog language utilities
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Verilog::Language;
\&
\&  $result = Verilog::Language::is_keyword ("wire");  # true
\&  $result = Verilog::Language::is_compdirect ("\`notundef");  # false
\&  $result = Verilog::Language::number_value ("4\*(Aqb111");  # 8
\&  $result = Verilog::Language::number_bits  ("32\*(Aqh1b");  # 32
\&  $result = Verilog::Language::number_signed ("1\*(Aqsh1");  # 1
\&  @vec    = Verilog::Language::split_bus ("[31,5:4]"); # 31, 5, 4
\&  @vec    = Verilog::Language::split_bus_nocomma ("[31:29]"); # 31, 30, 29
\&  $result = Verilog::Language::strip_comments ("a/*b*/c");  # ac
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Verilog::Language provides general utilities for using the Verilog
Language, such as parsing numbers or determining what keywords exist.
General functions will be added as needed.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "Verilog::Language::is_keyword ($symbol_string)" 4
.IX Item "Verilog::Language::is_keyword ($symbol_string)"
Return true if the given symbol string is a Verilog reserved keyword.
Value indicates the language standard as per the `begin_keywords macro,
\&'1364\-1995', '1364\-2001', '1364\-2005', '1800\-2005', '1800\-2009',
\&'1800\-2012' or '\s-1VAMS\s0'.
.IP "Verilog::Language::is_compdirect ($symbol_string)" 4
.IX Item "Verilog::Language::is_compdirect ($symbol_string)"
Return true if the given symbol string is a Verilog compiler directive.
.IP "Verilog::Language::is_gateprim ($symbol_string)" 4
.IX Item "Verilog::Language::is_gateprim ($symbol_string)"
Return true if the given symbol is a built in gate primitive; for example
\&\*(L"buf\*(R", \*(L"xor\*(R", etc.
.IP "Verilog::Language::language_keywords ($year)" 4
.IX Item "Verilog::Language::language_keywords ($year)"
Returns a hash for keywords for given language standard year, where the
value of the hash is the standard in which it was defined.
.IP "Verilog::Language::language_standard ($year)" 4
.IX Item "Verilog::Language::language_standard ($year)"
Sets the language standard to indicate what are keywords.  If undef, all
standards apply.  The year is indicates the language standard as per the
`begin_keywords macro, '1364\-1995', '1364\-2001', '1364\-2005', '1800\-2005'
\&'1800\-2009' or '1800\-2012'.
.IP "Verilog::Language::language_maximum" 4
.IX Item "Verilog::Language::language_maximum"
Returns the greatest language currently standardized, presently
\&'1800\-2012'.
.IP "Verilog::Language::number_bigint ($number_string)" 4
.IX Item "Verilog::Language::number_bigint ($number_string)"
Return the numeric value of a Verilog value stored as a Math::BigInt, or
undef if incorrectly formed.  You must 'use Math::BigInt' yourself before
calling this function.  Note bigints do not have an exact size, so \s-1NOT\s0 of a
Math::BigInt may return a different value than verilog.  See also
number_value and number_bitvector.
.IP "Verilog::Language::number_bits ($number_string)" 4
.IX Item "Verilog::Language::number_bits ($number_string)"
Return the number of bits in a value string, or undef if incorrectly
formed, _or_ not specified.
.IP "Verilog::Language::number_bitvector ($number_string)" 4
.IX Item "Verilog::Language::number_bitvector ($number_string)"
Return the numeric value of a Verilog value stored as a Bit::Vector, or
undef if incorrectly formed.  You must 'use Bit::Vector' yourself before
calling this function.  The size of the Vector will be that returned by
number_bits.
.IP "Verilog::Language::number_signed ($number_string)" 4
.IX Item "Verilog::Language::number_signed ($number_string)"
Return true if the Verilog value is signed, else undef.
.IP "Verilog::Language::number_value ($number_string)" 4
.IX Item "Verilog::Language::number_value ($number_string)"
Return the numeric value of a Verilog value, or undef if incorrectly
formed.  It ignores any signed Verilog attributes, but is is returned as a
perl signed integer, so it may fail for over 31 bit values.  See also
number_bigint and number_bitvector.
.IP "Verilog::Language::split_bus ($bus)" 4
.IX Item "Verilog::Language::split_bus ($bus)"
Return a list of expanded arrays.  When passed a string like
\&\*(L"foo[5:1:2,10:9]\*(R", it will return a array with (\*(L"foo[5]\*(R", \*(L"foo[3]\*(R", ...).
It correctly handles connectivity expansion also, so that \*(L"x[1:0] = y[3:0]\*(R"
will get intuitive results.
.IP "Verilog::Language::split_bus_nocomma ($bus)" 4
.IX Item "Verilog::Language::split_bus_nocomma ($bus)"
As with split_bus, but faster.  Only supports simple decimal colon
separated array specifications, such as \*(L"foo[3:0]\*(R".
.IP "Verilog::Language::strip_comments ($text)" 4
.IX Item "Verilog::Language::strip_comments ($text)"
Return text with any // or /**/ comments stripped, correctly handing quoted
strings.  Newlines will be preserved in this process.
.SH "DISTRIBUTION"
.IX Header "DISTRIBUTION"
Verilog-Perl is part of the <http://www.veripool.org/> free Verilog \s-1EDA\s0
software tool suite.  The latest version is available from \s-1CPAN\s0 and from
<http://www.veripool.org/verilog\-perl>.
.PP
Copyright 2000\-2015 by Wilson Snyder.  This package is free software; you
can redistribute it and/or modify it under the terms of either the \s-1GNU\s0
Lesser General Public License Version 3 or the Perl Artistic License Version 2.0.
.SH "AUTHORS"
.IX Header "AUTHORS"
Wilson Snyder <wsnyder@wsnyder.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Verilog-Perl,
Verilog::EditFiles
Verilog::Parser,
Verilog::ParseSig,
Verilog::Getopt
.PP
And the <http://www.veripool.org/verilog\-mode>Verilog-Mode package for Emacs.
