.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Simple 3"
.TH Simple 3 "2012-11-17" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Proc::Simple \-\- launch and control background processes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Proc::Simple;
\&
\&   $myproc = Proc::Simple\->new();        # Create a new process object
\&
\&   $myproc\->start("shell\-command\-line"); # Launch an external program
\&   $myproc\->start("command",             # Launch an external program
\&                  "param", ...);         # with parameters
\&                                        
\&   $myproc\->start(sub { ... });          # Launch a perl subroutine
\&   $myproc\->start(\e&subroutine);         # Launch a perl subroutine
\&   $myproc\->start(\e&subroutine,          # Launch a perl subroutine
\&                  $param, ...);          # with parameters
\&
\&   $running = $myproc\->poll();           # Poll Running Process
\&
\&   $exit_status = $myproc\->wait();       # Wait until process is done
\&
\&   $proc\->kill_on_destroy(1);            # Set kill on destroy
\&   $proc\->signal_on_destroy("KILL");     # Specify signal to be sent
\&                                         # on destroy
\&
\&   $myproc\->kill();                      # Kill Process (SIGTERM)
\&
\&
\&
\&   $myproc\->kill("SIGUSR1");             # Send specified signal
\&
\&   $myproc\->exit_status();               # Return exit status of process
\&
\&
\&   Proc::Simple::debug($level);          # Turn debug on
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Proc::Simple package provides objects mimicing real-life
processes from a user's point of view. A new process object is created by
.PP
.Vb 1
\&   $myproc = Proc::Simple\->new();
.Ve
.PP
Either external programs or perl subroutines can be launched and
controlled as processes in the background.
.PP
A 10\-second sleep process, for example, can be launched 
as an external program as in
.PP
.Vb 2
\&   $myproc\->start("/bin/sleep 10");    # or
\&   $myproc\->start("/bin/sleep", "10");
.Ve
.PP
or as a perl subroutine, as in
.PP
.Vb 2
\&   sub mysleep { sleep(shift); }    # Define mysleep()
\&   $myproc\->start(\e&mysleep, 10);   # Launch it.
.Ve
.PP
or even as
.PP
.Vb 1
\&   $myproc\->start(sub { sleep(10); });
.Ve
.PP
The \fIstart\fR Method returns immediately after starting the
specified process in background, i.e. there's no blocking.
It returns \fI1\fR if the process has been launched
successfully and \fI0\fR if not.
.PP
The \fIpoll\fR method checks if the process is still running
.PP
.Vb 1
\&   $running = $myproc\->poll();
.Ve
.PP
and returns \fI1\fR if it is, \fI0\fR if it's not. Finally,
.PP
.Vb 1
\&   $myproc\->kill();
.Ve
.PP
terminates the process by sending it the \s-1SIGTERM\s0 signal. As an
option, another signal can be specified.
.PP
.Vb 1
\&   $myproc\->kill("SIGUSR1");
.Ve
.PP
sends the \s-1SIGUSR1\s0 signal to the running process. \fIkill\fR returns \fI1\fR if
it succeeds in sending the signal, \fI0\fR if it doesn't.
.PP
The methods are discussed in more detail in the next section.
.PP
A destructor is provided so that a signal can be sent to
the forked processes automatically should the process object be
destroyed or if the process exits. By default this
behaviour is turned off (see the kill_on_destroy and
signal_on_destroy methods).
.SH "METHODS"
.IX Header "METHODS"
The following methods are available:
.IP "new (Constructor)" 4
.IX Item "new (Constructor)"
Create a new instance of this class by writing
.Sp
.Vb 1
\&  $proc = new Proc::Simple;
.Ve
.Sp
or
.Sp
.Vb 1
\&  $proc = Proc::Simple\->new();
.Ve
.Sp
It takes no arguments.
.IP "start" 4
.IX Item "start"
Launches a new process.
The \f(CW\*(C`start()\*(C'\fR method can be used to launch both external programs 
(like \f(CW\*(C`/bin/echo\*(C'\fR) or one of your self-defined subroutines
(like \f(CW\*(C`foo()\*(C'\fR) in a new process.
.Sp
For an external program to be started, call
.Sp
.Vb 1
\& $status = $proc\->start("program\-name");
.Ve
.Sp
If you want to pass a couple of parameters to the launched program,
there's two options: You can either pass them in one argument like
in
.Sp
.Vb 1
\& $status = $proc\->start("/bin/echo hello world");
.Ve
.Sp
or in several arguments like in
.Sp
.Vb 1
\& $status = $proc\->start("/bin/echo", "hello", "world");
.Ve
.Sp
Just as in Perl's function \f(CW\*(C`system()\*(C'\fR, there's a big difference 
between the two methods: If you provide one argument containing
a blank-separated command line, your shell is going to
process any meta-characters (if you choose to use some) before
the process is actually launched:
.Sp
.Vb 1
\& $status = $proc\->start("/bin/ls \-l /etc/initt*");
.Ve
.Sp
will expand \f(CW\*(C`/etc/initt*\*(C'\fR to \f(CW\*(C`/etc/inittab\*(C'\fR before running the \f(CW\*(C`ls\*(C'\fR
command. If, on the other hand, you say
.Sp
.Vb 1
\& $status = $proc\->start("/bin/ls", "\-l", "*");
.Ve
.Sp
the \f(CW\*(C`*\*(C'\fR will stay unexpanded, meaning you'll look for a file with the
literal name \f(CW\*(C`*\*(C'\fR (which is unlikely to exist on your system unless
you deliberately create confusingly named files :). For
more info on this, look up \f(CW\*(C`perldoc \-f exec\*(C'\fR.
.Sp
If, on the other hand, you want to start a Perl subroutine
in the background, simply provide the function reference like
.Sp
.Vb 1
\& $status = $proc\->start(\e&your_function);
.Ve
.Sp
or supply an unnamed subroutine:
.Sp
.Vb 1
\& $status = $proc\->start( sub { sleep(1) } );
.Ve
.Sp
You can also provide additional parameters to be passed to the function:
.Sp
.Vb 1
\& $status = $proc\->start(\e&printme, "hello", "world");
.Ve
.Sp
The \fIstart\fR Method returns immediately after starting the
specified process in background, i.e. non-blocking mode.
It returns \fI1\fR if the process has been launched
successfully and \fI0\fR if not.
.IP "poll" 4
.IX Item "poll"
The \fIpoll\fR method checks if the process is still running
.Sp
.Vb 1
\&   $running = $myproc\->poll();
.Ve
.Sp
and returns \fI1\fR if it is, \fI0\fR if it's not.
.IP "kill" 4
.IX Item "kill"
The \fIkill()\fR method:
.Sp
.Vb 1
\&   $myproc\->kill();
.Ve
.Sp
terminates the process by sending it the \s-1SIGTERM\s0 signal. As an
option, another signal can be specified.
.Sp
.Vb 1
\&   $myproc\->kill("SIGUSR1");
.Ve
.Sp
sends the \s-1SIGUSR1\s0 signal to the running process. \fIkill\fR returns \fI1\fR if
it succeeds in sending the signal, \fI0\fR if it doesn't.
.IP "kill_on_destroy" 4
.IX Item "kill_on_destroy"
Set a flag to determine whether the process attached
to this object should be killed when the object is
destroyed. By default, this flag is set to false.
The current value is returned.
.Sp
.Vb 3
\&  $current = $proc\->kill_on_destroy;
\&  $proc\->kill_on_destroy(1); # Set flag to true
\&  $proc\->kill_on_destroy(0); # Set flag to false
.Ve
.IP "signal_on_destroy" 4
.IX Item "signal_on_destroy"
Method to set the signal that will be sent to the
process when the object is destroyed (Assuming
kill_on_destroy is true). Returns the current setting.
.Sp
.Vb 2
\&  $current = $proc\->signal_on_destroy;
\&  $proc\->signal_on_destroy("KILL");
.Ve
.IP "redirect_output" 4
.IX Item "redirect_output"
Redirects stdout and/or stderr output to a file.
Specify undef to leave the stderr/stdout handles of the process alone.
.Sp
.Vb 2
\&  # stdout to a file, left stderr unchanged
\&  $proc\->redirect_output ("/tmp/someapp.stdout", undef);
\&  
\&  # stderr to a file, left stdout unchanged
\&  $proc\->redirect_output (undef, "/tmp/someapp.stderr");
\&  
\&  # stdout and stderr to a separate file
\&  $proc\->redirect_output ("/tmp/someapp.stdout", "/tmp/someapp.stderr");
.Ve
.Sp
Call this method before running the start method.
.IP "pid" 4
.IX Item "pid"
Returns the pid of the forked process associated with
this object
.Sp
.Vb 1
\&  $pid = $proc\->pid;
.Ve
.IP "t0" 4
.IX Item "t0"
Returns the start \fItime()\fR of the forked process associated with
this object
.Sp
.Vb 1
\&  $t0 = $proc\->t0();
.Ve
.IP "t1" 4
.IX Item "t1"
Returns the stop \fItime()\fR of the forked process associated with
this object
.Sp
.Vb 1
\&  $t1 = $proc\->t1();
.Ve
.IP "\s-1DESTROY \s0(Destructor)" 4
.IX Item "DESTROY (Destructor)"
Object destructor. This method is called when the
object is destroyed (eg with \*(L"undef\*(R" or on exiting
perl). If kill_on_destroy is true the process
associated with the object is sent the signal_on_destroy
signal (\s-1SIGTERM\s0 if undefined).
.IP "exit_status" 4
.IX Item "exit_status"
Returns the exit status of the process as the $! variable indicates.
If the process is still running, \f(CW\*(C`undef\*(C'\fR is returned.
.IP "wait" 4
.IX Item "wait"
The \fIwait\fR method:
.Sp
.Vb 1
\&   $exit_status = $myproc\->wait();
.Ve
.Sp
waits until the process is done and returns its exit status.
.IP "debug" 4
.IX Item "debug"
Switches debug messages on and off \*(-- \fIProc::Simple::debug\fR\|(1) switches
them on, \fIProc::Simple::debug\fR\|(0) keeps Proc::Simple quiet.
.IP "cleanup" 4
.IX Item "cleanup"
Proc::Simple keeps around data of terminated processes, e.g. you can check via
\&\f(CW\*(C`t0()\*(C'\fR and \f(CW\*(C`t1()\*(C'\fR how long a process ran, even if it's long gone. Over time,
this data keeps occupying more and more memory and if you have a long-running
program, you might want to run \f(CW\*(C`Proc::Simple\->cleanup()\*(C'\fR every once in a
while to get rid of data pertaining to processes no longer in use.
.SH "NOTE"
.IX Header "NOTE"
Please keep in mind that there is no guarantee that the \s-1SIGTERM\s0
signal really terminates a process. Processes can have signal
handlers defined that avoid the shutdown.
If in doubt, whether a process still exists, check it
repeatedly with the \fIpoll\fR routine after sending the signal.
.SH "Shell Processes"
.IX Header "Shell Processes"
If you pass a shell program to Proc::Simple, it'll use \f(CW\*(C`exec()\*(C'\fR to 
launch it. As noted in Perl's \f(CW\*(C`exec()\*(C'\fR manpage, simple commands for
the one-argument version of \f(CW\*(C`exec()\*(C'\fR will be passed to 
\&\f(CW\*(C`execvp()\*(C'\fR directly, while commands containing characters
like \f(CW\*(C`;\*(C'\fR or \f(CW\*(C`*\*(C'\fR will be passed to a shell to make sure those get
the shell expansion treatment.
.PP
This has the interesting side effect that if you launch something like
.PP
.Vb 1
\&    $p\->start("./womper *");
.Ve
.PP
then you'll see two processes in your process list:
.PP
.Vb 3
\&    $ ps auxww | grep womper
\&    mschilli  9126 11:21 0:00 sh \-c ./womper *
\&    mschilli  9127 11:21 0:00 /usr/local/bin/perl \-w ./womper ...
.Ve
.PP
A regular \f(CW\*(C`kill()\*(C'\fR on the process \s-1PID\s0 would only kill the first
process, but Proc::Simple's \f(CW\*(C`kill()\*(C'\fR will use a negative signal
and send it to the first process (9126). Since it has marked the
process as a process group leader when it created it previously
(via \fIsetsid()\fR), this will cause both processes above to receive the
signal sent by \f(CW\*(C`kill()\*(C'\fR.
.SH "Contributors"
.IX Header "Contributors"
Tim Jenness  <t.jenness@jach.hawaii.edu>
   did kill_on_destroy/signal_on_destroy/pid
.PP
Mark R. Southern <mark_southern@merck.com>
   worked on \s-1EXIT_STATUS\s0 tracking
.PP
Tobias Jahn <tjahn@users.sourceforge.net>
   added redirection to stdout/stderr
.PP
Clauss Strauch <Clauss_Strauch@aquila.fac.cs.cmu.edu>
suggested the multi-arg \fIstart()\fR\-methods.
.PP
Chip Capelik contributed a patch with the \fIwait()\fR method.
.PP
Jeff Holt provided a patch for time tracking with \fIt0()\fR and \fIt1()\fR.
.PP
Brad Cavanagh fixed \s-1RT33440 \s0(unreliable $?)
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\&    1996, Mike Schilli <cpan@perlmeister.com>
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
Copyright 1996\-2011 by Mike Schilli, all rights reserved.
This program is free software, you can redistribute it and/or
modify it under the same terms as Perl itself.
