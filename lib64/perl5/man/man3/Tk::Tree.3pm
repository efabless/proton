.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Tree 3"
.TH Tree 3 "2015-01-31" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tk::Tree \- Create and manipulate Tree widgets
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\ \ \ \ \fBuse Tk::Tree;\fR
.PP
\&\ \ \ \ \fI\f(CI$tree\fI\fR = \fI\f(CI$parent\fI\fR\->\fBTree\fR(?\fIoptions\fR?);
.SH "SUPER-CLASS"
.IX Header "SUPER-CLASS"
The \fBTree\fR class is derived from the HList class and inherits all
the methods, options and subwidgets of its super-class.  A \fBTree\fR widget is
not scrolled by default.
.SH "STANDARD OPTIONS"
.IX Header "STANDARD OPTIONS"
\&\fBTree\fR supports all the standard options of an HList widget.
See Tk::options for details on the standard options.
.SH "WIDGET-SPECIFIC OPTIONS"
.IX Header "WIDGET-SPECIFIC OPTIONS"
.IP "Name:		\fBbrowseCmd\fR" 4
.IX Item "Name: browseCmd"
.PD 0
.IP "Class:		\fBBrowseCmd\fR" 4
.IX Item "Class: BrowseCmd"
.IP "Switch:		\fB\-browsecmd\fR" 4
.IX Item "Switch: -browsecmd"
.PD
Specifies a callback to call whenever the user browses on an entry
(usually by single-clicking on the entry). The callback is called with
one argument, the pathname of the entry.
.IP "Name:		\fBcloseCmd\fR" 4
.IX Item "Name: closeCmd"
.PD 0
.IP "Class:		\fBCloseCmd\fR" 4
.IX Item "Class: CloseCmd"
.IP "Switch:		\fB\-closecmd\fR" 4
.IX Item "Switch: -closecmd"
.PD
Specifies a callback to call whenever an entry needs to be closed (See
\&\*(L"\s-1BINDINGS\*(R"\s0 below). This method is called with one argument,
the pathname of the entry. This method should perform appropriate
actions to close the specified entry. If the \fB\-closecmd\fR option
is not specified, the default closing action is to hide all child
entries of the specified entry.
.IP "Name:		\fBcommand\fR" 4
.IX Item "Name: command"
.PD 0
.IP "Class:		\fBCommand\fR" 4
.IX Item "Class: Command"
.IP "Switch:		\fB\-command\fR" 4
.IX Item "Switch: -command"
.PD
Specifies a callback to call whenever the user activates an entry
(usually by double-clicking on the entry). The callback
is called with one argument, the pathname of the entry.
.IP "Name:		\fBignoreInvoke\fR" 4
.IX Item "Name: ignoreInvoke"
.PD 0
.IP "Class:		\fBIgnoreInvoke\fR" 4
.IX Item "Class: IgnoreInvoke"
.IP "Switch:		\fB\-ignoreinvoke\fR" 4
.IX Item "Switch: -ignoreinvoke"
.PD
A Boolean value that specifies when a branch should be opened or
closed. A branch will always be opened or closed when the user presses
the (+) and (\-) indicators. However, when the user invokes a branch
(by doublc-clicking or pressing <Return>), the branch will be opened
or closed only if \fB\-ignoreinvoke\fR is set to false (the default
setting).
.IP "Name:		\fBopenCmd\fR" 4
.IX Item "Name: openCmd"
.PD 0
.IP "Class:		\fBOpenCmd\fR" 4
.IX Item "Class: OpenCmd"
.IP "Switch:		\fB\-opencmd\fR" 4
.IX Item "Switch: -opencmd"
.PD
Specifies a callback to call whenever an entry needs to be opened (See
\&\*(L"\s-1BINDINGS\*(R"\s0 below). This method is called with one argument,
the pathname of the entry. This method should perform appropriate
actions to open the specified entry. If the \fB\-opencmd\fR option
is not specified, the default opening action is to show all the child
entries of the specified entry.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBTree\fR method creates a new window and makes it into a Tree widget
and return a reference to it.  Additional options, described above, may
be specified on the command line or in the option database to configure
aspects of the Tree widget such as its cursor and relief.
.PP
The Tree widget can be used to display hierarchical data in a tree
form. The user can adjust the view of the tree by opening or closing
parts of the tree.
.PP
To display a static tree structure, you can add the entries into the
Tree widget and hide any entries as desired. Then you can call
the \fBautosetmode\fR method. This will set up the Tree widget so that it
handles all the \fIopen\fR and \fIclose\fR events automatically.
the demonstration program \fITixish/examples/perl\-tix\-tree\fR).
.PP
The above method is not applicable if you want to maintain a dynamic tree
structure, i.e, you do not know all the entries in the tree and you need
to add or delete entries subsequently. To do this, you should first create
the entries in the Tree widget. Then, use the \fBsetmode\fR method to
indicate the entries that can be opened or closed, and use the \fB\-opencmd\fR
and \fB\-closecmd\fR options to handle the opening and closing events. (Please
see the demonstration program \fITixish/examples/perl\-tix\-dyntree\fR).
.PP
Use either
.PP
\&\ \ \ \ \fI\f(CI$parent\fI\fR\->\fBScrolled\fR(\fB'Tree'\fR, ... );
.PP
or
.PP
\&\ \ \ \ \fI\f(CI$parent\fI\fR\->\fBScrlTree\fR( ... );
.PP
to create a scrolled \fBTree\fR. See Tk::Scrolled for details.
.SH "WIDGET METHODS"
.IX Header "WIDGET METHODS"
The \fBTree\fR method creates a widget object.
This object supports the \fBconfigure\fR and \fBcget\fR methods
described in Tk::options which can be used to enquire and
modify the options described above.
The widget also inherits all the methods provided by the generic
Tk::Widget class.
.PP
The following additional methods are available for Tree widgets:
.ie n .IP "\fI\fI$tree\fI\->\fR\fBadd_pathimage\fR(\fItreeRegExp [, openImg, closeImg]\fR)" 4
.el .IP "\fI\f(CI$tree\fI\->\fR\fBadd_pathimage\fR(\fItreeRegExp [, openImg, closeImg]\fR)" 4
.IX Item "$tree->add_pathimage(treeRegExp [, openImg, closeImg])"
This method defines images for a given path (images must be in xpm
format). The path can be determined by a simplified regular
expression. There are just three metasymbols:
.RS 4
.IP "^" 4
at the beginning of the \f(CW\*(C`treeRegExp\*(C'\fR same as in Perl regular
expressions
.IP "*" 4
anything
.IP "$" 4
at the end of the \f(CW\*(C`TreeRegExp\*(C'\fR, the same as in Perl regular
expressions
.RE
.RS 4
.Sp
Examples:
.Sp
.Vb 1
\&  $tree\->add_pathimage(\*(Aq^root\*(Aq,\*(Aqopenfolder\*(Aq,\*(Aqfolder\*(Aq);
.Ve
.Sp
matches \f(CW\*(C`root\*(C'\fR, \f(CW\*(C`root.foo\*(C'\fR, \f(CW\*(C`root.bar\*(C'\fR, but not \f(CW\*(C`foo.root\*(C'\fR
.Sp
.Vb 1
\&  $tree\->add_pathimage(\*(Aqroot.*.class\*(Aq,\*(Aqopenfolder\*(Aq,\*(Aqfolder\*(Aq);
.Ve
.Sp
matches all paths containing \f(CW\*(C`root.<anything>.class\*(C'\fR, but not
\&\f(CW\*(C`root.<anything>.<anything>.class\*(C'\fR \f(CW\*(C`*\*(C'\fR is one part of the path. If
you want to use a wildcard for two steps, you have to use \f(CW\*(C`*.*\*(C'\fR.
.Sp
.Vb 1
\&  $tree\->add_pathimage(\*(Aqclass$\*(Aq,\*(Aqopenfolder\*(Aq,\*(Aqfolder\*(Aq);
.Ve
.Sp
This matches all path with \f(CW\*(C`class\*(C'\fR at the end.
.RE
.ie n .IP "\fI\fI$tree\fI\fR\->\fBautosetmode\fR" 4
.el .IP "\fI\f(CI$tree\fI\fR\->\fBautosetmode\fR" 4
.IX Item "$tree->autosetmode"
This method calls the \fBsetmode\fR method for all the entries in
this Tree widget: if an entry has no child entries, its mode is set to
\&\fBnone\fR. Otherwise, if the entry has any hidden child entries, its
mode is set to \fBopen\fR; otherwise its mode is set to \fBclose\fR.
.ie n .IP "\fI\fI$tree\fI\->\fR\fBchild_entries\fR([$path][,$depth])" 4
.el .IP "\fI\f(CI$tree\fI\->\fR\fBchild_entries\fR([$path][,$depth])" 4
.IX Item "$tree->child_entries([$path][,$depth])"
This method returns in list context an array that contains all
pathnames of subentries within the given path. In scalar context it
returns the number of subentries in the given path.
.Sp
.Vb 6
\&  Example:
\&    root
\&     | foo
\&     | bar
\&     |  | bar1
\&     |  | bar2
\&
\&  my @childentries = $tree\->child_entries(\*(Aqroot.bar\*(Aq);
\&  # returns (root.bar.bar1, root.bar.bar2)
\&
\&  my $nr_of_subentries = $tree\->child_entries(\*(Aqroot\*(Aq,2);
\&  # returns 4
.Ve
.Sp
If \f(CW$path\fR is omitted, all it is assumed, that the entry above
\&'root' is meant. \f(CW$depth\fR defines the numbers of levels.
.ie n .IP "\fI\fI$tree\fI\fR\->\fBclose\fR(\fIentryPath\fR)" 4
.el .IP "\fI\f(CI$tree\fI\fR\->\fBclose\fR(\fIentryPath\fR)" 4
.IX Item "$tree->close(entryPath)"
Close the entry given by \fIentryPath\fR if its \fImode\fR is \fBclose\fR.
.ie n .IP "\fI\fI$tree\fI\fR\->\fBgetmode\fR(\fIentryPath\fR)" 4
.el .IP "\fI\f(CI$tree\fI\fR\->\fBgetmode\fR(\fIentryPath\fR)" 4
.IX Item "$tree->getmode(entryPath)"
Returns the current \fImode\fR of the entry given by \fIentryPath\fR.
.ie n .IP "\fI\fI$tree\fI\fR\->\fBopen\fR(\fIentryPath\fR)" 4
.el .IP "\fI\f(CI$tree\fI\fR\->\fBopen\fR(\fIentryPath\fR)" 4
.IX Item "$tree->open(entryPath)"
Open the entry given by \fIentryPath\fR if its \fImode\fR is \fBopen\fR.
.ie n .IP "\fI\fI$tree\fI\fR\->\fBsetmode\fR(\fIentryPath, mode\fR)" 4
.el .IP "\fI\f(CI$tree\fI\fR\->\fBsetmode\fR(\fIentryPath, mode\fR)" 4
.IX Item "$tree->setmode(entryPath, mode)"
This method is used to indicate whether the entry given by
\&\fIentryPath\fR has children entries and whether the children are
visible. \fImode\fR must be one of \fBopen\fR,
\&\fBclose\fR or \fBnone\fR. If \fImode\fR is set to \fBopen\fR, a (+)
indicator is drawn next to the entry. If \fImode\fR is set to
\&\fBclose\fR, a (\-) indicator is drawn next to the entry. If
\&\fImode\fR is set to \fBnone\fR, no indicators will be drawn for this
entry. The default \fImode\fR is none. The \fBopen\fR mode indicates
the entry has hidden children and this entry can be opened by the
user. The \fBclose\fR mode indicates that all the children of the entry
are now visible and the entry can be closed by the user.
.SH "BINDINGS"
.IX Header "BINDINGS"
The basic mouse and keyboard bindings of the Tree widget are the same
as the bindings of the HList widget.
In addition, the entries can be opened or closed under the following
conditions:
.IP "[1]" 4
.IX Item "[1]"
If the \fImode\fR of the entry is \fBopen\fR, it can be opened by clicking
on its (+) indicator.
.IP "[2]" 4
.IX Item "[2]"
If the \fImode\fR of the entry is \fBclose\fR, it can be closed by clicking
on its (\-) indicator.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Tk::HList
.SH "AUTHOR"
.IX Header "AUTHOR"
Perl/TK version by Chris Dean <ctdean@cogit.com>.  Original Tcl/Tix
version by Ioi Kim Lam.
.PP
Additions by Renee Baecker <module@renee\-baecker.de>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Achim Bohnet <ach@mpe.mpg.de> for all his help.
