.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PTKSH 1"
.TH PTKSH 1 "2013-11-18" "Tk804.033" "perl/Tk Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ptksh \- Perl/Tk script to provide a graphical user interface for testing Perl/Tk
commands and scripts.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  % ptksh  ?scriptfile?
\&  ... version information ...
\&  ptksh> $b=$mw\->Button(\-text=>\*(AqHi\*(Aq,\-command=>sub{print \*(AqHi\*(Aq})
\&  ptksh> $b\->pack
\&  ptksh> o $b
\&  ... list of options ...
\&  ptksh> help
\&  ... help information ...
\&  ptksh> exit
\&  %
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
ptksh is a perl/Tk shell to enter perl commands
interactively.  When one starts ptksh a MainWindow
is automaticly created, along with a ptksh command window.
One can access the main window by typing commands using the
variable \f(CW$mw\fR at the 'ptksh> ' prompt of the command window.
.PP
ptksh supports command line editing and history.  Just type \*(L"<Up>\*(R" at
the command prompt to see a history list.  The last 50 commands entered
are saved, then reloaded into history list the next time you start ptksh.
.PP
ptksh supports some convenient commands for inspecting Tk widgets.  See below.
.PP
To exit ptksh use: \f(CW\*(C`exit\*(C'\fR.
.PP
ptksh is \fB*not*\fR a full symbolic debugger.
To debug perl/Tk programs at a low level use the more powerful
perl debugger.  (Just enter ``O tk'' on debuggers
command line to start the Tk eventloop.)
.SH "FEATURES"
.IX Header "FEATURES"
.SS "History"
.IX Subsection "History"
Press <Up> (the Up Arrow) in the perlwish window to obtain a gui-based history list.
Press <Enter> on any history line to enter it into the perlwish window.
Then hit return.  So, for example, repeat last command is <Up><Enter><Enter>.
You can quit the history window with <Escape>.  \s-1NOTE:\s0 history is only saved
if exit is \*(L"graceful\*(R" (i.e. by the \*(L"exit\*(R" command from the console or by
quitting all main windows\*(--NOT by interrupt).
.SS "Debugging Support"
.IX Subsection "Debugging Support"
ptksh provides some convenience function to make browsing
in perl/Tk widget easier:
.IP "\fB?\fR, or \fBh\fR" 4
.IX Item "?, or h"
displays a short help summary.
.IP "\fBd\fR, or \fBx\fR ?\fIargs\fR, ...?" 4
.IX Item "d, or x ?args, ...?"
Dumps recursively arguments to stdout. (see Data::Dumper).
You must have <Data::Dumper> installed to support this feature.
.Sp
\&\fBx\fR was introduced for perl debugger compatibility.
.IP "\fBp\fR ?\fIarg\fR, ...?" 4
.IX Item "p ?arg, ...?"
appends \*(L"|\en\*(R" to each of it's arguments and prints it.
If value is \fBundef\fR, '(undef)' is printed to stdout.
.ie n .IP "\fBo\fR \fI\fI$widget\fI\fR ?\fI\-option\fR ...?" 4
.el .IP "\fBo\fR \fI\f(CI$widget\fI\fR ?\fI\-option\fR ...?" 4
.IX Item "o $widget ?-option ...?"
prints the option(s) of \fI\f(CI$widget\fI\fR one on each line.
If no options are given all options of the widget are
listed.  See Tk::options for more details on the
format and contents of the returned list.
.ie n .IP "\fBo\fR \fI\fI$widget\fI\fR \fB/\fR\fIregexp\fR\fB/\fR" 4
.el .IP "\fBo\fR \fI\f(CI$widget\fI\fR \fB/\fR\fIregexp\fR\fB/\fR" 4
.IX Item "o $widget /regexp/"
Lists options of \fI\f(CI$widget\fI\fR matching the
regular expression \fIregexp\fR.
.IP "\fBu\fR ?\fIclass\fR?" 4
.IX Item "u ?class?"
If no argument is given it lists the modules loaded
by the commands you executed or since the last time you
called \f(CW\*(C`u\*(C'\fR.
.Sp
If argument is the empty string lists all modules that are
loaded by ptksh.
.Sp
If argument is a string, ``text'' it tries to do a ``use Tk::Text;''.
.SS "Packages"
.IX Subsection "Packages"
Ptksh compiles into package Tk::ptksh.  Your code is eval'ed into package
main.  The coolness of this is that your eval code should not interfere with
ptksh itself.
.SS "Multiline Commands"
.IX Subsection "Multiline Commands"
ptksh will accept multiline commands.  Simply put a \*(L"\e\*(R" character immediately
before the newline, and ptksh will continue your command onto the next line.
.SS "Source File Support"
.IX Subsection "Source File Support"
If you have a perl/Tk script that you want to do debugging on, try running the
command
.PP
.Vb 1
\&  ptksh> do \*(Aqmyscript\*(Aq;
\&
\&   \-\- or  (at shell command prompt) \-\-
\&
\&  % ptksh myscript
.Ve
.PP
Then use the perl/Tk commands to try out different operations on your script.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
Looks for your .ptksh_history in the directory specified by
the \f(CW$HOME\fR environment variable ($HOMEPATH on Win32 systems).
.SH "FILES"
.IX Header "FILES"
.IP "\fI.ptksh_init\fR" 4
.IX Item ".ptksh_init"
If found in current directory it is read in an evaluated
after the mainwindow \fI\f(CI$mw\fI\fR is created. \fI.ptksh_init\fR
can contain any valid perl code.
.IP "\fI~/.ptksh_history\fR" 4
.IX Item "~/.ptksh_history"
Contains the last 50 lines entered in ptksh session(s).
.SH "PITFALLS"
.IX Header "PITFALLS"
It is best not to use \*(L"my\*(R" in the commands you type into ptksh.
For example \*(L"my \f(CW$v\fR\*(R" will make \f(CW$v\fR local just to the command or commands
entered until <Return> is pressed.
For a related reason, there are no file-scopy \*(L"my\*(R" variables in the
ptksh code itself (else the user might trounce on them by accident).
.SH "BUGS"
.IX Header "BUGS"
\&\fBTk::MainLoop\fR function interactively entered or sourced in a
init or script file will block ptksh.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Tk
perldebug
.SH "VERSION"
.IX Header "VERSION"
\&\s-1VERSION 2.03\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
Mike Beller <beller@penvision.com>,
Achim Bohnet <ach@mpe.mpg.de>
.PP
Copyright (c) 1996 \- 1998 Achim Bohnet and Mike Beller. All rights reserved.
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
