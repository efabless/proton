.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "VPASSERT 1"
.TH VPASSERT 1 "2015-03-16" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
vpassert \- Preprocess Verilog code assertions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBvpassert\fR
[ \fB\-\-help\fR ]
[ \fB\-\-date\fR ]
[ \fB\-\-quiet\fR ]
[ \-y \fBdirectories...\fR ]
[ \fBfiles...\fR ]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Vpassert will read the specified Verilog files and preprocess special \s-1PLI\s0
assertions.  The files are written to the directory named .vpassert unless
another name is given with \fB\-o\fR.  If a directory is passed, all files in
that directory will be preprocessed.
.SH "ARGUMENTS"
.IX Header "ARGUMENTS"
Standard \s-1VCS\s0 and GCC-like parameters are used to specify the files to be
preprocessed:
.PP
.Vb 6
\&    +libext+I<ext>+I<ext>...    Specify extensions to be processed
\&    \-f I<file>          Parse parameters in file
\&    \-v I<file>          Parse the library file (I<file>)
\&    \-y I<dir>           Parse all files in the directory (I<dir>)
\&    \-II<dir>            Parse all files in the directory (I<dir>)
\&    +incdir+I<dir>      Parse all files in the directory (I<dir>)
.Ve
.PP
To prevent recursion and allow reuse of the input.vc being passed to the
simulator, if the output directory is requested to be preprocessed, that
directory is simply ignored.
.IP "\-\-allfiles" 4
.IX Item "--allfiles"
Preprocess and write out files that do not have any macros that need
expanding.  By default, files that do not need processing are not written
out.
.Sp
This option may speed up simulator compile times; the file will always be
found in the preprocessed directory, saving the compiler from having to
search a large number of \-v directories to find it.
.IP "\-\-axiom" 4
.IX Item "--axiom"
Special Axiom \s-1ATHDL\s0 enables/disables added around unreachable code.
.IP "\-\-call\-error <function>" 4
.IX Item "--call-error <function>"
When \f(CW$uerror\fR (or \f(CW$uassert\fR etc.) wants to display a message, call the
specified function instead of \f(CW$display\fR and \f(CW$stop\fR.
.IP "\-\-call\-info <function>" 4
.IX Item "--call-info <function>"
When \f(CW$uinfo\fR wants to display a message, call the specified function instead
of \f(CW$display\fR.
.IP "\-\-call\-warn <function>" 4
.IX Item "--call-warn <function>"
When \f(CW$uwarn\fR (or \f(CW$uwarn_clk\fR etc.) wants to display a message, call the
specified function instead of \f(CW$display\fR and \f(CW$stop\fR.
.IP "\-\-date" 4
.IX Item "--date"
Check file dates and sizes versus the last run of vpassert and don't
process if the given source file has not changed.
.IP "\-\-exclude" 4
.IX Item "--exclude"
Exclude processing any files which begin with the specified prefix.
.IP "\-\-help" 4
.IX Item "--help"
Displays this message and program version and exits.
.IP "\-\-language <1364\-1995|1364\-2001|1364\-2005|1800\-2005|1800\-2009|1800\-2012>" 4
.IX Item "--language <1364-1995|1364-2001|1364-2005|1800-2005|1800-2009|1800-2012>"
Set the language standard for the files.  This determines which tokens are
signals versus keywords, such as the ever-common \*(L"do\*(R" (data-out signal,
versus a do-while loop keyword).
.IP "\-\-minimum" 4
.IX Item "--minimum"
Include `_\|_message_minimum in the \f(CW$uinfo\fR test, so that by defining
_\|_message_minimum=1 some uinfos may be optimized away at compile time.
.IP "\-\-noline" 4
.IX Item "--noline"
Do not emit `line directives.  If not specified they will be used under
\&\-\-language 1364\-2001 and later.
.IP "\-\-nopli" 4
.IX Item "--nopli"
Delete all 'simple' \s-1PLI\s0 calls.  \s-1PLI\s0 function calls inside parenthesis will
not be changed, and thus may still need to be manually ifdef'ed out.
Useful for reducing the amount of `ifdef's required to feed non-PLI
competent synthesis programs.
.IP "\-\-nostop" 4
.IX Item "--nostop"
By default, \f(CW$error\fR and \f(CW$warn\fR insert a \f(CW$stop\fR statement.  With \-\-nostop, this
is replaced by incrementing a variable, which may then be used to
conditionally halt simulation.
.IP "\-\-o \fIfile\fR" 4
.IX Item "--o file"
Use the given filename for output instead of the input name .vpassert.  If
the name ends in a / it is used as a output directory with the default
name.
.IP "\-\-quiet" 4
.IX Item "--quiet"
Suppress messages about what files are being preprocessed.
.IP "\-\-realintent" 4
.IX Item "--realintent"
Special RealIntent enable/disables added around unreachable code.
.IP "\-\-synthcov" 4
.IX Item "--synthcov"
When \*(L"ifdef \s-1SYNTHESIS\*(R"\s0 is seen, disable coverage.  Resume on the `else or
`endif.  This does \s-1NOT\s0 follow child defines, for example:
.Sp
.Vb 4
\&  \`ifdef SYNTHSIS
\&    \`define MYSYNTH
\&  \`endif
\&  \`ifdef MYSYNTH   // This will not be coveraged\-off
.Ve
.IP "\-\-timeformat\-units \fIunits\fR" 4
.IX Item "--timeformat-units units"
If specified, include Verilog \f(CW$timeformat\fR calls before all messages.  Use
the provided argument as the units.  Units is in powers of 10, so \-9
indicates to use nanoseconds.
.IP "\-\-timeformat\-precision \fIprec\fR" 4
.IX Item "--timeformat-precision prec"
When using \-\-timeformat\-units, use this as the precision value, the number
of digits after the decimal point.  Defaults to zero.
.IP "\-\-vericov" 4
.IX Item "--vericov"
Special Vericov enable/disables added around unreachable code.
.IP "\-\-verilator" 4
.IX Item "--verilator"
Special Verilator translations enabled.
.IP "\-\-version" 4
.IX Item "--version"
Displays program version and exits.
.IP "\-\-vcs" 4
.IX Item "--vcs"
Special Synopsys \s-1VCS\s0 enables/disables added around unreachable code.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
These Verilog pseudo-pli calls are expanded:
.IP "/*vp_coverage_off*/" 4
.IX Item "/*vp_coverage_off*/"
Disable coverage for all tools starting at this point.  Does not need to be
on a unique line.
.IP "/*vp_coverage_on*/" 4
.IX Item "/*vp_coverage_on*/"
Re-enable coverage after a vp_coverage_off.  Does not need to be on a
unique line.
.ie n .IP "$uassert (\fIcase\fR, ""message"", [\fIvars\fR...] )" 4
.el .IP "\f(CW$uassert\fR (\fIcase\fR, ``message'', [\fIvars\fR...] )" 4
.IX Item "$uassert (case, message, [vars...] )"
Report a \f(CW$uerror\fR if the given case is \s-1FALSE.  \s0(Like \fIassert()\fR in C.)
.ie n .IP "$uassert_amone (\fIsig\fR, [\fIsig\fR...], ""message"", [\fIvars\fR...] )" 4
.el .IP "\f(CW$uassert_amone\fR (\fIsig\fR, [\fIsig\fR...], ``message'', [\fIvars\fR...] )" 4
.IX Item "$uassert_amone (sig, [sig...], message, [vars...] )"
Report a \f(CW$uerror\fR if more than one signal is asserted, or any are X.  (None
asserted is ok.)  The error message will include a binary display of the
signal values.
.ie n .IP "$uassert_info (\fIcase\fR, ""message"", [\fIvars\fR...] )" 4
.el .IP "\f(CW$uassert_info\fR (\fIcase\fR, ``message'', [\fIvars\fR...] )" 4
.IX Item "$uassert_info (case, message, [vars...] )"
Report a \f(CW$uinfo\fR if the given case is \s-1FALSE.  \s0(Like \fIassert()\fR in C.)
.ie n .IP "$uassert_onehot (\fIsig\fR, [\fIsig\fR...], ""message"", [\fIvars\fR...] )" 4
.el .IP "\f(CW$uassert_onehot\fR (\fIsig\fR, [\fIsig\fR...], ``message'', [\fIvars\fR...] )" 4
.IX Item "$uassert_onehot (sig, [sig...], message, [vars...] )"
Report a \f(CW$uerror\fR if other than one signal is asserted, or any are X.  The
error message will include a binary display of the signal values.
.ie n .IP "$uassert_req_ack (\fIreq_sig\fR, \fIack_sig\fR, [\fIdata_sig\fR,...] )" 4
.el .IP "\f(CW$uassert_req_ack\fR (\fIreq_sig\fR, \fIack_sig\fR, [\fIdata_sig\fR,...] )" 4
.IX Item "$uassert_req_ack (req_sig, ack_sig, [data_sig,...] )"
Check for a single cycle request pulse, followed by a single cycle
acknowledgment pulse.  Do not allow any of the data signals to change
between the request and acknowledgement.
.ie n .IP "$ucheck_ilevel (\fIlevel\fR )" 4
.el .IP "\f(CW$ucheck_ilevel\fR (\fIlevel\fR )" 4
.IX Item "$ucheck_ilevel (level )"
Return true if the _\|_message level is greater or equal to the given
level, and that global messages are turned on.
.ie n .IP "$ucover_clk (\fIclock\fR, \fIlabel\fR)" 4
.el .IP "\f(CW$ucover_clk\fR (\fIclock\fR, \fIlabel\fR)" 4
.IX Item "$ucover_clk (clock, label)"
Similar to \f(CW$uerror_clk\fR, add a SystemVerilog assertion at the next specified
clock's edge, with the label specified. This allows cover properties to be
specified \*(L"inline\*(R" with normal \s-1RTL\s0 code.
.ie n .IP "$ucover_foreach_clk (\fIclock\fR, \fIlabel\fR, ""\fImsb\fR:\fIlsb\fR"", (... $ui ...))" 4
.el .IP "\f(CW$ucover_foreach_clk\fR (\fIclock\fR, \fIlabel\fR, ``\fImsb\fR:\fIlsb\fR'', (... \f(CW$ui\fR ...))" 4
.IX Item "$ucover_foreach_clk (clock, label, ""msb:lsb"", (... $ui ...))"
Similar to \f(CW$ucover_clk\fR, however cover a range where \f(CW$ui\fR in the expression
is replaced with the range index.
.Sp
Range is "\fImsb\fR:\fIlsb\fR" to indicate from \fImsb\fR downto \fIlsb\fR inclusive,
and/or a comma separated list of values.
.Sp
Similar to:
.Sp
.Vb 4
\&   for ($ui=msb; $ui>=lsb; $ui=$ui\-1) begin
\&        if (expression with $ui)
\&            $ucover_clk(clock, label ## "_" ## bit)
\&   end
.Ve
.Sp
However there's no way to form a label from a for loop (as psudocoded with
## above), thus this macro.
.ie n .IP "$ui" 4
.el .IP "\f(CW$ui\fR" 4
.IX Item "$ui"
Loop index used inside \f(CW$ucover_foreach_clk\fR.
.ie n .IP "$uinfo (\fIlevel\fR, ""message"", [\fIvars\fR...] )" 4
.el .IP "\f(CW$uinfo\fR (\fIlevel\fR, ``message'', [\fIvars\fR...] )" 4
.IX Item "$uinfo (level, message, [vars...] )"
Report a informational message in standard form.  End test if warning
limit exceeded.
.ie n .IP "$uerror (""message"", [\fIvars\fR...] )" 4
.el .IP "\f(CW$uerror\fR (``message'', [\fIvars\fR...] )" 4
.IX Item "$uerror (message, [vars...] )"
Report a error message in standard form.  End test if error limit exceeded.
.ie n .IP "$uerror_clk (\fIclock\fR, ""message"", [\fIvars\fR...] )" 4
.el .IP "\f(CW$uerror_clk\fR (\fIclock\fR, ``message'', [\fIvars\fR...] )" 4
.IX Item "$uerror_clk (clock, message, [vars...] )"
Report a error message in standard form at the next clock edge.  If you
place a \f(CW$uerror\fR etc in a combo logic block (always @*), event based
simulators may misfire the assertion due to glitches.  \f(CW$uerror_clk\fR fixes
this by instead creating a temporary signal and then moving the assert
itself to a new clocked block at the specified edge.  Note any variables
printed will be the values at the time of the next clock edge, which may
differ from the value where the \f(CW$uerror_clk\fR is assigned.
.ie n .IP "$uwarn (""message"", [\fIvars\fR...] )" 4
.el .IP "\f(CW$uwarn\fR (``message'', [\fIvars\fR...] )" 4
.IX Item "$uwarn (message, [vars...] )"
Report a warning message in standard form.
.ie n .IP "$uwarn_clk (\fIclock\fR ""message"", [\fIvars\fR...] )" 4
.el .IP "\f(CW$uwarn_clk\fR (\fIclock\fR ``message'', [\fIvars\fR...] )" 4
.IX Item "$uwarn_clk (clock message, [vars...] )"
Report a warning message in standard form at the next clock edge.  See
\&\f(CW$uerror_clk\fR.
.SH "DISTRIBUTION"
.IX Header "DISTRIBUTION"
Verilog-Perl is part of the <http://www.veripool.org/> free Verilog \s-1EDA\s0
software tool suite.  The latest version is available from \s-1CPAN\s0 and from
<http://www.veripool.org/verilog\-perl>.
.PP
Copyright 2000\-2015 by Wilson Snyder.  This package is free software; you
can redistribute it and/or modify it under the terms of either the \s-1GNU\s0
Lesser General Public License Version 3 or the Perl Artistic License Version 2.0.
.SH "AUTHORS"
.IX Header "AUTHORS"
Wilson Snyder <wsnyder@wsnyder.org>,
Duane Galbi <duane.galbi@conexant.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Verilog-Perl,
Verilog::Parser, Verilog::Pli
