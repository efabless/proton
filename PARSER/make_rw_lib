
sub function_name {
  my @file_array0 = ();
  my $v;
  my $identifier = "([A-Z]([A-Z]|[0-9]|_)*)";
  my $filename = $_[0];
  open(READ, "$filename");
  my $isFunctionFound = 0 ;
  my $flopfound = 0;
  my $latchfound = 0;
  while (<READ>) {
    if($_ =~ /^$/ || $_ =~ /^#/) {
      next;
    }
    chomp();
    if($_ =~ m/^\s*cell\s*\(/) {
      $flopfound = 0;
      $latchfound = 0;
      if($v) {
        if($isFunctionFound == 1){
          push (@file_array0, $v);
        } else {
          $v = $v . " und" ;
          push (@file_array0, $v);
        }
        $isFunctionFound = 0;
      }
      s/\{//;
      #s/\s*//g;
      #print "\n$_";
      $v = $_ . "-";
      next ;
    }
##---------------------------------------------------------------------------------##
    if($_ =~ m/^\s*latch\s*\(/){
      $latchfound = 1;
     #print "Latch $_\n";
    }
    if($_ =~ m/^\s*ff\s*\(/){
      $flopfound = 1;
     #print "Flop $_\n";
    }
##---------------------------------------------------------------------------------##
    if($_ =~ m/^\s*function/) {
      $isFunctionFound = 1 ;
      s/\s*function//;
      s/\://;
      s/\"//;
      s/\"//;
      s/\;//;
      s/^\s+|\s+$//g;
      #print " $_";
      chomp();
      #$v = $v . " " . $_ ;  

    if ($_ =~ m/^\(\s*$identifier\s*\^\s*$identifier\s*\^\s*$identifier\s*\)$/) {
      $v = $v . " sum of full adder" ;
    }
    elsif ($_ =~ m/^\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\^\s*$identifier\s*\)$/) {
      $v = $v . " xor" ;
    }
    elsif ($_ =~ m/^\(\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\^\s*$identifier\s*\)\^\s*$identifier\s*\)$/) {
      $v = $v . " xor" ;
    }
    elsif ($_ =~ m/^\(\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s+$identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s+$identifier\s*\)\s*\)/) {
     # print " carry of full adder";
      $v = $v . " carry of full adder" ;
    }
    elsif($_ =~ m/^\(\s*$identifier\s+$identifier\s*\)$/){
      #print " and ";
      $v = $v . " and" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)$/){
      #print " and ";
      $v = $v . " and" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s+$identifier\s*\)$/){
      #print " and ";
      $v = $v . " and" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s+$identifier\s*\)\s+$identifier\s*\)$/){
      #print " and ";
      $v = $v . " and" ;
    }
    elsif($_ =~ m/^\(\s*$identifier((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $v = $v . " or" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $v = $v . " or" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $v = $v . " or" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $v = $v . " or" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $v = $v . " andor" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $v = $v . " andor" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))\(\s*$identifier\s+$identifier\s*\)\s*\)((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $v = $v . " andor" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))\(\s*$identifier\s+$identifier\s*\)\s*\)((\|)|(\+))\(\s*$identifier\s+$identifier\s*\)\s*\)$/){
      #print " and ";
      $v = $v . " andor" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))\(\s*$identifier\s+$identifier\s*\)\s*\)$/){
      #print " and ";
      $v = $v . " andor" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $v = $v . " andor" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s*\)$/){
      #print " and ";
      $v = $v . " andor" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)\s+$identifier\s*\)\s+$identifier\s*\)$/){
      #print " and ";
      $v = $v . " orand" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)\s+$identifier\s*\)$/){
      #print " and ";
      $v = $v . " orand" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)\s+\(\s*$identifier((\|)|(\+))$identifier\s*\)\s*\)\s+$identifier\s*\)$/){
      #print " and ";
      $v = $v . " orand" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)\s+\(\s*$identifier((\|)|(\+))$identifier\s*\)\s*\)\s+\(\s*$identifier((\|)|(\+))$identifier\s*\)\s*\)$/){
      #print " and ";
      $v = $v . " orand" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)\s+\(\s*$identifier((\|)|(\+))$identifier\s*\)\s*\)$/){
      #print " and ";
      $v = $v . " orand" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)\s+$identifier\s*\)$/){
      #print " and ";
      $v = $v . " orand" ;
    }
    elsif($_ =~ m/^\(\s*\!\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s*\)\s*\)$/){
      #print " and ";
      $v = $v . " aoi" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)((\|)|(\+))\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s*\)$/){
      #print " and ";
      $v = $v . " andor" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)\s+\(\s*\($identifier((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)\s*\)$/){
      #print " and ";
      $v = $v . " orand" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)\s+\(\s*\($identifier((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)\s*\)$/){
      #print " and ";
      $v = $v . " orand" ;
    }
    elsif($_ =~ m/^\(\s*\!\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)((\|)|(\+))\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s*\)\s*\)$/){
      #print " and ";
      $v = $v . " aoi" ;
    }
    elsif($_ =~ m/^\(\s*$identifier\s*\^\s*$identifier\s*\)/){
      #print " xor ";
      $v = $v . " xor" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*$identifier\s+$identifier\s*\)\s+((\|)|(\+))\s+\(\s*\!$identifier\s+$identifier\s*\)\s*\)/){
      #print " xor ";
      $v = $v . " mux" ;
    }
    elsif($_ =~ m/^\(\!\(\s*\(\s*$identifier\s+$identifier\s*\)\s+((\|)|(\+))\s+\(\s*\!$identifier\s+$identifier\s*\)\s*\)\s*\)/){
      #print " xor ";
      $v = $v . " mux" ;
    }
    elsif($_ =~ m/^\(\!\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s*\)/){
      #print " nand ";
      $v = $v . " nand" ;
    }
    elsif($_ =~ m/^\(\!\s*\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s+$identifier\s*\)\s*\)/){
      #print " nand ";
      $v = $v . " nand" ;
    }

##-----------------------------------------------------------------------------------------##

    elsif($_ =~ m/^\(\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*\(\s*$identifier\s*\^\s*$identifier\s*\^\s*$identifier\s*\'\s*\)\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s*\(\s*$identifier\s*\^\s*$identifier\s*\^ \s*$identifier\s*\'\s*\)\s*\)\s*\)/){
      #print " sum of full adder";
      $v = $v . " sum of full adder" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s*$identifier\s*\'\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s*$identifier\s*\)\s*\)/){
    #elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s*$identifier\s*\'\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s*$identifier\s*\)\s*\)/){}
      #print " carry of full adder";
      $v = $v . " carry of full adder" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*\(\s*$identifier\s*\^\s*$identifier\s*\^\s*$identifier\s*\)\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s*\(\s*$identifier\s*\^\s*$identifier\s*\^\s*$identifier\s*\)\s*\)\s*\)/){
      #print " sum of full adder";
      $v = $v . " sum of full adder" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s*$identifier\s*\)\s*\)/){
      #print " carry of full adder";
      $v = $v . " carry of full adder" ;
    }
    elsif($_ =~ m/^\(\s*$identifier\s*\^\s*$identifier\s*\'\s*\)/){
      #print " sum of half adder";
      $v = $v . " sum of half adder" ;
    }
    elsif($_ =~ m/^\(\s*$identifier\s*$identifier\s*\'\s*\)/){
      #print " carry of half adder";
      $v = $v . " carry of half adder" ;
    }
    elsif($_ =~ m/^I$/){
      #print " buffer";
      $v = $v . " buf" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*$identifier\s*\)/){
      #print " inverter";
      $v = $v . " inv" ;
    }
    elsif($_ =~ m/^\(\s*$identifier\s*\^\s*$identifier\s*\^\s*$identifier\s*\'\s*\)/){
      #print " sum of full adder";
      $v = $v . " sum of full adder" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\($identifier\s*\^\s*$identifier\s*\)\s*$identifier\s*\'\s*\)\s*((\|)|(\+))\s*\($identifier $identifier\s*\)\s*\)/){
      #print " carry of full adder";
      $v = $v . " carry of full adder" ;
    }
    elsif($_ =~ m/^\!\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)/){
      #print " and or invert";
      $v = $v . " aoi" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
      #print " and or invert";
      $v = $v . " aoi" ;
    }
    elsif($_ =~ m/^\!\s*\(\s*$identifier\s*((\|)|(\+))\s*\(\s*$identifier\s+$identifier\s*\)\s*\)/){
      #print " and or invert";
      $v = $v . " aoi" ;
    }
    elsif($_ =~ m/^\(\!\s*\(\s*$identifier\s*((\|)|(\+))\s*\(\s*$identifier\s+$identifier\s*\)\s*\)\s*\)/){
      #print " and or invert";
      $v = $v . " aoi" ;
    }

##-------------------------------------------------------------------------------------------------------------------------------------##

    elsif($_ =~ m/^\!\s*\(\s*\(\s*$identifier\s+$identifier\s+$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)$/){
      #print " and or invert";
      $v = $v . " aoi" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)$/){
      #print " and or invert";
      $v = $v . " aoi" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)$/){
      #print " and or invert";
      $v = $v . " aoi" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s+$identifier\s*\)\s*\)\s*\)$/){
      #print " and or invert";
      $v = $v . " aoi" ;
    }
    elsif($_ =~ m/^\!\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s*((((\|)|(\+)))|(\+))\s*\(\s*$identifier\s+$identifier\s*\)\s*\)$/){
      #print " and or invert";
      $v = $v . " aoi" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s+$identifier\s*\)\s*\)\s*\)$/){
      #print " and or invert";
      $v = $v . " aoi" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))\(\s*$identifier\s+$identifier\s*\)\s*\)((\|)|(\+))$identifier\s*\)\s*\)$/){
      #print " and or invert";
      $v = $v . " aoi" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))\(\s*$identifier\s+$identifier\s*\)\s*\)((\|)|(\+))\(\s*$identifier\s+$identifier\s*\)\s*\)\s*\)$/){
      #print " and or invert";
      $v = $v . " aoi" ;
    }

     elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s*\)\s*\)/){
      #print " and or invert";
      $v = $v . " oai" ;
    }
     elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s*\)\s*\)/){
      #print " and or invert";
      $v = $v . " oai" ;
    }
     elsif($_ =~ m/^\(\s*\(\s*\!\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s+$identifier\s*\)\s*\)/){
      #print " and or invert";
      $v = $v . " oai" ;
    }
     elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))$identifier\s*\)\s*\)\s*/){
      #print " and or invert";
      $v = $v . " oai" ;
    }
     elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
      #print " and or invert";
      $v = $v . " oai" ;
    }
     elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\)\s+$identifier\s*\)\s*\)/){
      #print " and or invert";
      $v = $v . " oai" ;
    }
     elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
      #print " and or invert";
      $v = $v . " oai" ;
    }

#    elsif($_ =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s*\)/){
#      #print " and or invert";
#      $v = $v . " 4oai" ;
#    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s*\)\s+$identifier\s*\)\s*\)/){
      #print " and or invert";
      $v = $v . " oai" ;
    }
#    elsif($_ =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 4oai" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 4oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 4oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s*\)/){
#      #print " and or invert";
#      $v = $v . " 4oai" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 4oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 4oai" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 4oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*$identifier\s+$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 4oai" ;
#    }
#    elsif($_ =~ m/^\s\(\s*\!\s*\(\s*$identifier\s+$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 4oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s*\)/){
#      #print " and or invert";
#      $v = $v . " 4oai" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 4oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s*\)/){
#      #print " and or invert";
#      $v = $v . " 4oai" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 4oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\)\s+$identifier\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\)\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\)\s+$identifier\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\)\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\(\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*$identifier\s+$identifier\s+$identifier\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*$identifier\s+$identifier\s+$identifier\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*$identifier\s+$identifier\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s+\)\s+$identifier\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*$identifier\s+$identifier\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s+\)\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s+$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " 5oai" ;
#    }
#




##-------------------------------------------------------------------------------------------------------------------------------------##

#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " aoi" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier $identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " aoi" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier $identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier $identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " aoi" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier $identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier $identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier $identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " aoi" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier $identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier $identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " aoi" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\!\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " aoi" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\!\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*((\|)|(\+))\s*\(\s*$identifier $identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " aoi" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier $identifier $identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " aoi" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier $identifier $identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier $identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " aoi" ;
#    }
#    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*$identifier\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s*$identifier\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $v = $v . " aoi" ;
#    }
    elsif($_ =~ m/^\(\s*$identifier\s*\^\s*$identifier\s*\^\s*$identifier\s*\)/){
      #print " sum of full adder";
      $v = $v . " sum of full adder" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier $identifier\s*\)\s*\)/){
      #print " carry of full adder";
      $v = $v . " carry of full adder" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s*\)/){
      #print " xnor ";
      $v = $v . " xnor" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*$identifier\s*\^\s*$identifier\s*\^\s*$identifier\s*\)\s*\)/){
      #print " xnor ";
      $v = $v . " xnor" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s*\^\s*$identifier\s*\)\s*\)/){
      #print " xnor ";
      $v = $v . " xnor" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s*\^\s*$identifier\s*\)\s*\^\s*$identifier\s*\)\s*\)/){
      #print " xnor ";
      $v = $v . " xnor" ;
    }
    elsif($flopfound == 1){  
      if (( index($v, " flop") < 0 ) && ( index($v, " latch") < 0 )) {
        $v = $v . " flop" ;
      }
      $flopfound = 0 ;
    }
    elsif($latchfound == 1){  
      if (( index($v, " flop") < 0 ) && ( index($v, " latch") < 0 )) {
        $v = $v . " latch" ;
      }
      $latchfound = 0 ;
    }
    elsif($_ =~ m/^IQ$/){
      #print " flip flop";
      #if ( index($v, " flop") < 0 ) {}
      if (( index($v, " flop") < 0 ) && ( index($v, " latch") < 0 )) {
        $v = $v . " flop" ;
      }
    }
    elsif($_ =~ m/^IQN$/){
      #print " flip flop";
      #if ( index($v, " flop") < 0 ) {}
      if (( index($v, " flop") < 0 ) && ( index($v, " latch") < 0 )) {
      $v = $v . " flop" ;
      }
    }
    elsif($_ =~ m/^\(\s*\(\s*$identifier\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*$identifier\s*\)\s*\)/){
      #print " two input mux";
      $v = $v . " mux" ;
    }
    elsif($_ =~ m/^\(\s*\(\s*$identifier\s*\(\s*\(\s*$identifier $identifier\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*$identifier\s*\)\s*\)\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*\(\s*\(\s*$identifier\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*$identifier\s*\)\s*\)\s*\)\s*\)/){
      #print " four input mux";
      $v = $v . " mux" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*$identifier\s*\)\s*\)\s*\)/){
      #print " two input inverted mux";
      $v = $v . " mux" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*\(\s*\(\s*$identifier\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*$identifier\s*\)\s*\)\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*\(\s*\(\s*$identifier\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*$identifier\s*\)\s*\)\s*\)\s*\)\s*\)/){
      #print " four input inverted mux";
      $v = $v . " mux" ;
    }
    elsif($_ =~ m/^\(\!\s*\(\s*$identifier\'?\s*$identifier\s*\)\s*\)/){
      #print " nand ";
      $v = $v . " nand" ;
    }
    elsif($_ =~ m/^\(\!\s*\(\s*$identifier\'? $identifier $identifier\)\)/){
      #print " nand ";
      $v = $v . " nand" ;
    }
    elsif($_ =~ m/^\(\!\s*\(\s*$identifier\'?\s*$identifier\'?\s*$identifier\s*$identifier\s*\)\s*\)/){
      #print " nand ";
      $v = $v . " nand" ;
    }
    elsif($_ =~ m/^\!\s*\(\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\'?\s*\)/){
      #print " nor ";
      $v = $v . " nor" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
      #print " nor ";
      $v = $v . " nor" ;
    }
    elsif($_ =~ m/^\!\s*\(\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\)/){
      #print " nor ";
      $v = $v . " nor" ;
    }
    elsif($_ =~ m/^\!\s*\(\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\)/){
      #print " nor ";
      $v = $v . " nor" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\'?\s*\)\)/){
      #print " nor ";
      $v = $v . " nor" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\)\)/){
      #print " nor ";
      $v = $v . " nor" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\)\)/){
      #print " nor ";
      $v = $v . " nor" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*((\|)|(\+))\s*$identifier\)\)/){
      #print " nor ";
      $v = $v . " nor" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*$identifier\s*$identifier\s*\)\s*\)/){
      #print " or and invert ";
      $v = $v . " oai" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*$identifier\s*\)\s*\)/){
      #print " 5 input or and invert ";\s*
      $v = $v . " oai" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
      #print " 6 input or and invert ";
      $v = $v . " oai" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\!\s*\(\s*$identifier\s*$identifier\s*\)\s*\)\s*$identifier\s*\)\s*\)/){
      #print " 3 input or and invert ";
      $v = $v . " oai" ;

    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
      #print " 4 input or and invert ";
      $v = $v . " oai" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*\!\s*\(\s*$identifier\s*$identifier\s*\)\s*\)\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
      #print " 4 input or and invert ";
      $v = $v . " oai" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*$identifier\s*\)\s*\)/){
      #print " 4 input or and invert";
      $v = $v . " oai" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
      #print " 5 input or and invert ";
      $v = $v . " oai" ;
    }
    elsif($_ =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
      #print " 6 input or and invert ";
      $v = $v . " oai" ;
    }
    elsif($_ =~ m/^\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)/){
      #print " 2 input or";
      $v = $v . " or" ;
    }
    elsif($_ =~ m/\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)/){
      #print " 3 input or";
      $v = $v . " or" ;
    }
    elsif($_ =~ m/^\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)/){
      #print " 4 input or";
      $v = $v . " or" ;
    }
    elsif($_ =~ m/^1$/){
      #print " tie 1";
      $v = $v . " tie 1" ;
    }
    elsif($_ =~ m/^0$/){
      #print " tie 0";
      $v = $v . " tie 0" ;
    } 

    else {
      $v = $v . " complex" ;
    } 
  }
  }
  if($v) {
    if($isFunctionFound == 1){
      push (@file_array0, $v);
    } else {
      $v = $v . " und" ;
      push (@file_array0, $v);
    }
    $isFunctionFound = 0;
  }
close(READ);
return(@file_array0);
}


sub function_name1 {
my $file = $_[0];
my @file_array1 = ();
my $X ;
my @file_array2 = &function_name($file);
#print "shobhit printing start\n" ; 
#print join  ("\n", @file_array2) ;
#print "\nshobhit printing end\n" ; 
  foreach (@file_array2) {
    if($_ =~ /^$/ || $_ =~ /^#/) {next;}
    chomp();
    if ( index($_, " flop") >= 0 ) {
        ($macroName, $funcName) = (split(/\-/, $_))[0,1];
        $X =  $macroName . "  - " . "flop";
    }
    elsif ( index($_, " latch") >= 0 ) {
        ($macroName, $funcName) = (split(/\-/, $_))[0,1];
        $X =  $macroName . "  - " . "latch";
    }
    elsif ( index($_, " complex") >= 0 ) {
        ($macroName, $funcName) = (split(/\-/, $_))[0,1];
        $X =  $macroName . "  - " . "complex";
    }
    elsif($_ =~ s/\s+sum of full adder carry of full adder carry of full adder/ full add/) {
      #print "  $_ \n";
      $X =  $_ ;
    }
    elsif($_ =~ s/\s+sum of full adder carry of full adder/ full add/){
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*xor\s+nand\s*/ half add/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s+sum of half adder carry of half adder/ half add/) {
      #print" $_\n";
      $X =  $_;
    }
    #elsif($_ =~ s/\s*sum of full adder/ full add/) {
    #  #print" $_\n";
    #  $X =  $_;
    #}
    #elsif($_ =~ s/\s*sum of full adder\s*/ xor/) {
    #  #print" $_\n";
    #  $X =  $_;
    #}
    elsif($_ =~ s/\s+xor and/ half add/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*andor\s+xor\s*/ half add/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*and\s+xor\s*/ half add/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s+carry of full adder$/ complex/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*sum of full adder\s*/ xor/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s+flop flop/ flop/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*complex\s+oai\s+xnor\s*/ complex/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*complex\s+oai\s+xnor\s*/ complex/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*complex\s+andor\s+complex\s*/ complex/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*complex\s+andor\s+complex\s*/ complex/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*complex\s+complex\s+complex\s*/ complex/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*aoi\s+aoi\s+complex\s*/ complex/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*complex\s+xnor\s*/ complex/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*aoi\s+xor\s*/ complex/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*nand\s+nor\s+xor\s*/ complex/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*nand\s+xor\s*/ complex/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*complex\s+complex\s*/ complex/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*nand\s+complex\s*/ complex/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*flop\s+flop\s+flop\s*/ flop/) {
      #print" $_\n";
      $X =  $_;
    }
    elsif($_ =~ s/\s*flop\s+flop\s+flop\s*/ flop/) {
      #print" $_\n";
      $X =  $_;
    }
    #elsif($_ =~ m/^cell\s*\(\w+\)\s*\-\s*$/) {
    #  #print" $_ COMPLEX\n";
    #  $X = $_ . " complex";
    #}
    else {
      #print "  $_ \n";
      $X =  $_;
    }

    if($X) {
      push (@file_array1, $X);
    }
  }#foreach
return(@file_array1);
}

sub function_name2 {
my $file1 = $_[0];
my @file_array1 = &function_name1($file1);
  my $macroName;
  my $funcName;
  foreach (@file_array1) {
    if($_ =~ /^$/ || $_ =~ /^#/) {next;}
    chomp();
    if($_ =~ m/^\s*cell/){
      s/\s*cell//;
      s/\(//;
      s/\)\s*//;
      s/\s*//g;
      ($macroName, $funcName) = (split(/\-/, $_))[0,1];
      #print "Cell name is $macroName, and function name is $funcName\n";
      if (exists $PLDB{$macroName} ) {
        $PLDB{$macroName}->dbMdbSetFunction($funcName);
        if ($funcName eq "flop" || $funcName eq "latch"){
          $PLDB{$macroName}->dbMdbSetType("seq");
        }
      }
    }
  }
}




sub write_lib_old {
#****f* /write_lib 
# NAME
#   write_lib  
# FUNCTION
#        write_lib command write a .lib model of a cell from its LEF model. The main purpose of this command is to create a approximate liberty model of the given LEF macro. it contains pin information, direction, capacitance and load attributes. It does not contain the header, so the output needs to be added in an existing libert file with the header.
#    
# SYNOPSIS
# 
# INPUTS
#      options :
#              -outlib < specify the filename in which the lib for macro would be writen>
#              -cellList {macro1,macro2}   a comma separated list of macronames for which lib has to written
#      switches :
#      
#      	-
# OUTPUTS
# 
#****

$noOfArguments = @_;
if($noOfArguments < 3 || $_[0] eq '-h') {
print "usage : write_lib --fromlef \n";
print "                  -outlib < Output file> \n";
print "                  -cellList < {tcl list of macroes} >\n";
print "                  -delay_info_file <delay file>\n";
print "                  -listFile < list of macros in a file one macroname per line >\n";
print "                  -power_ground < false / true >\n";
                       } else {
######## defaults #####################
$outputPGPins = "false";

for(my $i = 0 ; $i < $noOfArguments ;  $i++){
if($_[$i] eq "-outlib"){  $OUTPUT_LIB = $_[$i+1];}
if($_[$i] eq "-cellList"){  $INPUT_CELLLIST = $_[$i+1];}
if($_[$i] eq "-delay_info_file"){  $DELAY_FILE = $_[$i+1]; 
                                   read_delay_file ($DELAY_FILE);
                                }
if($_[$i] eq "-listFile"){  $INPUT_LISTFILE = $_[$i+1];}
if($_[$i] eq "-power_ground"){  $outputPGPins = $_[$i+1];}
                              }# for no of arguments

open(READ_CELLLIST, "$INPUT_LISTFILE");
while(<READ_CELLLIST>){
  chomp;
  push(@cellList,$_)
}#while
close(READ_CELLLIST);

if($INPUT_CELLLIST ne ""){
   $INPUT_CELLLIST =~ s/{//;
   $INPUT_CELLLIST =~ s/}//;
   my @list = split(/\,/, $INPUT_CELLLIST );
   foreach $cell ( @list ){push(@cellList,$cell);}
}

if($#cellList < 0){
   @cellList = keys %PLDB;
}

open (WRITE,">$OUTPUT_LIB");
print "INFO-PAR-LIB : 001 : Writing lib file $OUTPUT_LIB \n";
print WRITE "\/\* #LIB written from proton verion-$TOOL_VERSION \*\/\n";
print WRITE "\n\n";

print WRITE "library\(typical\) \{\n";
foreach $macroName (@cellList){
  chomp($macroName);
  if(exists $TLDB{$macroName}) {
  }else {
     $TLDB{$macroName} = TimingLibDB::new(); 
  }
  write_header($macroName);
}

foreach $macroName (@cellList){
chomp($macroName);
print "INFO-PAR-LIB : 002 :\tprocessed cell $macroName\n";
write_lib_cell($macroName);
                  }
@cellList = ();
print WRITE "\}\n";
close(WRITE);


                            }#if correct argumnets

}#sub write_lib_old





sub write_lib_cell {

my $CAPACITANCE = 0.005;
my $macroName = $_[0]; 
my $pinType;
my $pinDir;

my %BUSSES = ();
if(exists $PLDB{$macroName}) {
   print WRITE "cell\($macroName\) \{\n";
   my $area = 0;
   my $pinarea = 0;
   my @temp = $PLDB{$macroName}->dbMdbGetSize;
   my $area = $temp[0]*$temp[1];
   print WRITE "\tarea \: $area\;\n";
   print WRITE "\tdont_use \t\t\: TRUE\;\n";
   print WRITE "\tdont_touch \t\t\: TRUE\;\n";
   print WRITE "\tinterface_timing \t\: TRUE\;\n";
   my @pins = $PLDB{$macroName}->dbMdbGetPins;
   foreach my $pinName(@pins){
      if(defined ($TLDB{$macroName}->dbTimingLibGetPinType($pinName))){
         $pinType = $TLDB{$macroName}->dbTimingLibGetPinType($pinName);
      }else{
      	$pinType = $PLDB{$macroName}->dbMdbGetPinType($pinName);
        $TLDB{$macroName}->dbTimingLibSetPinType($pinName,$pinType);
      }

      if(defined ($TLDB{$macroName}->dbTimingLibGetPinDir($pinName))){
         $pinDir = $TLDB{$macroName}->dbTimingLibGetPinDir($pinName);
      }else{
         $pinDir = $PLDB{$macroName}->dbMdbGetPinDir($pinName);
      	 $TLDB{$macroName}->dbTimingLibSetPinDir($pinName,$pinDir);
      }

      if(defined ($TLDB{$macroName}->dbTimingLibGetPinCap($pinName))){
         $CAPACITANCE = $TLDB{$macroName}->dbTimingLibGetPinCap($pinName);
      }else{
         my @rects = $PLDB{$macroName}->dbMdbGetPinRect($pinName);
         $pinarea = 0 ;
         foreach my $l (@rects) {
           $l =~ s/ RECT//;
           my @L  = split(/\s+/,$l);
           my ($llx,$lly,$urx,$ury)=($L[1],$L[2],$L[3],$L[4]);
           $pinarea += abs(($urx-$llx)*($ury-$lly));
           # print "$llx,$lly,$urx,$ury Pin area $pinarea \n";
           $layerName = $L[0];
         }
         $layerCapacitance = ${$layerName}{'CAPACITANCE'};
         $CAPACITANCE = $pinarea * $layerCapacitance ; 
         $TLDB{$macroName}->dbTimingLibSetPinCap($pinName,$pinCap);
      }
            
      if(($pinDir eq "input") || ($pinDir eq "output") || ($pinDir eq "inout")){ $DIR = $pinDir; }
      elsif($pinDir == 0 ){ $DIR = "input"; }
      elsif($pinDir == 1 ){ $DIR = "output"; }
      else {$DIR = "inout"; }
      my $busWidth = $PLDB{$macroName}->dbMdbGetPinBusWidth($pinName);
      print "INFO-PAR-LIB : 001 : $pinName : $pinType : $pinDir : $busWidth \n";
      if($busWidth == 0){
         if($pinType == 1 || $pinType == 2){ 
            if($outputPGPins eq "true" ) {
               #$pinName =~ s/\\\[/\[/g;
               #$pinName =~ s/\\\]/\]/g;
               print WRITE "\tpin\($pinName\) \{\n";
               print WRITE "\t\tdirection \: $DIR\;\n";
               print WRITE "\t\tcapacitance \: $CAPACITANCE\;\n";
               if(($TLDB{$macroName}->dbTimingLibGetPinTiming($pinName)) eq 'true'){}
               else {
                   print WRITE "\t\}\n";
               }
            }
         }else {
            $pinName =~ s/\\\[/\[/g;
            $pinName =~ s/\\\]/\]/g;
            print WRITE "\tpin\($pinName\) \{\n";
            print WRITE "\t\tdirection \: $DIR\;\n";
            print WRITE "\t\tcapacitance \: $CAPACITANCE\;\n";
            if(($TLDB{$macroName}->dbTimingLibGetPinTiming($pinName)) eq 'true'){}
            else {
              print WRITE "\t\}\n";
            }
        }#pwr / gnd pin
      }elsif($busWidth == 1){ 
        my $busBit = $PLDB{$macroName}->dbMdbGetPinBusBit($pinName);
        my $busBase = $PLDB{$macroName}->dbMdbGetPinBusBaseName($pinName);
        push(@{$BUSSES{$busBase}},$busBit);
      }# if bus

      #####################################################
      #Add timing part to lib
      #####################################################
      if(($TLDB{$macroName}->dbTimingLibGetPinTiming($pinName)) eq 'true'){
          my $relatedPin = $TLDB{$macroName}->dbTimingLibGetPinRPin($pinName);	
          my @timing_type = $TLDB{$macroName}->dbTimingLibGetPinTimingType($pinName);
          my $delay_timing = 1;
          #print "Timing type is @timing_type \n";
          if(@timing_type) { 
             #print "Timing type exists\n";
             foreach (@timing_type) {
               if($_ =~ /setup/) {	
               	  print WRITE "\t\ttiming\(\) \{\n";
               	  print WRITE "\t\t\trelated_pin : $relatedPin \;\n";	
               	  print WRITE "\t\t\ttiming_type : $_ \;\n";
               	  ######rise constraint timing#########
               	  my ($riseConstraintindex_name,@riseConstraintindex) = $TLDB{$macroName}->dbTimingLibGetPinSetupConsIndex($pinName,$relatedPin,$cond,riseConstraint);
               	  my(@riseConstraint)=$TLDB{$macroName}->dbTimingLibGetPinSetupCons($pinName,$relatedPin,$cond,riseConstraint);

               	  print WRITE "\t\t\trise_constraint($riseConstraintindex_name) {\n";
               	  my $index1 = join (", " , split(/\s+/,$riseConstraintindex[0]));
               	  my $index2 = join (", " , split(/\s+/,$riseConstraintindex[1]));
               	  print WRITE "\t\t\t\tindex_1 (\"$index1\")\;\n";
               	  print WRITE "\t\t\t\tindex_2 (\"$index2\")\;\n";
                  print WRITE "\t\t\tvalues ( \\ \n";
                  for(my $i = 0 ; $i < $#riseConstraint;$i++){
                      $riseConstraint[$i] = join(", " , split(/\s+/,$riseConstraint[$i]));
                      print WRITE "\t\t\t\t\"$riseConstraint[$i]\" , \\\n";
          	      $riseConstraint[$#riseConstraint] = join(", " , split(/\s+/,$riseConstraint[$#riseConstraint]));
                      print WRITE "\t\t\t\t\"$riseConstraint[$#riseConstraint]\" )\;\n";
          	      print WRITE "\t\t\t\}\n";
          	      #####fall constraint timing#########
          	      my ($fallConstraintindex_name,@fallConstraintindex) = $TLDB{$macroName}->dbTimingLibGetPinSetupConsIndex($pinName,$relatedPin,$cond,fallConstraint);
                      my(@fallConstraint)=$TLDB{$macroName}->dbTimingLibGetPinSetupCons($pinName,$relatedPin,$cond,fallConstraint);
                      print WRITE "\t\t\tfall_constraint($fallConstraintindex_name) {\n";
                      my $index1 = join (", " , split(/\s+/,$fallConstraintindex[0]));
                      my $index2 = join (", " , split(/\s+/,$fallConstraintindex[1]));
          	      print WRITE "\t\t\t\tindex_1 (\"$index1\")\;\n";
          	      print WRITE "\t\t\t\tindex_2 (\"$index2\")\;\n";
          
          	      print WRITE "\t\t\tvalues ( \\ \n";
          	      for(my $i = 0 ; $i < $#fallConstraint;$i++){
          	          $fallConstraint[$i] = join(", " , split(/\s+/,$fallConstraint[$i]));
          	          print WRITE "\t\t\t\t\"$fallConstraint[$i]\" , \\\n";
          	 
          	      }	
          	      $fallConstraint[$#fallConstraint] = join(", " , split(/\s+/,$fallConstraint[$#fallConstraint]));
          	      print WRITE "\t\t\t\t\"$fallConstraint[$#fallConstraint]\" )\;\n";
          	      print WRITE "\t\t\t\}\n";
          	      print WRITE "\t\t\}\n";

          	      $delay_timing = 0;	
                  }
               }elsif ($_ =~ /hold/) {	
                  print WRITE "\t\ttiming\(\) \{\n";
          	  print WRITE "\t\t\trelated_pin : $relatedPin \;\n";	
          	  print WRITE "\t\t\ttiming_type : $_ \;\n";
          	  ######rise constraint timing#########
          	  my ($riseConstraintindex_name,@riseConstraintindex) = $TLDB{$macroName}->dbTimingLibGetPinHoldConsIndex($pinName,$relatedPin,$cond,riseConstraint);
          	  my(@riseConstraint)=$TLDB{$macroName}->dbTimingLibGetPinHoldCons($pinName,$relatedPin,$cond,riseConstraint);

          	  print WRITE "\t\t\trise_constraint($riseConstraintindex_name) {\n";
          	  my $index1 = join (", " , split(/\s+/,$riseConstraintindex[0]));
          	  my $index2 = join (", " , split(/\s+/,$riseConstraintindex[1]));
          	  print WRITE "\t\t\t\tindex_1 (\"$index1\")\;\n";
          	  print WRITE "\t\t\t\tindex_2 (\"$index2\")\;\n";
          
          	  print WRITE "\t\t\tvalues ( \\ \n";
          	  for(my $i = 0 ; $i < $#riseConstraint;$i++){
          	      $riseConstraint[$i] = join(", " , split(/\s+/,$riseConstraint[$i]));
          	      print WRITE "\t\t\t\t\"$riseConstraint[$i]\" , \\\n";
          	  }	
          	  $riseConstraint[$#riseConstraint] = join(", " , split(/\s+/,$riseConstraint[$#riseConstraint]));
          	  print WRITE "\t\t\t\t\"$riseConstraint[$#riseConstraint]\" )\;\n";
          	  print WRITE "\t\t\t\}\n";

          	  ######fall constraint timing#########
          	  my ($fallConstraintindex_name,@fallConstraintindex) = $TLDB{$macroName}->dbTimingLibGetPinHoldConsIndex($pinName,$relatedPin,$cond,fallConstraint);
          	  my(@fallConstraint)=$TLDB{$macroName}->dbTimingLibGetPinHoldCons($pinName,$relatedPin,$cond,fallConstraint);

          	  print WRITE "\t\t\tfall_constraint($fallConstraintindex_name) {\n";
          	  my $index1 = join (", " , split(/\s+/,$fallConstraintindex[0]));
          	  my $index2 = join (", " , split(/\s+/,$fallConstraintindex[1]));
          	  print WRITE "\t\t\t\tindex_1 (\"$index1\")\;\n";
          	  print WRITE "\t\t\t\tindex_2 (\"$index2\")\;\n";
          
          	  print WRITE "\t\t\tvalues ( \\ \n";
          	  for(my $i = 0 ; $i < $#fallConstraint;$i++){
          	      $fallConstraint[$i] = join(", " , split(/\s+/,$fallConstraint[$i]));
          	      print WRITE "\t\t\t\t\"$fallConstraint[$i]\" , \\\n";
          	  }	
          	  $fallConstraint[$#fallConstraint] = join(", " , split(/\s+/,$fallConstraint[$#fallConstraint]));
          	  print WRITE "\t\t\t\t\"$fallConstraint[$#fallConstraint]\" )\;\n";
          	  print WRITE "\t\t\t\}\n";
          	  print WRITE "\t\t\}\n";

          	  $delay_timing = 0;	
               }elsif($_ =~ /rising/) { 
                  $tim_type = "rising_edge"; 
               }elsif($_ =~ /falling/){ 
                  $tim_type = "falling_edge" ;
               }else { 
                  $delay_timing = 1;
               }
             }#end foreach
          }else {
      	     #print "Timing type does not exist\n";
          }
      
          if($delay_timing == 1) {	
             print WRITE "\t\ttiming\(\) \{\n";
             print WRITE "\t\t\trelated_pin : $relatedPin \;\n";	
             if(defined ($tim_type)){
          	    print WRITE "\t\t\ttiming_type : $tim_type \;\n";	
          	 }		
             ######cell rise timing#########
             my ($riseDelayindex_name,@riseDelayindex) = $TLDB{$macroName}->dbTimingLibGetPinDelayIndex($pinName,$relatedPin,$cond,riseDelay);
             my(@riseDelay)=$TLDB{$macroName}->dbTimingLibGetPinDelay($pinName,$relatedPin,$cond,riseDelay);

             print WRITE "\t\t\tcell_rise($riseDelayindex_name) {\n";
             my $index1 = join (", " , split(/\s+/,$riseDelayindex[0]));
             my $index2 = join (", " , split(/\s+/,$riseDelayindex[1]));
             print WRITE "\t\t\t\tindex_1 (\"$index1\")\;\n";
             print WRITE "\t\t\t\tindex_2 (\"$index2\")\;\n";
             
             print WRITE "\t\t\tvalues ( \\ \n";
             for(my $i = 0 ; $i < $#riseDelay;$i++){
          	     $riseDelay[$i] = join(", " , split(/\s+/,$riseDelay[$i]));
          	     print WRITE "\t\t\t\t\"$riseDelay[$i]\" , \\\n";
             }
             $riseDelay[$#riseDelay] = join(", " , split(/\s+/,$riseDelay[$#riseDelay]));
             print WRITE "\t\t\t\t\"$riseDelay[$#riseDelay]\" )\;\n";
             print WRITE "\t\t\t\}\n";
             
             #######rise transition timing#########
             my ($riseTranindex_name,@riseTranindex) = $TLDB{$macroName}->dbTimingLibGetPinTranIndex($pinName,$relatedPin,$cond,riseTran);
             my(@riseTran)=$TLDB{$macroName}->dbTimingLibGetPinTran($pinName,$relatedPin,$cond,riseTran);

             print WRITE "\t\t\trise_transition($riseTranindex_name) {\n";
             my $index1 = join (", " , split(/\s+/,$riseTranindex[0]));
             my $index2 = join (", " , split(/\s+/,$riseTranindex[1]));
             print WRITE "\t\t\t\tindex_1 (\"$index1\")\;\n";
             print WRITE "\t\t\t\tindex_2 (\"$index2\")\;\n";
             
             print WRITE "\t\t\tvalues ( \\ \n";
             for(my $i = 0 ; $i < $#riseTran;$i++){
                 $riseTran[$i] = join(", " , split(/\s+/,$riseTran[$i])); 
                 print WRITE "\t\t\t\t\"$riseTran[$i]\" , \\\n";
             }
             $riseTran[$#riseTran] = join(", " , split(/\s+/,$riseTran[$#riseTran]));
             print WRITE "\t\t\t\t\"$riseTran[$#riseTran]\" )\;\n";
             print WRITE "\t\t\t\}\n";

             #######cell fall timing#########
             my ($fallDelayindex_name,@fallDelayindex) = $TLDB{$macroName}->dbTimingLibGetPinDelayIndex($pinName,$relatedPin,$cond,fallDelay);
             my(@fallDelay)=$TLDB{$macroName}->dbTimingLibGetPinDelay($pinName,$relatedPin,$cond,fallDelay);

             print WRITE "\t\t\tcell_fall($fallDelayindex_name) {\n";
             my $index1 = join (", " , split(/\s+/,$fallDelayindex[0]));
             my $index2 = join (", " , split(/\s+/,$fallDelayindex[1]));
             print WRITE "\t\t\t\tindex_1 (\"$index1\")\;\n";
             print WRITE "\t\t\t\tindex_2 (\"$index2\")\;\n";
             
             print WRITE "\t\t\tvalues ( \\ \n";
             for(my $i = 0 ; $i < $#fallDelay;$i++){
                 $fallDelay[$i] = join(", " , split(/\s+/,$fallDelay[$i]));
                 print WRITE "\t\t\t\t\"$fallDelay[$i]\" , \\\n";
             }
             $fallDelay[$#fallDelay] = join(", " , split(/\s+/,$fallDelay[$#fallDelay]));
             print WRITE "\t\t\t\t\"$fallDelay[$#fallDelay]\" )\;\n";
             print WRITE "\t\t\t\}\n";

             #######fall transition timing#########
             my ($fallTranindex_name,@fallTranindex) = $TLDB{$macroName}->dbTimingLibGetPinTranIndex($pinName,$relatedPin,$cond,fallTran);
             my(@fallTran)=$TLDB{$macroName}->dbTimingLibGetPinTran($pinName,$relatedPin,$cond,fallTran);

             print WRITE "\t\t\tfall_transition($fallTranindex_name) {\n";
             my $index1 = join (", " , split(/\s+/,$fallTranindex[0]));
             my $index2 = join (", " , split(/\s+/,$fallTranindex[1]));
             print WRITE "\t\t\t\tindex_1 (\"$index1\")\;\n";
             print WRITE "\t\t\t\tindex_2 (\"$index2\")\;\n";
             
             print WRITE "\t\t\tvalues ( \\ \n";
             for(my $i = 0 ; $i < $#fallTran;$i++){
                 $fallTran[$i] = join(", " , split(/\s+/,$fallTran[$i]));
                 print WRITE "\t\t\t\t\"$fallTran[$i]\" , \\\n";
             }
             $fallTran[$#fallTran] = join(", " , split(/\s+/,$fallTran[$#fallTran]));
             print WRITE "\t\t\t\t\"$fallTran[$#fallTran]\" )\;\n";
             print WRITE "\t\t\t\}\n";
             print WRITE "\t\t\}\n";
          }#if delay_timing == 1

	 ####end timing definition####
	 print WRITE "\t\}\n";
	}	
   }# foreach
   foreach(keys %BUSSES){
     my @bits = @{$BUSSES{$_}};
     my $len = @bits;
     my $busTypeName = $_._.$macroName._BUS;
     my @sorted_array = sort { $a <=> $b} @bits;
     my $bit = $sorted_array[0];
     my $busname = $_."[".$bit."]";
     print WRITE "\tbus\($_\) \{\n";
     print WRITE "\t\tbus_type \: $busTypeName\;\n";;
     my $dir = $PLDB{$macroName}->dbMdbGetPinDir($busname);
     if ($dir == 0 ) { print WRITE "\t\tdirection \: input\;\n"; }
     elsif ($dir == 1 ) { print WRITE "\t\tdirection \: output\;\n"; }
     elsif ($dir == 2 ) { print WRITE "\t\tdirection \: inout\;\n"; }
     else { print "WARN-PAR-LIB : 002 : unknown pin direction\n"; }

     print WRITE "\t\tcapacitance \: $CAPACITANCE\;\n";
     print WRITE "\t\}\n";
   } # foreach bus
   print WRITE "\}\n";
}#if macro exists
else {
  print "WARN-PAR-LIB : 003 : $macroName does not exist in the input lef files\n";
}#if macro does not exist
		
}#sub write_lib_cell

sub read_delay_file {
	my $delay_file = $_[0];
	my $START_CELL_PARSING = 0;
	my $START_CELL_TIMING = 0;
	my $START_TABLE_PARSING = 0;
	my @valueArray = ();
	my @IndexArray = ();
	my $nextValue = "";
	my $table_name = "";
	my $NEXT_DATA_LINE = 0;
    my %TABLE_HASH ; 
    my $debug = 1;

	open(DELAY_FILE, "$delay_file");
	print "INFO-PAR-LIB : 001 : Reading delay file $delay_file \n";
	while(<DELAY_FILE>){
		chomp;
		$_ =~ s/^\s+//; # removing any empty space in the begining of line

		if ($_ =~ /^\s*#/)  { print "DBG-PAR-LIB : 002 : Comment line\n" if ($debug); }#comment line, ignore 
	    
		if ($_ =~ /^\s*LOOKUP_TABLE\s*/){
			$START_TABLE_PARSING = 1;
		}        
		if ($_ =~ /^\s*END LOOKUP_TABLE\s*/){
			$START_TABLE_PARSING = 0;
		}        
	
		if (($START_TABLE_PARSING == 1) && ($_ !~ /LOOKUP/)) {
			if ($_ =~ /_template/) {
				$table_name = $_ ;
				$table_name =~ s/\s*//g;
			}
			elsif ($_ =~ /^\s*$/) {}
			else {
				$_ =~ s/index_1 \(\"//;
        		$_ =~ s/index_2 \(\"//;
        		$_ =~ s/\,//g;
        		$_ =~ s/\"\)\;//;
				
        		push(@{$TABLE_HASH{$table_name}}, $_); 
				print "DBG-PAR-LIB : 003 : Lookup Table  is $TABLE_HASH{$table_name} : @{$TABLE_HASH{$table_name}} \n" if ($debug);
			}
		}	
		else {
		if ($_ =~ /^\s*CELL\s*(\w*)/){
			$macroName = $1;
			print "DBG-PAR-LIB : 004 : macro : $macroName\n" if ($debug);
			$START_CELL_PARSING = 1;
			$NEXT_DATA_LINE = 0;
			$START_CELL_TIMING = 0;
			$nextValue = "";
         	$TLDB{$macroName} = TimingLibDB::new();
		}
		if ($_ =~ /^\s*END CELL\s*$/){
			$START_CELL_PARSING = 0;
			$NEXT_DATA_LINE = 0;
			$START_CELL_TIMING = 0;
			$nextValue = "";
		}
		if ($_ =~ /^\s*$/) { print "DBG-PAR-LIB : 005 : Empty line\n" if ($debug); } #empty line, ignore

		if ( $START_CELL_PARSING == 1 ) {
        
        if ($_ =~ /^PIN/  ) {
			@line = split (/\s+/,$_);
			print "DBG-PAR-LIB : 006 : Line is @line finish\n" if ($debug);	
			$pinName = $line[1];
			$pinDir = $line[2];
			$pinDir =~ s/\(//;
			$pinType = $line[3];
			$pinCap = $line[4];
			$pinCap =~ s/\)//;
			print "DBG-PAR-LIB : 007 : $pinName : $pinDir : $pinType : $pinCap \n" if ($debug);
			$TLDB{$macroName}->dbTimingLibSetPinDir($pinName,$pinDir);
			$TLDB{$macroName}->dbTimingLibSetPinCap($pinName,$pinCap);
			$TLDB{$macroName}->dbTimingLibSetPinType($pinName,$pinType);
		}
		elsif ($_ =~ /^\s*BEGIN TIMING\s*/) {
			$START_CELL_TIMING = 1;
			$TLDB{$macroName}->dbTimingLibSetPinTiming($pinName,true);
		}
		elsif ($_ =~ /^\s*END TIMING\s*/) {
			$START_CELL_TIMING = 0;
		}
		
		if ( $START_CELL_TIMING == 1 ) {
		#print "Inside timing loop\n";
			if ($_ =~ /related_pin/) {
				$relatedPin = (split(/\s+/, $_))[1];
				$TLDB{$macroName}->dbTimingLibSetPinRPin($pinName,$relatedPin);
				print "DBG-PAR-LIB : 008 : Related pin is : $relatedPin\n" if ($debug);
			}
			if (($_ =~ /(setup|hold)_(rising|falling) (rise_constraint)/)|($_ =~ /(rising|falling) (cell_rise)/)) {
				$timing_type = (split(/\s+/, $_))[0];
				$TLDB{$macroName}->dbTimingLibSetPinTimingType($pinName,$timing_type);
				print "DBG-PAR-LIB : 009 : Timing type is : $timing_type\n" if ($debug);
			}
			if($_ =~ /rise_constraint\((\w*)\)/ ) { 
				$index = $1 ; 
				$nextValue = "riseConstraint"; @valueArray = (); @indexArray = @{$TABLE_HASH{$1}}; 
				print "DBG-PAR-LIB : 010 : $nextValue $1 : @indexArray : @{$TABLE_HASH{$1}} \n" if ($debug) ;
			}
			if($_ =~ /fall_constraint\((\w*)\)/ ) { 
				$index = $1 ; 
				$nextValue = "fallConstraint"; @valueArray = (); @indexArray = @{$TABLE_HASH{$1}}; 
				print "DBG-PAR-LIB : 011 : $nextValue $1 : @indexArray : @{$TABLE_HASH{$1}} \n" if ($debug) ;
			}
			if($_ =~ /cell_rise\((\w*)\)/ ) { 
				$index = $1 ; 
				$nextValue = "riseDelay"; @valueArray = (); @indexArray = @{$TABLE_HASH{$1}}; 
				print "DBG-PAR-LIB : 012 : $nextValue $1 : @indexArray : @{$TABLE_HASH{$1}} \n" if ($debug) ;
			}
			if($_ =~ /cell_fall\((\w*)\)/ ) {
				$index = $1; 
				$nextValue = "fallDelay";  @valueArray = (); @indexArray = @{$TABLE_HASH{$1}} ; 
				print "DBG-PAR-LIB : 013 : $nextValue $1 : @indexArray : @{$TABLE_HASH{$1}} \n" if ($debug) ;
			}
			if($_ =~ /rise_transition\((\w*)\)/ ) { 
				$index = $1; 
				$nextValue = "riseTran";  @valueArray = (); @indexArray = @{$TABLE_HASH{$1}} ; 
				print "DBG-PAR-LIB : 014 : $nextValue $1 : @indexArray : @{$TABLE_HASH{$1}} \n" if ($debug) ;
			}
			if($_ =~ /fall_transition\((\w*)\)/ ) { 
				$index = $1; 
				$nextValue = "fallTran";  @valueArray = (); @indexArray = @{$TABLE_HASH{$1}} ; 
				print "DBG-PAR-LIB : 015 : $nextValue $index : @indexArray : @{$TABLE_HASH{$1}} \n" if ($debug) ;
			}
			if( $_ =~ /^values\s*\(/ ) {
				$_ =~ s/values\s*\(\s*\\//;
                $_ =~ s/\,//g;
                $_ =~ s/\"//;
                $_ =~ s/\\//;
                if ($_ !~ m/^\s*$/ ){ 
                	push(@valueArray, $_);
                }
				$NEXT_DATA_LINE = 1; 
			}
			
			if ( $NEXT_DATA_LINE == 1 ) {
				if ( $_ =~ /\)\;/ ) { 
               		$NEXT_DATA_LINE  = 0;
                    $_ =~ s/\"//g;
                    $_ =~ s/\\//g;
                    $_ =~ s/\,/ /g;
                    $_ =~ s/\)\;/ /g;
                    if ($_ !~ m/^\s*$/ ){ 
                      push(@valueArray, $_);
                    }
				if ( $nextValue eq "fallDelay" ) { 
                      print " DBG-PAR-LIB : 016 : $macroName $pinName $relatedPin $cond $nextValue \n" if ($debug) ;
                      foreach $entry  ( @valueArray ){ print "DBG-PAR-LIB : 017 : $entry \n" if ($debug) ; }
                      print "\n" if ($debug) ;
                      $TLDB{$macroName}->dbTimingLibSetPinDelay($pinName, $relatedPin, $cond, $nextValue, @valueArray);
                      $TLDB{$macroName}->dbTimingLibSetPinDelayIndex($pinName, $relatedPin, $cond, $nextValue, $index, @indexArray);
                }
                elsif ( $nextValue eq "riseDelay" ) {
                      print "DBG-PAR-LIB : 018 : $macroName $pinName $relatedPin HI $cond\n" if ($debug) ;
                      foreach $entry  ( @valueArray ){ print "DBG-PAR-LIB : 019 : $entry \n" if ($debug); }
                      print "\n" if ($debug) ;
                      $TLDB{$macroName}->dbTimingLibSetPinDelay($pinName, $relatedPin, $cond, $nextValue, @valueArray);
                      $TLDB{$macroName}->dbTimingLibSetPinDelayIndex($pinName, $relatedPin, $cond, $nextValue, $index, @indexArray);
                }
                elsif ( $nextValue eq "riseTran" ) {
                      print "DBG-PAR-LIB : 020 : $macroName $pinName $relatedPin $cond\n" if ($debug) ;
                      foreach $entry  ( @valueArray ){ print "DBG-PAR-LIB : 021 : $entry \n" if ($debug) ; }
                      print "\n" if ($debug) ;
                      $TLDB{$macroName}->dbTimingLibSetPinTran($pinName, $relatedPin, $cond, $nextValue, @valueArray);
                      $TLDB{$macroName}->dbTimingLibSetPinTranIndex($pinName, $relatedPin, $cond, $nextValue, $index, @indexArray);
                }
                elsif ( $nextValue eq "fallTran" ) {
                      print "DBG-PAR-LIB : 022 : $macroName $pinName $relatedPin $cond\n" if ($debug) ;
                      foreach $entry  ( @valueArray ){ print "DBG-PAR-LIB : 023 : $entry \n" if ($debug) ; }
                      print "\n" if ($debug) ;
                      $TLDB{$macroName}->dbTimingLibSetPinTran($pinName, $relatedPin, $cond, $nextValue, @valueArray);
                      $TLDB{$macroName}->dbTimingLibSetPinTranIndex($pinName, $relatedPin, $cond, $nextValue, $index, @indexArray);
                }
				elsif ( $nextValue eq "riseConstraint" ) {
                      print "DBG-PAR-LIB : 024 : $macroName $pinName $relatedPin $cond\n" if ($debug) ;
                      foreach $entry  ( @valueArray ){ print "DBG-PAR-LIB : 025 : $entry \n" if ($debug) ; }
                      print "\n" if ($debug) ;
					  if ($timing_type =~ /setup/) { 
                      $TLDB{$macroName}->dbTimingLibSetPinSetupCons($pinName, $relatedPin, $cond, $nextValue, @valueArray);
                      $TLDB{$macroName}->dbTimingLibSetPinSetupConsIndex($pinName, $relatedPin, $cond, $nextValue, $index, @indexArray);
					   } else {
						$TLDB{$macroName}->dbTimingLibSetPinHoldCons($pinName, $relatedPin, $cond, $nextValue, @valueArray);
                      $TLDB{$macroName}->dbTimingLibSetPinHoldConsIndex($pinName, $relatedPin, $cond, $nextValue, $index, @indexArray);
					   }
                }
				elsif ( $nextValue eq "fallConstraint" ) {
                      print "DBG-PAR-LIB : 026 : $macroName $pinName $relatedPin $cond\n" if ($debug) ;
                      foreach $entry  ( @valueArray ){ print "DBG-PAR-LIB : 027 : $entry \n" if ($debug) ; }
                      print "\n" if ($debug) ;
					  if ($timing_type =~ /setup/) { 
                      $TLDB{$macroName}->dbTimingLibSetPinSetupCons($pinName, $relatedPin, $cond, $nextValue, @valueArray);
                      $TLDB{$macroName}->dbTimingLibSetPinSetupConsIndex($pinName, $relatedPin, $cond, $nextValue, $index, @indexArray);
					   } else {
						$TLDB{$macroName}->dbTimingLibSetPinHoldCons($pinName, $relatedPin, $cond, $nextValue, @valueArray);
                      $TLDB{$macroName}->dbTimingLibSetPinHoldConsIndex($pinName, $relatedPin, $cond, $nextValue, $index, @indexArray);
					   }
                }

				
                }
				else { $NEXT_DATA_LINE = 1;
                	$_ =~ s/\"//g;
                    $_ =~ s/\\//g;
                    $_ =~ s/\,/ /g;
                    if ($_ !~ m/^\s*$/ ){ 
                    	push(@valueArray, $_);
                    }
                }
		}
		}#end if timing parsing

		}#end if cell parsing

	}#end else
	}#end while
	
print "INFO-PAR-LIB : 028 : End reading delay file $delay_file\n";
close (DELAY_FILE);
} #sub read_delay_file


sub write_header {

my $macroName = $_[0];
print "INFO-PAR-LIB : 001 : generating header for $macroName\n";

my %BUSSES =();
if(exists $PLDB{$macroName}) {
   my @allPins = $PLDB{$macroName}->dbMdbGetPins;
   foreach my $pinName ( @allPins ) {
     my $pinWidth = $PLDB{$macroName}->dbMdbGetPinBusWidth($pinName);
     if($pinWidth == 1 ) {
        my $busBit = $PLDB{$macroName}->dbMdbGetPinBusBit($pinName);
        my $busBase = $PLDB{$macroName}->dbMdbGetPinBusBaseName($pinName);
        print "INFO-PAR-LIB : 002 : $busBase $busBit\n";
        push(@{$BUSSES{$busBase}},$busBit);
     }#if bus
   }#foreach
   foreach (keys %BUSSES){
     my @bits = @{$BUSSES{$_}};
     my $len = @bits;
     my $busTypeName = $_._.$macroName._BUS;
     my @sorted_array = sort {$a <=> $b} @bits;
     my $bit = $sorted_array[0];
     my $width = $sorted_array[$len - 1] - $sorted_array[0] + 1;
     print WRITE "\ttype \($busTypeName\) \{\n";
     print WRITE "\t\tbase_type \: array \;\n";
     print WRITE "\t\tdata_type \: bit \;\n";
     print WRITE "\t\tbit_width \: $width \;\n";
     print WRITE "\t\tbit_from \: $sorted_array[$len - 1]\;\n";
     print WRITE "\t\tbit_to \: $sorted_array[0] \;\n";
#--------------------- fixed from down_to to downto bug-271 rajeevs ----------#
     print WRITE "\t\tdownto \: true \;\n";
     print WRITE "\t\}\n";
   }# foreach BUSSES
} # if exists
}# sub write_header




sub read_lib_old {
#****f* /read_lib_old 
# NAME
#   read_lib_old  
# FUNCTION
#   
#    
# SYNOPSIS
# 
# INPUTS
#      options :
#
#      switches :
#      
#      	-
# OUTPUTS
# 
#****

use Benchmark;
my $t0 = new Benchmark;

my $noOfArguments = @_;
 $INPUT_LIBRARY ="";
my $macroName ="";

if($noOfArguments < 2 || $_[0] eq '-h'){ print "Usage : read_lib_old -lib <dotlib_library>\n";
                        print "                 -tlf <tlf_library   > currently not supported\n";
                      }else{
for(my $x = 0; $x < $noOfArguments; $x++){
if($_[$x] =~ /-lib/){ $INPUT_LIBRARY = $_[$x+1];}
                                         }#for correct no of Arguments

#-----------------------------------------------------------------------------------------#
#&function_name($INPUT_LIBRARY);
#&function_name1;
&function_name2($INPUT_LIBRARY);
#-----------------------------------------------------------------------------------------#


open (READ_TIMING_LIBRARY, "$INPUT_LIBRARY");

print "INFO-PAR-LIB : 001 : Begin reading $INPUT_LIBRARY\n";
my $START_CELL_PARSING = 0;
my @valueArray = ();
my @IndexArray = ();
my $NEXT_DATA_LINE = 0;
my $nextValue = "";
my $index;

while(<READ_TIMING_LIBRARY>){
chomp();
$_ =~ s/^\s+//; # removing any empty space in the begining of line

if($_ =~ /^\s*cell\s*\(\w*\)/) { # if contains the cell line
         ($macroName)=(split(/\s*\(\s*|\s*\)\s*/, $_))[1]; 
        # print "macro : $macroName\n";
         $TLDB{$macroName} = TimingLibDB::new();
         $START_CELL_PARSING = 1;
         $NEXT_DATA_LINE = 0;
         $nextValue = "";
         $cond = "UNDEF";
         $START_CELL_TIMING = 0;
         $latchfound = 0;
         $flopfound = 0;   
         $data_in = 0;
         $next_state = 0;                   
                                  } # if contains the cell line

if ($_ =~ m/^\s*latch\s*\(/){
     $latchfound = 1;
  }
if ($_ =~ m/^\s*ff\s*\(/){
    $flopfound = 1;

}


if ( $START_CELL_PARSING == 1 ) {

if($_ =~ /^\s*pin\s*\(\w*\)/ ) {
         $pinName = (split(/\s*\(\s*|\s*\)\s*/, $_))[1];
        # print "pin : $pinName\n";
#print "Debug : $_\n";
                               }
elsif($_ =~ /^capacitance\s+\:/ ) { $pinCap = (split(/\s+\:\s+/, $_ ))[1];
                        #print "$macroName $pinName $pinCap\n";
                        $TLDB{$macroName}->dbTimingLibSetPinCap($pinName,$pinCap);
                                  }
elsif($_ =~ /^direction\s+\:/ ) { $pinDir = (split(/\s+\:\s+/, $_ ))[1];
                        $TLDB{$macroName}->dbTimingLibSetPinDir($pinName,$pinDir);
                                }
elsif($_ =~ /^function\s+\:/ ) { $pinFunc = (split(/\s+\:\s+/, $_ ))[1];
                               $TLDB{$macroName}->dbTimingLibSetPinFunc($pinName,$pinFunc);
                               } 
if ($latchfound == 1 || $flopfound == 1){
          if($_ =~(/^function\s+\:\s+IQ/) || (/^function\s+\:\s+"IQ"/)){
               if(exists $PLDB{$macroName} ){
               $PLDB{$macroName}->dbMdbSetPinIsRegOut1($pinName);
               }
              }
           }
       
elsif($_ =~ /^clock\s+\:/ ) { $pinType = 'clock';
                               $TLDB{$macroName}->dbTimingLibSetPinType($pinName,$pinType);
                               if( exists $PLDB{$macroName} ) {
                               $PLDB{$macroName}->dbMdbSetPinIsClock($pinName);
                                                              }
                               }
if ($latchfound == 1){
if ($_ =~ /^data_in/){
   $data_in = 1;
      }
    } 
if ($data_in == 1){ 
        if ($_ =~/^data_in\s+\:\s+/){
                 $data = (split(/\s+\:\s+/,$_))[1];
                 $data =~ s/"//;
                 $data =~ s/"//;
                 $data =~ s/;//;
                 if(exists $PLDB{$macroName}){
                 $PLDB{$macroName}->dbMdbSetPinIsRegIn1($data);
                                 }
                             }
                      }
if ($flopfound == 1){
if($_ =~ /^next_state/){
   $next_state = 1;
        }
      }
if ($next_state == 1){
         if ($_ =~/^next_state\s+\:\s+/){
                    $next = (split(/\s+\:\s+/,$_))[1];
                    $next =~ s/"//;
                    $next =~ s/"//;
                    $next =~ s/;//;              
                    if(exists $PLDB{$macroName}){
                    $PLDB{$macroName}->dbMdbSetPinIsRegIn1($next);
                                     }
                                 }
                        }

#############################################################################################
#   begin parsing the timing 								    #
#############################################################################################
if ( $_ =~ /timing\(\)/ ) { $START_CELL_TIMING = 1 ; }

if ( $START_CELL_TIMING == 1 ) {

if ( $NEXT_DATA_LINE == 1 ) {
                            if ( $_ =~ /\)\;/ ) { 
                                 $NEXT_DATA_LINE  = 0;
                                 $_ =~ s/\"//g;
                                 $_ =~ s/\\//g;
                                 $_ =~ s/\,/ /g;
                                 $_ =~ s/\)\;/ /g;
                                                           if ($_ !~ m/^\s*$/ ){ 
                                   push(@valueArray, $_);
                                 }
                                 #print "$_\n";
                                  if ( $nextValue eq "fallDelay" ) { 
                                       # print " $macroName $pinName $relatedPin $cond $nextValue \n";
                                       # foreach $entry  ( @valueArray ){ print "$entry \n"; }
                                       # print "\n";
                                        $TLDB{$macroName}->dbTimingLibSetPinDelay($pinName, $relatedPin, $cond, $nextValue, @valueArray);
                                        $TLDB{$macroName}->dbTimingLibSetPinDelayIndex($pinName, $relatedPin, $cond, $nextValue, $index, @indexArray);
                                                                   }
                                  elsif ( $nextValue eq "riseDelay" ) {
                                        #print "$macroName $pinName $relatedPin HI $cond\n";
                                        #foreach $entry  ( @valueArray ){ print "$entry \n"; }
                                        #print "\n";
                                        $TLDB{$macroName}->dbTimingLibSetPinDelay($pinName, $relatedPin, $cond, $nextValue, @valueArray);
                                        $TLDB{$macroName}->dbTimingLibSetPinDelayIndex($pinName, $relatedPin, $cond, $nextValue, $index, @indexArray);
                                                                      }
                                  elsif ( $nextValue eq "riseTran" ) {
                                        #print "$macroName $pinName $relatedPin $cond\n";
                                        #foreach $entry  ( @valueArray ){ print "$entry \n"; }
                                        #print "\n";
                                        $TLDB{$macroName}->dbTimingLibSetPinTran($pinName, $relatedPin, $cond, $nextValue, @valueArray);
                                        $TLDB{$macroName}->dbTimingLibSetPinTranIndex($pinName, $relatedPin, $cond, $nextValue,$index, @indexArray);
                                                                      }
                                  elsif ( $nextValue eq "fallTran" ) {
                                        #print "$macroName $pinName $relatedPin $cond\n";
                                        #foreach $entry  ( @valueArray ){ print "$entry \n"; }
                                        #print "\n";
                                        $TLDB{$macroName}->dbTimingLibSetPinTran($pinName, $relatedPin, $cond, $nextValue, @valueArray);
                                        $TLDB{$macroName}->dbTimingLibSetPinTranIndex($pinName, $relatedPin, $cond, $nextValue, $index,@indexArray);
                                                                      }
                                              }
                            else { $NEXT_DATA_LINE = 1;
                                 $_ =~ s/\"//g;
                                 $_ =~ s/\\//g;
                                 $_ =~ s/\,/ /g;
                                                           if ($_ !~ m/^\s*$/ ){ 
                                   push(@valueArray, $_);
                                 }
                                 #print "$_\n";
                                              }

                            } # if next line is data
# elsif($_ =~ /^\s*pin\s*\(\w*\)/ ) { 
#          $pinName = (split(/\s*\(\s*|\s*\)\s*/, $_))[1];
#          #print "pin : $pinName\n";
 #                               }
# elsif($_ =~ /^capacitance\s+\:/ ) { $pinCap = (split(/\s+\:\s+/, $_ ))[1];
#                         #print "$macroName $pinName $pinCap\n";
#                         $TLDB{$macroName}->dbTimingLibSetPinCap($pinName,$pinCap);
#                                   }
# elsif($_ =~ /^direction\s+\:/ ) { $pinDir = (split(/\s+\:\s+/, $_ ))[1];
#                         $TLDB{$macroName}->dbTimingLibSetPinDir($pinName,$pinDir);
#                                 }
# elsif($_ =~ /^function\s+\:/ ) { $pinFunc = (split(/\s+\:\s+/, $_ ))[1];
#            #                    $TLDB{$macroName}->dbTimingLibSetPinFunc($pinName,$pinFunc);
#                                }
if($_ =~ /^related_pin\s+\:/ ) { $relatedPin = (split(/\s+\:\s+/, $_ ))[1];
                          #print "\trelated : $relatedPin\n";
                                    $relatedPin =~ s/\"//g;
                                    $relatedPin =~ s/\s*\;\s*$//g ;
           #                    $TLDB{$macroName}->dbTimingLibSetPin2PinRdly($pinName,$relatedPin);
                               }

elsif($_ =~ /^when\s+\:/ ) { $cond = (split(/\s+\:\s+/, $_ ))[1]; 
                             $cond =~ s/\"//g;
                             $cond =~ s/\s+//g;
                             $cond =~ s/\;//g ;

####################################################################################

$TLDB{$macroName}->dbTimingLibSetPinCond($pinName,$relatedPin,$nextValue,$cond);


##################################################################

                             #if ( $cond =~ /\!/ ) { $cond =~ s/\!(\w+)/$1\:0/g ; print "$cond\n"; }
                           }# if condition
elsif($_ =~ /^cell_rise\((\w*)\)/ ) { $nextValue = "riseDelay"; @valueArray = (); @indexArray = (); $index = $1 ;}
elsif($_ =~ /^cell_fall\((\w*)\)/ ) { $nextValue = "fallDelay";  @valueArray = (); @indexArray = (); $index = $1 ;}
elsif($_ =~ /^rise_transition\((\w*)\)/ ) { $nextValue = "riseTran";  @valueArray = (); @indexArray = (); $index = $1 ;}
elsif($_ =~ /^fall_transition\((\w*)\)/ ) { $nextValue = "fallTran";  @valueArray = (); @indexArray = (); $index = $1 ;}
elsif( $_ =~ /^values\s*/ ) {
                            if ( $_ =~ /\)\;/ ) { 
                                 push(@valueArray, $_);
                                  if ( $nextValue eq "fallDelay" ) { 
                                                                   }
                                  elsif ( $nextValue eq "riseDelay" ) {
                                                                      }
                                                 }
                            else { 
                                 #print "\t\t$_\n";
                                 if ( $_ =~ /values\s*\(/ ) { 
                                 #if ( $_ =~ /values\s*\(\\*/ ) { 
                                                               #$_ =~ s/values\s*\(\s*\"//;
                                                               $_ =~ s/values\s*\(\s*\\*\"*\s*//;
                                                               $_ =~ s/\,//g;
                                                               $_ =~ s/\"//;
                                                               $_ =~ s/\\//;
                                                           if ($_ !~ m/^\s*$/ ){ 
                                                               push(@valueArray, $_);
                                                           }
                                                                    }
                                 $NEXT_DATA_LINE = 1; 
                                 }
                            }
elsif ( $_ =~ /^index/ ) {

        $_ =~ s/index_1 \(\"//;
        $_ =~ s/index_2 \(\"//;
        $_ =~ s/\,//g;
        $_ =~ s/\"\)\;//;
        # print "\t$_\n";
        push(@indexArray, $_); 
                         }


                               }# cell timing section
#############################################################################################
#   end parsing the timing 								    #
#############################################################################################

                               }# if parsing the cell section
else { next; }
                            }#while reading the timing library
print "INFO-PAR-LIB : 002 : End reading $INPUT_LIBRARY\n";

##foreach $macro ( keys %PLDB ) {
#                 if ( $macro eq "ADDFHX1" ) {
#		 print "$macro\n";
#                 if (exists $TLDB{$macro} ) {
#                        my @pins = $PLDB{$macro}->dbMdbGetPins;
#                        foreach $pinName ( @pins ) {
#                        print "$pinName\n";
#                        #my $pinType = $PLDB{$macro}->dbMdbGetPinType;
#                        $TLDB{$macro}->dbgTimingLibGetPinCap($pinName);
#                        $type = "fallDelay";
#                        my @cond = $TLDB{$macro}->dbTimingLibGetPinCond(S,A,$type);
#                        my $index = 0;
#                        foreach my $cond ( @cond ) { 
#                                if ( $cond eq "B&!CI" ) {     
#                                     print "$cond $index\n";
#                        print "Delay Table \n";
#                        my @data = $TLDB{$macro}->dbgTimingLibGetPinDelay(S,A,$index,"$type");
#                        print "Index Table \n";
#                        @data = $TLDB{$macro}->dbgTimingLibGetPinIndex(S,A,$index,"$type"); 
#                                                           }# if condition
#                           $index++;
#                                                   }#foreach condition
#                        $type = "riseDelay";
#                        @cond = $TLDB{$macro}->dbTimingLibGetPinCond(S,A,$type);
#                        $index = 0;
#                        foreach my $cond ( @cond ) { 
#                                if ( $cond eq "B&!CI" ) {     
#                                     print "$cond $index\n";
#                        print "Delay Table \n";
#                        @data = $TLDB{$macro}->dbgTimingLibGetPinDelay(S,A,$index,"$type");
#                        print "Index Table \n";
#                        @data = $TLDB{$macro}->dbgTimingLibGetPinIndex(S,A,$index,"$type"); 
#                                                           }# if condition
#                           $index++;
#                                                   }#foreach condition
# 
#                                                   }# foreach pin
#                                    }#if macro exists in timing lib
#                                           }# if macro is ADDFHX1
#                         }# foreach macro in library

                           }#if correct no of Arguments
my$t1 = new Benchmark;
my $td = timediff($t1, $t0);
print "Command read_lib_old took:",timestr($td),"\n";

}#sub read_lib_old




sub appendPG_to_lib  {

#****f* /appendPG_to_lib 
# NAME
#   appendPG_to_lib  
# FUNCTION
#   
#    
# SYNOPSIS
# 
# INPUTS
#      options :
#      
#      	-
# OUTPUTS
# 
#****



my $noOfArguments = @_;

if($noOfArguments < 2 || $_[0] eq '-h'){ print "Usage : appendPG_to_lib -inlib <input library>\n";
                        print "                        -outlib <output library >\n";
                      }else{
for(my $x = 0; $x < $noOfArguments; $x++){
if($_[$x] =~ /-inlib/){ $INPUT_LIBRARY = $_[$x+1];}
if($_[$x] =~ /-outlib/){ $OUTPUT_LIBRARY = $_[$x+1];}
                                         }#for correct no of Arguments
open (READ, "$INPUT_LIBRARY");
open (WRITE, ">$OUTPUT_LIBRARY");

my $CAPACITANCE = 0.005;

while(<READ>) {
chomp();
print WRITE "$_\n";
if($_ =~ /^\s*cell\s*\(\w*\)/) { # if contains the cell line
         ($macroName)=(split(/\s*\(\s*|\s*\)\s*/, $_))[1]; 
         if( exists $MACROS_ALREADY{$macroName} ) {
                foreach $pins ( keys %{$MACROS_ALREADY{$macroName}} ) {
                if ( $pins eq "area" ) {}
                else {
if( $MACROS_ALREADY{$macroName}{$pins}{use} eq "power" || $MACROS_ALREADY{$macroName}{$pins}{use} eq "ground" ){
                               print WRITE "\tpin\($pins\) \{\n";
                               print WRITE "\t\tdirection \: $MACROS[0]{$macroName}{$pins}{direction}\;\n";
                               print WRITE "\t\tcapacitance \: $CAPACITANCE\;\n";
                               print WRITE "\t\}\n";

                                                                       }
                     }
                                                                      }
                                                  }
         else { print "ERR-PAR-LIB : 001 : Did not find the $macroName in LEF file\n"; }
                               }
              }# while reading the input library

close(WRITE);

                            }# if correct arguments



}#sub appendPG_to_lib


sub read_footprint {

use Benchmark;
my $t0 = new Benchmark;

my $noOfArguments = @_;

if($noOfArguments < 2 || $_[0] eq '-h'){ print "Usage : read_footprint  -f <input footprint file>\n";
                      }else{
for(my $x = 0; $x < $noOfArguments; $x++){
if($_[$x] =~ /-f/){ $INPUT_FOOTPRINT_FILE = $_[$x+1];}
                                         }#for correct no of Arguments


if (-e "$INPUT_FOOTPRINT_FILE")
{ 

open (READ, $INPUT_FOOTPRINT_FILE);
print "INFO-PAR-LIB : 001 : reading the footprint file $INPUT_FOOTPRINT_FILE\n";
while (<READ>) {
chomp();
$_ =~ s/^\s+//;
if ( $_ =~ /^$/) { next; } else {
my ($macroName,$function,$type)=(split(/\s+/, $_))[0,1,2];
#print "$function\n";
            if ( exists $PLDB{$macroName} ) {
                 $PLDB{$macroName}->dbMdbSetFunction($function);
                 $PLDB{$macroName}->dbMdbSetType($type);
                 if ( $type eq "seq" ) { my ($in,$out,$clk)=(split(/\s+/, $_))[3,4,5];
  if ( exists $PLDB{$macroName}{PIN}{$clk} ) { $PLDB{$macroName}->dbMdbSetPinIsClock($clk); } else { print "WARN-PAR-FOOTPRT : 002 : $clk not found, check cell $macroName\n"; }
  if ( exists $PLDB{$macroName}{PIN}{$out} ) { $PLDB{$macroName}->dbMdbSetPinIsRegOut1($out); } else { print "WARN-PAR-FOOTPRT : 003 : $out not found, check cell $macroName\n"; }
  if ( exists $PLDB{$macroName}{PIN}{$in} ) { $PLDB{$macroName}->dbMdbSetPinIsRegIn1($in); } else { print "WRAN-PAR-FOOTPRT : 004 : $in not found, check cell $macroName\n"; }
                                       }# if the macro is type sequential
                                            }# if macro exist in the db
#if ( exists $MACROS_ATTRIBUTE_ALREADY{$macroName} ) {
#     $MACROS_ATTRIBUTE_ALREADY{$macroName}{func} = $function;
                                                   }#if
#                                }#if not empty line

               }#while

}#if
else {
     print "ERR-PAR-FOOTPRT : 005 : The footprint file $INPUT_FOOTPRINT_FILE does not exist .... please check the pathTo/filename\n";
     }
                           }#if correct noOfArguments

my $t1 = new Benchmark;
my $td = timediff($t1, $t0);
print "Command read_footprint took:",timestr($td),"\n";

}# sub read_footprint



sub do_characterize_inst {

#****f* /do_characterize_inst 
# NAME
#   do_characterize_inst  
# FUNCTION
#   
#    
# SYNOPSIS
# 
# INPUTS
#      options :
#
#      switches :
#      
#      	-
# OUTPUTS
# 
#****



my $delay = 2500;
my $tran = 1000;
foreach $inst ( keys %COMP_ALREADY ) {
print "INFO-PAR : 001 : $inst\n";
        $TADB{$inst} = TimingDB::new(); 
my      $cellref = $CADB{$inst}->dbCadbGetCellref;
my      @pins = $PLDB{$cellref}->dbMdbGetPins;
#        print join (",", @pins);
my @inputPins = ();
my @outputPins = ();
        foreach my $pinName ( @pins ) {
        my $direction = $PLDB{$cellref}->dbMdbGetPinDir($pinName);
           if ( $direction == 0 ) { push (@inputPins,$pinName); }
           elsif ( $direction == 1 ) { push (@outputPins,$pinName); }
           else{ }
                                      }# foreach
         foreach my $outPin ( @outputPins ) {
         foreach my $inPin ( @inputPins ) {
         $TADB{$inst}->dbTimingInstSetArcDly($inPin,$outPin,$delay,$tran);
         $TADB{$inst}->dbTimingInstSetArrAtPin($inPin,$delay,$tran);
         $TADB{$inst}->dbTimingInstSetBiasAtPin(VDD,1.8);
                                          }# foreach 
                                            }# foreach 


                                     }# foreach

foreach $inst (keys  %TADB ) {
        my ($arrival,$tran)  = $TADB{$inst}->dbTimingInstGetArrAtPin(A);
        my ($volt)  = $TADB{$inst}->dbTimingInstGetBiasAtPin(VDD);
        print "INFO-PAR : 002 : $inst Arr : $arrival Vdd : $volt\n";
                        }

}#sub do_characterize_inst


#---------------------------------------------------------------------------------------------------------------------------#


sub write_footprint {
    
#****f* /write_footprint
# NAME
#   write_footprint
# FUNCTION
#   write a footprint file
# Assumptions
#   write a footprint file
# SYNOPSIS
#   write_footprint 
# INPUTS
#   wrrite_footprint 
# OUTPUTS
#   macroName,function,clockpin,outputpin and inputpin
#****

use Benchmark;
my $t0 = new Benchmark;   

  open(WRITE,">footprint");
  foreach my $macroName(keys %PLDB){
    my $func = $PLDB{$macroName}->dbMdbGetFunction;
    my $type = $PLDB{$macroName}->dbMdbGetType;
    if ($func eq "flop" || $func eq "latch"){
        $function = "seq";
      my @pins = $PLDB{$macroName}->dbMdbGetPins;
      foreach my $pinName(@pins){
        if(exists $PLDB{$macroName}){
           $clock = $PLDB{$macroName}->dbMdbGetPinIsClock($pinName);
          if($clock == 1){$clockpin = $pinName;}
           $out = $PLDB{$macroName}->dbMdbGetPinIsRegOut1($pinName);
          if($out == 1){$outputpin = $pinName;}
           $in = $PLDB{$macroName}->dbMdbGetPinIsRegIn1($pinName);
          if($in == 1){$input = $pinName;}  
                                  }#if exists macroName
                                }#foreach pinName
          print WRITE "$macroName $func $function $input $outputpin $clockpin\n";
                              }#if func
    else{
         $function = "combi";
          print WRITE "$macroName $func $function\n";
                            }#else
                       }#foreach macro
close(WRITE);
my $t1 = new Benchmark;
my $td = timediff($t1, $t0);
print "Command write_footprint took:",timestr($td),"\n";

}#sub write_footprint


sub function_name_of_given_expression 
{
  my $exp = $_[0];
  my $curr_func_name = "";
  my $identifier = "([A-Za-z]([A-Za-z]|[0-9]|_)*)";
   if($exp =~ /^$/) {
      $curr_func_name = "UND" ;
    }
    chomp();
    if ($exp =~ m/^\(\s*$identifier\s*\^\s*$identifier\s*\^\s*$identifier\s*\)$/) {
      $curr_func_name = "sum of full adder" ;
    }
    elsif ($exp =~ m/^\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\^\s*$identifier\s*\)$/) {
      $curr_func_name = "xor" ;
    }
    elsif ($exp =~ m/^\(\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\^\s*$identifier\s*\)\^\s*$identifier\s*\)$/) {
      $curr_func_name = "xor" ;
    }
    elsif ($exp =~ m/^\(\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s+$identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s+$identifier\s*\)\s*\)/) {
     # print " carry of full adder";
      $curr_func_name = "carry of full adder" ;
    }
    elsif($exp =~ m/^\(\s*$identifier\s+$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "and" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "and" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s+$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "and" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s+$identifier\s*\)\s+$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "and" ;
    }
    elsif($exp =~ m/^\(\s*$identifier((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "or" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "or" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "or" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "or" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "andor" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "andor" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))\(\s*$identifier\s+$identifier\s*\)\s*\)((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "andor" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))\(\s*$identifier\s+$identifier\s*\)\s*\)((\|)|(\+))\(\s*$identifier\s+$identifier\s*\)\s*\)$/){
      #print " and ";
      $curr_func_name = "andor" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))\(\s*$identifier\s+$identifier\s*\)\s*\)$/){
      #print " and ";
      $curr_func_name = "andor" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)((\|)|(\+))$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "andor" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s*\)$/){
      #print " and ";
      $curr_func_name = "andor" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)\s+$identifier\s*\)\s+$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "orand" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)\s+$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "orand" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)\s+\(\s*$identifier((\|)|(\+))$identifier\s*\)\s*\)\s+$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "orand" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)\s+\(\s*$identifier((\|)|(\+))$identifier\s*\)\s*\)\s+\(\s*$identifier((\|)|(\+))$identifier\s*\)\s*\)$/){
      #print " and ";
      $curr_func_name = "orand" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)\s+\(\s*$identifier((\|)|(\+))$identifier\s*\)\s*\)$/){
      #print " and ";
      $curr_func_name = "orand" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)\s+$identifier\s*\)$/){
      #print " and ";
      $curr_func_name = "orand" ;
    }
    elsif($exp =~ m/^\(\s*\!\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s*\)\s*\)$/){
      #print " and ";
      $curr_func_name = "aoi" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)((\|)|(\+))\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s*\)$/){
      #print " and ";
      $curr_func_name = "andor" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)\s+\(\s*\($identifier((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)\s*\)$/){
      #print " and ";
      $curr_func_name = "orand" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*$identifier((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)\s+\(\s*\($identifier((\|)|(\+))$identifier\s*\)((\|)|(\+))$identifier\s*\)\s*\)$/){
      #print " and ";
      $curr_func_name = "orand" ;
    }
    elsif($exp =~ m/^\(\s*\!\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)((\|)|(\+))\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s*\)\s*\)$/){
      #print " and ";
      $curr_func_name = "aoi" ;
    }
    elsif($exp =~ m/^\(\s*$identifier\s*\^\s*$identifier\s*\)/){
      #print " xor ";
      $curr_func_name = "xor" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*$identifier\s+$identifier\s*\)\s+((\|)|(\+))\s+\(\s*\!$identifier\s+$identifier\s*\)\s*\)/){
      #print " xor ";
      $curr_func_name = "mux" ;
    }
    elsif($exp =~ m/^\(\!\(\s*\(\s*$identifier\s+$identifier\s*\)\s+((\|)|(\+))\s+\(\s*\!$identifier\s+$identifier\s*\)\s*\)\s*\)/){
      #print " xor ";
      $curr_func_name = "mux" ;
    }
    elsif($exp =~ m/^\(\!\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s*\)/){
      #print " nand ";
      $curr_func_name = "nand" ;
    }
    elsif($exp =~ m/^\(\!\s*\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s+$identifier\s*\)\s*\)/){
      #print " nand ";
      $curr_func_name = "nand" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*\(\s*$identifier\s*\^\s*$identifier\s*\^\s*$identifier\s*\'\s*\)\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s*\(\s*$identifier\s*\^\s*$identifier\s*\^ \s*$identifier\s*\'\s*\)\s*\)\s*\)/){
      #print " sum of full adder";
      $curr_func_name = "sum of full adder" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s*$identifier\s*\'\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s*$identifier\s*\)\s*\)/){
    #elsif($_ =~ m/^\(\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s*$identifier\s*\'\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s*$identifier\s*\)\s*\)/){}
      #print " carry of full adder";
      $curr_func_name = "carry of full adder" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*\(\s*$identifier\s*\^\s*$identifier\s*\^\s*$identifier\s*\)\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s*\(\s*$identifier\s*\^\s*$identifier\s*\^\s*$identifier\s*\)\s*\)\s*\)/){
      #print " sum of full adder";
      $curr_func_name = "sum of full adder" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s*$identifier\s*\)\s*\)/){
      #print " carry of full adder";
      $curr_func_name = "carry of full adder" ;
    }
    elsif($exp =~ m/^\(\s*$identifier\s*\^\s*$identifier\s*\'\s*\)/){
      #print " sum of half adder";
      $curr_func_name = "sum of half adder" ;
    }
    elsif($exp =~ m/^\(\s*$identifier\s*$identifier\s*\'\s*\)/){
      #print " carry of half adder";
      $curr_func_name = "carry of half adder" ;
    }
    elsif($exp =~ m/^\s*$identifier\s*$/){
      #print " buffer";
      $curr_func_name = "buf" ;
    }
    elsif($exp =~ m/^\s*\($identifier\s*\)$/){
      #print " buffer";
      $curr_func_name = "buf" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*$identifier\s*\)/){
      #print " inverter";
      $curr_func_name = "inv" ;
    }elsif($exp =~ m/^\s*\!\s*$identifier\s*/){
       #print "inverter";
       $curr_func_name = "inv";
    }elsif($exp =~ m/^\(\s*$identifier\s*\'\s*\)/){
       #print "inverter";
       $curr_func_name = "inv";
    }elsif($exp =~ m/^\s*$identifier\s*\'\s*/){
       #print "inverter";
       $curr_func_name = "inv";
    }
    elsif($exp =~ m/^\(\s*$identifier\s*\^\s*$identifier\s*\^\s*$identifier\s*\'\s*\)/){
      #print " sum of full adder";
      $curr_func_name = "sum of full adder" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\($identifier\s*\^\s*$identifier\s*\)\s*$identifier\s*\'\s*\)\s*((\|)|(\+))\s*\($identifier $identifier\s*\)\s*\)/){
      #print " carry of full adder";
      $curr_func_name = "carry of full adder" ;
    }
    elsif($exp =~ m/^\!\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)/){
      #print " and or invert";
      $curr_func_name = "aoi" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
      #print " and or invert";
      $curr_func_name = "aoi" ;
    }
    elsif($exp =~ m/^\!\s*\(\s*$identifier\s*((\|)|(\+))\s*\(\s*$identifier\s+$identifier\s*\)\s*\)/){
      #print " and or invert";
      $curr_func_name = "aoi" ;
    }
    elsif($exp =~ m/^\(\!\s*\(\s*$identifier\s*((\|)|(\+))\s*\(\s*$identifier\s+$identifier\s*\)\s*\)\s*\)/){
      #print " and or invert";
      $curr_func_name = "aoi" ;
    }
    elsif($exp =~ m/^\!\s*\(\s*\(\s*$identifier\s+$identifier\s+$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)$/){
      #print " and or invert";
      $curr_func_name = "aoi" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)$/){
      #print " and or invert";
      $curr_func_name = "aoi" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)$/){
      #print " and or invert";
      $curr_func_name = "aoi" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s+$identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s+$identifier\s*\)\s*\)\s*\)$/){
      #print " and or invert";
      $curr_func_name = "aoi" ;
    }
    elsif($exp =~ m/^\!\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s*((((\|)|(\+)))|(\+))\s*\(\s*$identifier\s+$identifier\s*\)\s*\)$/){
      #print " and or invert";
      $curr_func_name = "aoi" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s+$identifier\s*\)\s*\)\s*\)$/){
      #print " and or invert";
      $curr_func_name = "aoi" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))\(\s*$identifier\s+$identifier\s*\)\s*\)((\|)|(\+))$identifier\s*\)\s*\)$/){
      #print " and or invert";
      $curr_func_name = "aoi" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s+$identifier\s*\)((\|)|(\+))\(\s*$identifier\s+$identifier\s*\)\s*\)((\|)|(\+))\(\s*$identifier\s+$identifier\s*\)\s*\)\s*\)$/){
      #print " and or invert";
      $curr_func_name = "aoi" ;
    }
     elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s*\)\s*\)/){
      #print " and or invert";
      $curr_func_name = "oai" ;
    }
     elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s*\)\s*\)/){
      #print " and or invert";
      $curr_func_name = "oai" ;
    }
     elsif($exp =~ m/^\(\s*\(\s*\!\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s+$identifier\s*\)\s*\)/){
      #print " and or invert";
      $curr_func_name = "oai" ;
    }
     elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))$identifier\s*\)\s*\)\s*/){
      #print " and or invert";
      $curr_func_name = "oai" ;
    }
     elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
      #print " and or invert";
      $curr_func_name = "oai" ;
    }
     elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\)\s+$identifier\s*\)\s*\)/){
      #print " and or invert";
      $curr_func_name = "oai" ;
    }
     elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
      #print " and or invert";
      $curr_func_name = "oai" ;
    }

#    elsif($exp =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "4oai" ;
#    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s*\)\s+$identifier\s*\)\s*\)/){
      #print " and or invert";
      $curr_func_name = "oai" ;
    }
#    elsif($exp =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "4oai" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "4oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "4oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "4oai" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "4oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "4oai" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "4oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*$identifier\s+$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "4oai" ;
#    }
#    elsif($exp =~ m/^\s\(\s*\!\s*\(\s*$identifier\s+$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "4oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "4oai" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "4oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "4oai" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "4oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\)\s+$identifier\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\)\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\)\s+$identifier\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\)\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\(\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*$identifier\s+$identifier\s+$identifier\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*$identifier\s+$identifier\s+$identifier\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*$identifier\s+$identifier\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s+\)\s+$identifier\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*$identifier\s+$identifier\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s+\)\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s+$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+$identifier\s+$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s+$identifier\s+\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "5oai" ;
#    }
#




##-------------------------------------------------------------------------------------------------------------------------------------##

#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s+$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "aoi" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier $identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "aoi" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier $identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier $identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "aoi" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier $identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier $identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier $identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "aoi" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier $identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier $identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "aoi" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\!\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "aoi" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\!\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*((\|)|(\+))\s*\(\s*$identifier $identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "aoi" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier $identifier $identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "aoi" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier $identifier $identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier $identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "aoi" ;
#    }
#    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*$identifier\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier\s*$identifier\s*$identifier\s*\)\s*\)\s*\)/){
#      #print " and or invert";
#      $curr_func_name = "aoi" ;
#    }
    elsif($exp =~ m/^\(\s*$identifier\s*\^\s*$identifier\s*\^\s*$identifier\s*\)/){
      #print " sum of full adder";
      $curr_func_name = "sum of full adder" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*$identifier $identifier\s*\)\s*\)/){
      #print " carry of full adder";
      $curr_func_name = "carry of full adder" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s*\)/){
      #print " xnor ";
      $curr_func_name = "xnor" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*$identifier\s*\^\s*$identifier\s*\^\s*$identifier\s*\)\s*\)/){
      #print " xnor ";
      $curr_func_name = "xnor" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s*\^\s*$identifier\s*\)\s*\)/){
      #print " xnor ";
      $curr_func_name = "xnor" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*\^\s*$identifier\s*\)\s*\^\s*$identifier\s*\)\s*\^\s*$identifier\s*\)\s*\)/){
      #print " xnor ";
      $curr_func_name = "xnor" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*$identifier\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*$identifier\s*\)\s*\)/){
      #print " two input mux";
      $curr_func_name = "mux" ;
    }
    elsif($exp =~ m/^\(\s*\(\s*$identifier\s*\(\s*\(\s*$identifier $identifier\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*$identifier\s*\)\s*\)\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*\(\s*\(\s*$identifier\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*$identifier\s*\)\s*\)\s*\)\s*\)/){
      #print " four input mux";
      $curr_func_name = "mux" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*$identifier\s*\)\s*\)\s*\)/){
      #print " two input inverted mux";
      $curr_func_name = "mux" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*\(\s*\(\s*$identifier\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*$identifier\s*\)\s*\)\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*\(\s*\(\s*$identifier\s*$identifier\s*\)\s*((\|)|(\+))\s*\(\s*\(\s*\!\s*$identifier\s*\)\s*$identifier\s*\)\s*\)\s*\)\s*\)\s*\)/){
      #print " four input inverted mux";
      $curr_func_name = "mux" ;
    }
    elsif($exp =~ m/^\(\!\s*\(\s*$identifier\'?\s*$identifier\s*\)\s*\)/){
      #print " nand ";
      $curr_func_name = "nand" ;
    }
    elsif($exp =~ m/^\(\!\s*\(\s*$identifier\'? $identifier $identifier\)\)/){
      #print " nand ";
      $curr_func_name = "nand" ;
    }
    elsif($exp =~ m/^\(\!\s*\(\s*$identifier\'?\s*$identifier\'?\s*$identifier\s*$identifier\s*\)\s*\)/){
      #print " nand ";
      $curr_func_name = "nand" ;
    }
    elsif($exp =~ m/^\!\s*\(\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\'?\s*\)/){
      #print " nor ";
      $curr_func_name = "nor" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*\)/){
      #print " nor ";
      $curr_func_name = "nor" ;
    }
    elsif($exp =~ m/^\!\s*\(\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\)/){
      #print " nor ";
      $curr_func_name = "nor" ;
    }
    elsif($exp =~ m/^\!\s*\(\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\)/){
      #print " nor ";
      $curr_func_name = "nor" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\'?\s*\)\)/){
      #print " nor ";
      $curr_func_name = "nor" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\)\)/){
      #print " nor ";
      $curr_func_name = "nor" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\'?\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\)\)/){
      #print " nor ";
      $curr_func_name = "nor" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*((\|)|(\+))\s*$identifier\s*\)\s*((\|)|(\+))\s*$identifier\)\)/){
      #print " nor ";
      $curr_func_name = "nor" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*$identifier\s*$identifier\s*\)\s*\)/){
      #print " or and invert ";
      $curr_func_name = "oai" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*$identifier\s*\)\s*\)/){
      #print " 5 input or and invert ";\s*
      $curr_func_name = "oai" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
      #print " 6 input or and invert ";
      $curr_func_name = "oai" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\!\s*\(\s*$identifier\s*$identifier\s*\)\s*\)\s*$identifier\s*\)\s*\)/){
      #print " 3 input or and invert ";
      $curr_func_name = "oai" ;

    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
      #print " 4 input or and invert ";
      $curr_func_name = "oai" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*\!\s*\(\s*$identifier\s*$identifier\s*\)\s*\)\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
      #print " 4 input or and invert ";
      $curr_func_name = "oai" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*$identifier\s*\)\s*\)/){
      #print " 4 input or and invert";
      $curr_func_name = "oai" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
      #print " 5 input or and invert ";
      $curr_func_name = "oai" ;
    }
    elsif($exp =~ m/^\(\s*\!\s*\(\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)\s*\)\s*\)/){
      #print " 6 input or and invert ";
      $curr_func_name = "oai" ;
    }
    elsif($exp =~ m/^\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)/){
      #print " 2 input or";
      $curr_func_name = "or" ;
    }
    elsif($exp =~ m/\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)/){
      #print " 3 input or";
      $curr_func_name = "or" ;
    }
    elsif($exp =~ m/^\(\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*((\|)|(\+))\s*$identifier\s*\)/){
      #print " 4 input or";
      $curr_func_name = "or" ;
    }
    elsif($exp =~ m/^1$/){
      #print " tie 1";
      $curr_func_name = "tie 1" ;
    }
    elsif($exp =~ m/^0$/){
      #print " tie 0";
      $curr_func_name = "tie 0" ;
    } 
    else {
      $curr_func_name = "complex" ;
    } 
return $curr_func_name ;
}#sub function_name_of_given_expression

sub read_lib {
#****f* /read_lib 
# NAME
#   read_lib  
# FUNCTION
#   
#    
# SYNOPSIS
# 
# INPUTS
#      options :
#
#      switches :
#      
#      	-
# OUTPUTS
# 
#****

use Benchmark;
my $t0 = new Benchmark;

my $noOfArguments = @_;
my $INPUT_LIBRARY ="";

if($noOfArguments < 2 || $_[0] eq '-h'){ 
  print "Usage : read_lib -lib <dotlib_library>\n";
  print "                 -tlf <tlf_library   > currently not supported\n";
}else{
  for(my $x = 0; $x < $noOfArguments; $x++){
    if($_[$x] =~ /-lib/){ 
      $INPUT_LIBRARY = $_[$x+1];
    }
  }
}


$x = 11;
$z = 34;

$pi = liberty::si2drPIInit(\$x);
liberty::si2drReadLibertyFile($INPUT_LIBRARY, \$x);

$y = liberty::si2drPIGetErrorText($x, \$z);

my $groups_0 = liberty::si2drPIGetGroups(\$x);
while( !liberty::si2drObjectIsNull(my $group_0 = liberty::si2drIterNextGroup($groups_0,\$x), \$z) )
{
    my $group_0_type = liberty::si2drGroupGetGroupType($group_0,\$z);
    if ($group_0_type eq "library" ) {
      my $group_0_names = liberty::si2drGroupGetNames($group_0, \$z);
      $library_name = liberty::si2drIterNextName($group_0_names,\$z);
      print "\nINFO-PAR-LIB : 001 : Reading library $library_name";
      liberty::si2drIterQuit($group_0_names, \$x);

      my $groups_1 = liberty::si2drGroupGetGroups($group_0,\$x);
      while( !liberty::si2drObjectIsNull(my $group_1 = liberty::si2drIterNextGroup($groups_1,\$x), \$z) )
      {
        my $group_1_type = liberty::si2drGroupGetGroupType($group_1,\$z);
        if ($group_1_type eq "cell") {
          my $flopfound = 0;
          my $latchfound = 0;
          my $temp_reg_out1_func = "" ;
          my $temp_reg_out2_func = "" ;
          my $temp_reg_out1_pin = "" ;
          my $temp_reg_out2_pin = "" ;
          my $group_1_names = liberty::si2drGroupGetNames($group_1, \$z);
          my $cell_name = liberty::si2drIterNextName($group_1_names,\$z);
          print "\nDBG-PAR-LIB : 002 : Reading cell $cell_name"if($debug ==333);
          liberty::si2drIterQuit($group_1_names, \$x);
          $TLDB{$cell_name} = TimingLibDB::new();
          $TLDB{$cell_name}->dbTimingLibSetCellName($cell_name);

          my $group_1_attributes = liberty::si2drGroupGetAttrs($group_1,\$z);
          while( !liberty::si2drObjectIsNull(my $group_1_attribute = liberty::si2drIterNextAttr($group_1_attributes,\$x),\$z) )
          {
            my $attr_name = liberty::si2drAttrGetName($group_1_attribute,\$z);
            if ($attr_name eq "cell_footprint") {
              my $cell_footprint_value = liberty::si2drSimpleAttrGetStringValue($group_1_attribute, \$x);
              $TLDB{$cell_name}->dbTimingLibSetCellFootPrint($cell_footprint_value);
              print "\nDBG-PAR-LIB : 007 : Its cell_footprint is $cell_footprint_value"if($debug ==333);
              if(exists$PLDB{$cell_name}){
                $PLDB{$cell_name}->dbMdbSetFootprint($cell_footprint_value);
              }#if exists PLDB                          
              last;
            }
          }
          liberty::si2drIterQuit($group_1_attributes, \$x);
          my $groups_2_preprocess = liberty::si2drGroupGetGroups($group_1,\$x);
          while( !liberty::si2drObjectIsNull(my $group_2_preprocess = liberty::si2drIterNextGroup($groups_2_preprocess,\$x), \$z) )
          {
            my $group_2_preprocess_type = liberty::si2drGroupGetGroupType($group_2_preprocess,\$z);
            if($group_2_preprocess_type eq "ff") {
              print "\nDBG-PAR-LIB : 003 : Info: cell $cell_name is a flop" if($debug ==333);
              $flopfound = 1;
              if(exists$PLDB{$cell_name}){
              $PLDB{$cell_name}->dbMdbSetFunction("flop");
              $PLDB{$cell_name}->dbMdbSetType("seq");
              }#if exists PLDB
              my $group_2_preprocess_names = liberty::si2drGroupGetNames($group_2_preprocess, \$z);
              $temp_reg_out1_func = liberty::si2drIterNextName($group_2_preprocess_names,\$z);
              $temp_reg_out2_func = liberty::si2drIterNextName($group_2_preprocess_names,\$z);
              liberty::si2drIterQuit($group_2_preprocess_names, \$x);
              print "\nDBG-PAR-LIB : 004 : Info: for flop primary func is $temp_reg_out1_func and secondary func is $temp_reg_out2_func"if($debug ==333); 
              last ;
            }
            if($group_2_preprocess_type eq "latch") {
              print "\nDBG-PAR-LIB : 005 : Info: cell $cell_name is a latch" if($debug ==333);
              $latchfound = 1;
              if(exists$PLDB{$cell_name}){
              $PLDB{$cell_name}->dbMdbSetFunction("latch");
              $PLDB{$cell_name}->dbMdbSetType("seq");
              }#if exists PLDB
              my $group_2_preprocess_names = liberty::si2drGroupGetNames($group_2_preprocess, \$z);
              $temp_reg_out1_func = liberty::si2drIterNextName($group_2_preprocess_names,\$z);
              $temp_reg_out2_func = liberty::si2drIterNextName($group_2_preprocess_names,\$z);
              liberty::si2drIterQuit($group_2_preprocess_names, \$x);
              print "\nDBG-PAR-LIB : 006 : Info: for latch primary func is $temp_reg_out1_func and secondary func is $temp_reg_out2_func"if($debug ==333); 
              my $group_2_preprocess_attributes = liberty::si2drGroupGetAttrs($group_2_preprocess,\$z);
              while( !liberty::si2drObjectIsNull(my $group_2_preprocess_attribute = liberty::si2drIterNextAttr($group_2_preprocess_attributes,\$x),\$z) )
              {
                my $attr_name = liberty::si2drAttrGetName($group_2_preprocess_attribute,\$z);
                if ($attr_name eq "data_in") {
                  my $data_in_value = liberty::si2drSimpleAttrGetStringValue($group_2_preprocess_attribute, \$x);
                  print "\nDBG-PAR-LIB : 007 : Its data in is $data_in_value"if($debug ==333);
                  if(exists$PLDB{$cell_name}){
                  $PLDB{$cell_name}->dbMdbSetPinIsRegIn1($data_in_value);
                  }#if exists PLDB                          
                  last;
                }
              }
              liberty::si2drIterQuit($group_2_preprocess_attributes, \$x);
              last ;
            }
          }
          liberty::si2drIterQuit($groups_2_preprocess, \$x);
          #--------------------------------------------------------------------------------------------------#
          my $group_1_for_bus= liberty::si2drGroupGetGroups($group_1,\$z);
          while( !liberty::si2drObjectIsNull(my $group_1_bus = liberty::si2drIterNextGroup($group_1_for_bus,\$x), \$z) )
          {
            my $group_1_get_bus = liberty::si2drGroupGetNames($group_1_bus, \$z);
            my $group_1_bus_type = liberty::si2drGroupGetGroupType($group_1_bus,\$z);
            if($group_1_bus_type eq "bus"){
              my %check_pin_hash = ();
              my %check_pin_dir_hash = ();
              my $dir_found = 0;
              my $pinname = liberty::si2drIterNextName($group_1_get_bus,\$z);
              #print "\nMansi $group_1_bus_type => $pin_name";

              my $group_1_bus_attributes = liberty::si2drGroupGetAttrs($group_1_bus,\$z);
              while( !liberty::si2drObjectIsNull(my $group_1_bus_attribute = liberty::si2drIterNextAttr($group_1_bus_attributes,\$x),\$z) )
              {
                my $group_2_bus_attr_name = liberty::si2drAttrGetName($group_1_bus_attribute,\$z);
                if($group_2_bus_attr_name eq "bus_type"){
                  my $bus_type_name = liberty::si2drSimpleAttrGetStringValue($group_1_bus_attribute, \$x);
                }elsif($group_2_bus_attr_name eq "direction"){
                  my $pin_dir = liberty::si2drSimpleAttrGetStringValue($group_1_bus_attribute, \$x);
                  $check_pin_dir_hash{$pinname} = $pin_dir;
                  #print "\n$group_2_bus_attr_name => $pin_name => $pin_direction";
                } 
              }
              liberty::si2drIterQuit($group_1_bus_attributes, \$x);
              my $group_2_for_bus= liberty::si2drGroupGetGroups($group_1_bus,\$z);
              while( !liberty::si2drObjectIsNull(my $group_2_bus_pin = liberty::si2drIterNextGroup($group_2_for_bus,\$x), \$z) )
              {
                my $group_2_bus_type = liberty::si2drGroupGetGroupType($group_2_bus_pin, \$z);
                if($group_2_bus_type eq "pin"){
                  my %temp_reltd_pins = {};  
                  my $pin_is_vector = 0;
                  my $group_2_bus_preprocess_names = liberty::si2drGroupGetNames($group_2_bus_pin, \$z);
                  my $pin = liberty::si2drIterNextName($group_2_bus_preprocess_names,\$z);
                  if($pin =~ /(\[|<)\s*[0-9]+\s*\:\s*[0-9]+\s*(\]|>)/){
                    $pin_is_vector = 1;
                  }
                  if($pin_is_vector == 1){
                    my @port_with_bit_blast = &port_blast($pin); 
                    foreach my $pin_name (@port_with_bit_blast){
                      $TLDB{$cell_name}->dbTimingLibAddPin($pin_name);
                      $check_pin_hash{$pin_name} = 1;
                    }
                  }else {
                    if(!exists $check_pin_hash{$pin}){ 
                      $TLDB{$cell_name}->dbTimingLibAddPin($pin);
                    }
                  }
                  #print "\nMansi $group_2_bus_type => $pin_name";
                  liberty::si2drIterQuit($group_2_bus_preprocess_names, \$x);
                  my $group_2_bus_pin_attributes = liberty::si2drGroupGetAttrs($group_2_bus_pin,\$z);
                  #-------------------------------------------------------------------------------------------------------#
                  while( !liberty::si2drObjectIsNull(my $group_2_bus_pin_attribute = liberty::si2drIterNextAttr($group_2_bus_pin_attributes,\$x),\$z) )
                  {
                    my $group_2_bus_pin_attr_name = liberty::si2drAttrGetName($group_2_bus_pin_attribute,\$z);
                    if ($group_2_bus_pin_attr_name eq "direction") {
                      my $pin_direction = liberty::si2drSimpleAttrGetStringValue($group_2_bus_pin_attribute, \$x);
                      $dir_found = 1;
                      if($pin_is_vector == 1){
                        my @port_with_bit_blast = &port_blast($pin); 
                        foreach my $pin_name (@port_with_bit_blast){
                          $TLDB{$cell_name}->dbTimingLibSetPinDir($pin_name,$pin_direction);
                        }
                      }else {
                        if(!exists $check_pin_hash{$pin}){
                          $TLDB{$cell_name}->dbTimingLibSetPinDir($pin,$pin_direction);
                        }
                      }
                    }
                    if ($group_2_bus_pin_attr_name eq "function") {
                      my $pin_function = liberty::si2drSimpleAttrGetStringValue($group_2_bus_pin_attribute, \$x);
                      if($pin_is_vector == 1){
                        my @port_with_bit_blast = &port_blast($pin); 
                        foreach my $pin_name (@port_with_bit_blast){
                          $TLDB{$cell_name}->dbTimingLibSetPinFunc($pin_name,$pin_function);
                        }
                      }else {
                          if(!exists $check_pin_hash{$pin}){
                            $TLDB{$cell_name}->dbTimingLibSetPinFunc($pin,$pin_function);
                          }
                      }
                    }
                    if (($group_2_bus_pin_attr_name eq "max_capacitance")||
                        ($group_2_bus_pin_attr_name eq "capacitance")) {
                      my $pin_max_capacitance = liberty::si2drSimpleAttrGetFloat64Value($group_2_bus_pin_attribute, \$x);
                      if($pin_is_vector == 1){
                        my @port_with_bit_blast = &port_blast($pin); 
                        foreach my $pin_name (@port_with_bit_blast){
                          $TLDB{$cell_name}->dbTimingLibSetPinCap($pin_name,$pin_max_capacitance);
                        }
                      }else {
                          if(!exists $check_pin_hash{$pin}){
                            $TLDB{$cell_name}->dbTimingLibSetPinCap($pin,$pin_max_capacitance);
                          }
                      }
                    }
                    if ($group_2_bus_pin_attr_name eq "clock") {
                      if(($flopfound == 1) || ($latchfound ==1)) {
                        my $clock_bus_pin_attribute_value = liberty::si2drSimpleAttrGetBooleanValue($group_2_bus_pin_attribute, \$x);
                        if($clock_bus_pin_attribute_value == 1) {
                          my $pinType = 'clock';
                          if($pin_is_vector == 1){
                            my @port_with_bit_blast = &port_blast($pin); 
                            foreach my $pin_name (@port_with_bit_blast){
                              $TLDB{$cell_name}->dbTimingLibSetPinType($pin_name,$pinType);
                            }
                          }else {
                              if(!exists $check_pin_hash{$pin}){
                                $TLDB{$cell_name}->dbTimingLibSetPinType($pin,$pinType);
                              }
                          }
                        }
                      }
                    }
                  }
                  liberty::si2drIterQuit($group_2_bus_pin_attributes, \$x);
                  #-------------------------------------------------------------------------------------------------------#
                  if($dir_found == 0){
                    if($pin_is_vector == 1){
                      my @port_with_bit_blast = &port_blast($pin); 
                      my $temp_pin = $pin;
                      $temp_pin =~ s/\[.*//;
                      if(exists $check_pin_dir_hash{$temp_pin}){
                        my $pin_dir = $check_pin_dir_hash{$temp_pin};
                        foreach my $pin_name (@port_with_bit_blast){
                          $TLDB{$cell_name}->dbTimingLibSetPinDir($pin_name,$pin_dir);
                        }
                      }
                    }else {
                      if(!exists $check_pin_hash{$pin}){
                        my $temp_pin = $pin;
                        $temp_pin =~ s/\[.*//;
                        if(exists $check_pin_dir_hash{$temp_pin}){
                          my $pin_dir = $check_pin_dir_hash{$temp_pin};
                          $TLDB{$cell_name}->dbTimingLibSetPinDir($pin,$pin_dir);
                        }
                      }
                    } 
                  }
                  #-------------------------------------------------------------------------------------------------------#
                  my $groups_3_bus_pin = liberty::si2drGroupGetGroups($group_2_bus_pin,\$x);
                  while( !liberty::si2drObjectIsNull(my $group_3_bus_pin = liberty::si2drIterNextGroup($groups_3_bus_pin,\$x), \$z) )
                  {
                    my $group_3_bus_pin_type = liberty::si2drGroupGetGroupType($group_3_bus_pin,\$z);
                    #print "\nMansi $group_3_bus_pin_type\n"; 
                    if($group_3_bus_pin_type eq "timing"){
                      my $related_pin = "";
                      my $condition = "NONE";
                      my $sdf_cond = "";
                      my $timing_sense = "" ;
                      my $timing_type = "" ;
                      my $group_3_bus_pin_attributes = liberty::si2drGroupGetAttrs($group_3_bus_pin,\$z);
                      while( !liberty::si2drObjectIsNull(my $group_3_bus_pin_attribute = liberty::si2drIterNextAttr($group_3_bus_pin_attributes,\$x),\$z) )
                      {
                         my $group_3_bus_pin_attr_name = liberty::si2drAttrGetName($group_3_bus_pin_attribute,\$z);
                         if($group_3_bus_pin_attr_name eq "related_pin"){
                           $related_pin = liberty::si2drSimpleAttrGetStringValue($group_3_bus_pin_attribute, \$x);
                           if(!exists $temp_reltd_pins{$related_pin}){
                             if($pin_is_vector == 1){
                               my @port_with_bit_blast = &port_blast($pin); 
                               foreach my $pin_name (@port_with_bit_blast){
                                 $TLDB{$cell_name}->dbTimingLibSetPinRPin($pin_name,$related_pin);
                                 $temp_reltd_pins{$related_pin} = 1;
                               }
                             }else {
                               if(!exists $check_pin_hash{$pin}){
                                 $TLDB{$cell_name}->dbTimingLibSetPinRPin($pin,$related_pin);
                                 $temp_reltd_pins{$related_pin} = 1;
                               }
                             }
                           }
                         }
                         if($group_3_bus_pin_attr_name eq "when"){
                           $condition = liberty::si2drSimpleAttrGetStringValue($group_3_bus_pin_attribute, \$x);
                           if($pin_is_vector == 1){
                             my @port_with_bit_blast = &port_blast($pin); 
                             foreach my $pin_name (@port_with_bit_blast){
                               $TLDB{$cell_name}->dbTimingLibSetPinCond($pin_name,$related_pin,$condition);
                             }
                           }else {
                             if(!exists $check_pin_hash{$pin}){
                               $TLDB{$cell_name}->dbTimingLibSetPinCond($pin,$related_pin,$condition);
                             }
                           }
                         } 
                         if($group_3_bus_pin_attr_name eq "timing_type"){
                           $timing_type = liberty::si2drSimpleAttrGetStringValue($group_3_bus_pin_attribute, \$x);
                         } 
                         if($group_3_bus_pin_attr_name eq "timing_sense"){
                           $timing_sense = liberty::si2drSimpleAttrGetStringValue($group_3_bus_pin_attribute, \$x);
                         } 
                         if($group_3_bus_pin_attr_name eq "sdf_cond"){
                           $sdf_cond = liberty::si2drSimpleAttrGetStringValue($group_3_bus_pin_attribute, \$x);
                         } 
                      }
                      if($pin_is_vector == 1){
                        my @port_with_bit_blast = &port_blast($pin); 
                        foreach my $pin_name (@port_with_bit_blast){
                          $TLDB{$cell_name}->dbTimingLibSetPinTimingType($pin_name,$related_pin,$condition,$timing_type);
                          $TLDB{$cell_name}->dbTimingLibSetPinTimingSense($pin_name,$related_pin,$condition,$timing_sense);
                          $TLDB{$cell_name}->dbTimingLibSetPinSdfCond($pin_name,$related_pin,$condition,$sdf_cond);
                        }
                      }else {
                        if(!exists $check_pin_hash{$pin}){
                          $TLDB{$cell_name}->dbTimingLibSetPinTimingType($pin,$related_pin,$condition,$timing_type);
                          $TLDB{$cell_name}->dbTimingLibSetPinTimingSense($pin,$related_pin,$condition,$timing_sense);
                          $TLDB{$cell_name}->dbTimingLibSetPinSdfCond($pin,$related_pin,$condition,$sdf_cond);
                        }
                      }
                      liberty::si2drIterQuit($group_3_bus_pin_attributes, \$x);

                      my $groups_4_bus_pin = liberty::si2drGroupGetGroups($group_3_bus_pin,\$x);
                      while( !liberty::si2drObjectIsNull(my $group_4_bus_pin = liberty::si2drIterNextGroup($groups_4_bus_pin,\$x), \$z) )
                      {
                        my $group_4_bus_pin_type = liberty::si2drGroupGetGroupType($group_4_bus_pin,\$z);
                        if (($group_4_bus_pin_type eq "cell_rise") || ($group_4_bus_pin_type eq "cell_fall")){
                          my $group_4_bus_pin_names = liberty::si2drGroupGetNames($group_4_bus_pin, \$z);
                          my $index = liberty::si2drIterNextName($group_4_bus_pin_names,\$z);
                          liberty::si2drIterQuit($group_4_bus_pin_names, \$x);
                          my @valueArray = (); 
                          my @indexArray = (); 
                          my $group_4_bus_pin_attrs = liberty::si2drGroupGetAttrs($group_4_bus_pin,\$x);
                          while( !liberty::si2drObjectIsNull(my $group_4_bus_pin_attr = liberty::si2drIterNextAttr($group_4_bus_pin_attrs,\$x), \$z) )
                          {
                            my $group_4_bus_pin_attr_name = liberty::si2drAttrGetName($group_4_bus_pin_attr,\$z);
                            if($group_4_bus_pin_attr_name eq "index_1") {
                              my $complex_values = liberty::si2drComplexAttrGetValues($group_4_bus_pin_attr, \$z);
                              while( 1 ) {
                                my $complex_value = liberty::si2drIterNextComplex($complex_values,\$z) ;
                                my $vt = liberty::si2drComplexValGetValueType($complex_value, \$z);
                                if($vt == $liberty::SI2DR_STRING)
                                {
                                  my $index_1_vals = liberty::si2drComplexValGetStringValue($complex_value, \$z);
                                  push(@indexArray, $index_1_vals); 
                                } else{ last; }
                              }
                              liberty::si2drIterQuit($complex_values, \$x);
                            }
                            if($group_4_bus_pin_attr_name eq "index_2") {
                              my $complex_values = liberty::si2drComplexAttrGetValues($group_4_bus_pin_attr, \$z);
                              while( 1 ) {
                                my $complex_value = liberty::si2drIterNextComplex($complex_values,\$z) ;
                                my $vt = liberty::si2drComplexValGetValueType($complex_value, \$z);
                                if($vt == $liberty::SI2DR_STRING)
                                {
                                  my $index_2_vals = liberty::si2drComplexValGetStringValue($complex_value, \$z);
                                  push(@indexArray, $index_2_vals); 
                                } else{ last; }
                              }
                              liberty::si2drIterQuit($complex_values, \$x);
                            }
                            if($group_4_bus_pin_attr_name eq "values") {
                              my $complex_values = liberty::si2drComplexAttrGetValues($group_4_bus_pin_attr, \$z);
                              while( 1 ) {
                                my $complex_value = liberty::si2drIterNextComplex($complex_values,\$z) ;
                                my $vt = liberty::si2drComplexValGetValueType($complex_value, \$z);
                                if($vt == $liberty::SI2DR_STRING)
                                {
                                  my $values_vals = liberty::si2drComplexValGetStringValue($complex_value, \$z);
                                  push(@valueArray, $values_vals); 
                                } else{ last; }
                              }
                              liberty::si2drIterQuit($complex_values, \$x);
                            }
                          }
                          liberty::si2drIterQuit($group_4_bus_pin_attrs, \$x);
                          if ($group_4_bus_pin_type eq "cell_rise") {
                            if($pin_is_vector == 1){
                              my @port_with_bit_blast = &port_blast($pin); 
                              foreach my $pin_name (@port_with_bit_blast){
                                $TLDB{$cell_name}->dbTimingLibSetPinDelay($pin_name, $related_pin, $condition, "riseDelay", @valueArray);
                                $TLDB{$cell_name}->dbTimingLibSetPinDelayIndex($pin_name, $related_pin, $condition, "riseDelay", $index, @indexArray);
                              }
                            }else {
                              if(!exists $check_pin_hash{$pin}){
                                $TLDB{$cell_name}->dbTimingLibSetPinDelay($pin, $related_pin, $condition, "riseDelay", @valueArray);
                                $TLDB{$cell_name}->dbTimingLibSetPinDelayIndex($pin, $related_pin, $condition, "riseDelay", $index, @indexArray);
                              }
                            }
                          }
                          if ($group_4_bus_pin_type eq "cell_fall") {
                            if($pin_is_vector == 1){
                              my @port_with_bit_blast = &port_blast($pin); 
                              foreach my $pin_name (@port_with_bit_blast){
                                $TLDB{$cell_name}->dbTimingLibSetPinDelay($pin_name, $related_pin, $condition, "fallDelay", @valueArray);
                                $TLDB{$cell_name}->dbTimingLibSetPinDelayIndex($pin_name, $related_pin, $condition, "fallDelay", $index, @indexArray);

                              }
                            }else {
                              if(!exists $check_pin_hash{$pin}){
                                $TLDB{$cell_name}->dbTimingLibSetPinDelay($pin, $related_pin, $condition, "fallDelay", @valueArray);
                                $TLDB{$cell_name}->dbTimingLibSetPinDelayIndex($pin, $related_pin, $condition, "fallDelay", $index, @indexArray);
                              }
                            }
                          }
                        }
                      }
                      liberty::si2drIterQuit($groups_4_bus_pin, \$x);
                    }
                  }
                  liberty::si2drIterQuit($groups_3_bus_pin, \$x);
                }
              }
              liberty::si2drIterQuit($group_2_for_bus , \$x);
            }
            liberty::si2drIterQuit($group_1_get_bus, \$x);
          }
          liberty::si2drIterQuit($group_1_for_bus , \$x);
          #----------------------------added by Mansi--------------------------------------------------------#
          my $group_1_attributes_next = liberty::si2drGroupGetAttrs($group_1,\$z);
          while( !liberty::si2drObjectIsNull(my $group_1_attribute = liberty::si2drIterNextAttr($group_1_attributes_next,\$x),\$z) )
          {
            my $group_1_attr_name = liberty::si2drAttrGetName($group_1_attribute,\$z);
            if($group_1_attr_name eq "area"){
              my $area = liberty::si2drSimpleAttrGetFloat64Value($group_1_attribute, \$x);
              $TLDB{$cell_name}->dbTimingLibSetCellArea($area);
            }
            #if($group_1_attr_name eq "cell_footprint"){
              #my $cell_footprint = liberty::si2drSimpleAttrGetStringValue($group_1_attribute, \$x);
              #$TLDB{$cell_name}->dbTimingLibSetCellFootPrint($cell_footprint);
            #}
          }
          liberty::si2drIterQuit($group_1_attributes_next , \$x);
          #-------------------------------------------------------------------------------------------------#
          my $groups_2 = liberty::si2drGroupGetGroups($group_1,\$x);
          while( !liberty::si2drObjectIsNull(my $group_2 = liberty::si2drIterNextGroup($groups_2,\$x), \$z) )
          {
            my $group_2_type = liberty::si2drGroupGetGroupType($group_2,\$z);
            if($group_2_type eq "pin") {
              my %temp_reltd_pins = {};  
              my $group_2_names = liberty::si2drGroupGetNames($group_2, \$z);
              my $pin_name = liberty::si2drIterNextName($group_2_names,\$z);
              $TLDB{$cell_name}->dbTimingLibAddPin($pin_name);
              liberty::si2drIterQuit($group_2_names, \$x);
              print "\nDBG-PAR-LIB : 008 : Reading pin $pin_name" if($debug ==333);
              my $group_2_attributes = liberty::si2drGroupGetAttrs($group_2,\$z);
              while( !liberty::si2drObjectIsNull(my $group_2_attribute = liberty::si2drIterNextAttr($group_2_attributes,\$x),\$z) )
              {
                my $group_2_attr_name = liberty::si2drAttrGetName($group_2_attribute,\$z);
                if ($group_2_attr_name eq "direction") {
                  my $pin_direction = liberty::si2drSimpleAttrGetStringValue($group_2_attribute, \$x);
                  $TLDB{$cell_name}->dbTimingLibSetPinDir($pin_name,$pin_direction);
                  my $new_dir = $TLDB{$cell_name}->dbTimingLibGetPinDir($pin_name); 
                  print "\nDBG-PAR-LIB : 009 : pin direction is $pin_direction" if($debug ==333);
                }
                if ($group_2_attr_name eq "function") {
                  my $pin_function = liberty::si2drSimpleAttrGetStringValue($group_2_attribute, \$x);
                  $TLDB{$cell_name}->dbTimingLibSetPinFunc($pin_name,$pin_function);
                  print "\nDBG-PAR-LIB : 010 : pin function is $pin_function" if($debug ==333);
                  if(($flopfound == 1) || ($latchfound == 1)) {
                    if($pin_function eq $temp_reg_out1_func) {
                      $temp_reg_out1_pin = $pin_name ;
                      print "\nDBG-PAR-LIB : 011 : Its data out is $pin_name"if($debug ==333);
                    }
                    if($pin_function eq $temp_reg_out2_func) {
                      $temp_reg_out2_pin = $pin_name ;
                      print "\nDBG-PAR-LIB : 012 : Its data out is $pin_name"if($debug ==333);
                    }
                  }
                  if(($flopfound ==0) && ($latchfound ==0)){
                    my $cell_function = &function_name_of_given_expression($pin_function);
                    if(exists $PLDB{$cell_name}){
                    $PLDB{$cell_name}->dbMdbSetFunction($cell_function);
                    }#if exists PLDB 
                  }
                }
                if (($group_2_attr_name eq "max_capacitance")||
                    ($group_2_attr_name eq "capacitance")) {
                  my $pin_max_capacitance = liberty::si2drSimpleAttrGetFloat64Value($group_2_attribute, \$x);
                  $TLDB{$cell_name}->dbTimingLibSetPinCap($pin_name,$pin_max_capacitance);
                  print "\nDBG-PAR-LIB : 013 : pin max_capacitance is $pin_max_capacitance" if($debug ==333);
                }
                if ($group_2_attr_name eq "nextstate_type") {
                  if($flopfound ==1) {
                    my $nextstate_type = liberty::si2drSimpleAttrGetStringValue($group_2_attribute, \$x);
                    if($nextstate_type eq "data") {
                      print "\nDBG-PAR-LIB : 014 : Its data in is $pin_name"if($debug ==333);
                      if(exists $PLDB{$cell_name}){
                      $PLDB{$cell_name}->dbMdbSetPinIsRegIn1($pin_name);
                      }#if exists PLDB
                    }
                  }
                }
                if ($group_2_attr_name eq "clock") {
                  if(($flopfound == 1) || ($latchfound ==1)) {
                    my $clock_attribute_value = liberty::si2drSimpleAttrGetBooleanValue($group_2_attribute, \$x);
                    if($clock_attribute_value == 1) {
                      print "\nDBG-PAR-LIB : 015 : Its clock is $pin_name"if($debug ==333);
                      my $pinType = 'clock';
                      $TLDB{$cell_name}->dbTimingLibSetPinType($pin_name,$pinType);
                      if(exists $PLDB{$cell_name}){
                      $PLDB{$cell_name}->dbMdbSetPinIsClock($pin_name);
                      }#if exists PLDB
                    }
                  }
                }
              }
              liberty::si2drIterQuit($group_2_attributes, \$x);

              my $groups_3 = liberty::si2drGroupGetGroups($group_2,\$x);
              while( !liberty::si2drObjectIsNull(my $group_3 = liberty::si2drIterNextGroup($groups_3,\$x), \$z) )
              {
                my $group_3_type = liberty::si2drGroupGetGroupType($group_3,\$z);
                if ($group_3_type eq "timing") {
                  print "\nDBG-PAR-LIB : 016 : Reading timing" if($debug ==333);
                  my $related_pin = "" ;
                  my $condition = "NONE" ;
                  my $sdf_cond = "" ;
                  my $timing_sense = "" ;
                  my $timing_type = "" ;
                  my $group_3_attributes = liberty::si2drGroupGetAttrs($group_3,\$z);
                  while( !liberty::si2drObjectIsNull(my $group_3_attribute = liberty::si2drIterNextAttr($group_3_attributes,\$x),\$z) )
                  {
                    my $group_3_attr_name = liberty::si2drAttrGetName($group_3_attribute,\$z);
                    if($group_3_attr_name eq "related_pin"){
                      $related_pin = liberty::si2drSimpleAttrGetStringValue($group_3_attribute, \$x);
                      if(!exists $temp_reltd_pins{$related_pin}){
                         $TLDB{$cell_name}->dbTimingLibSetPinRPin($pin_name,$related_pin);
                         $temp_reltd_pins{$related_pin} = 1;
                      }
                      print "\nDBG-PAR-LIB : 017 : Its related pin is $related_pin" if($debug ==333);
                    }
                    if($group_3_attr_name eq "when"){
                      $condition = liberty::si2drSimpleAttrGetStringValue($group_3_attribute, \$x);
                      $TLDB{$cell_name}->dbTimingLibSetPinCond($pin_name,$related_pin,$condition);
                      print "\nDBG-PAR-LIB : 018 : Its condition is $condition" if($debug ==333);
                    }
                    if($group_3_attr_name eq "timing_type"){
                      $timing_type = liberty::si2drSimpleAttrGetStringValue($group_3_attribute, \$x);
                      print "\nDBG-PAR-LIB : 018 : Its timing type is $timing_type" if($debug ==333);
                    }
                    if($group_3_attr_name eq "timing_sense"){
                      $timing_sense = liberty::si2drSimpleAttrGetStringValue($group_3_attribute, \$x);
                      print "\nDBG-PAR-LIB : 018 : Its timing sense is $timing_sense" if($debug ==333);
                    }
                    if($group_3_attr_name eq "sdf_cond"){
                      $sdf_cond = liberty::si2drSimpleAttrGetStringValue($group_3_attribute, \$x);
                      print "\nDBG-PAR-LIB : 018 : Its sdf_cond is $sdf_cond" if($debug ==333);
                    }
                  }
                  $TLDB{$cell_name}->dbTimingLibSetPinTimingType($pin_name,$related_pin,$condition,$timing_type);
                  $TLDB{$cell_name}->dbTimingLibSetPinTimingSense($pin_name,$related_pin,$condition,$timing_sense);
                  $TLDB{$cell_name}->dbTimingLibSetPinSdfCond($pin_name,$related_pin,$condition,$sdf_cond);
                  liberty::si2drIterQuit($group_3_attributes, \$x);

                  my $groups_4 = liberty::si2drGroupGetGroups($group_3,\$x);
                  while( !liberty::si2drObjectIsNull(my $group_4 = liberty::si2drIterNextGroup($groups_4,\$x), \$z) )
                  {
                    my $group_4_type = liberty::si2drGroupGetGroupType($group_4,\$z);
                    if (($group_4_type eq "cell_rise") || ($group_4_type eq "cell_fall")){
                      print "\nDBG-PAR-LIB : 019 : Reading $group_4_type" if($debug ==333);
                      my $group_4_names = liberty::si2drGroupGetNames($group_4, \$z);
                      my $index = liberty::si2drIterNextName($group_4_names,\$z);
                      print "\nDBG-PAR-LIB : 020 : Reading $index" if($debug ==333);
                      liberty::si2drIterQuit($group_4_names, \$x);
                      my @valueArray = (); 
                      my @indexArray = (); 
                      my $group_4_attrs = liberty::si2drGroupGetAttrs($group_4,\$x);
                      while( !liberty::si2drObjectIsNull(my $group_4_attr = liberty::si2drIterNextAttr($group_4_attrs,\$x), \$z) )
                      {
                        my $group_4_attr_name = liberty::si2drAttrGetName($group_4_attr,\$z);
                        if($group_4_attr_name eq "index_1") {
                          print "\nDBG-PAR-LIB : 021 : Reading index_1" if($debug ==333);
                          my $complex_values = liberty::si2drComplexAttrGetValues($group_4_attr, \$z);
                          while( 1 ) {
                            my $complex_value = liberty::si2drIterNextComplex($complex_values,\$z) ;
                            my $vt = liberty::si2drComplexValGetValueType($complex_value, \$z);
                            if($vt == $liberty::SI2DR_STRING)
                            {
                              my $index_1_vals = liberty::si2drComplexValGetStringValue($complex_value, \$z);
                              #$index_1_vals =~ s/\,//g;
                              print "\nDBG-PAR-LIB : 022 : index_1 val is  $index_1_vals" if($debug ==333);
                              push(@indexArray, $index_1_vals); 
                            } else{ last; }
                          }
                          liberty::si2drIterQuit($complex_values, \$x);
                        }
                        if($group_4_attr_name eq "index_2") {
                          print "\nDBG-PAR-LIB : 023 : Reading index_2" if($debug ==333);
                          my $complex_values = liberty::si2drComplexAttrGetValues($group_4_attr, \$z);
                          while( 1 ) {
                            my $complex_value = liberty::si2drIterNextComplex($complex_values,\$z) ;
                            my $vt = liberty::si2drComplexValGetValueType($complex_value, \$z);
                            if($vt == $liberty::SI2DR_STRING)
                            {
                              my $index_2_vals = liberty::si2drComplexValGetStringValue($complex_value, \$z);
                              #$index_2_vals =~ s/\,//g;
                              print "\nDBG-PAR-LIB : 024 : index_2 val is  $index_2_vals" if($debug ==333);
                              push(@indexArray, $index_2_vals); 
                            } else{ last; }
                          }
                          liberty::si2drIterQuit($complex_values, \$x);
                        }
                        if($group_4_attr_name eq "values") {
                          print "\nDBG-PAR-LIB : 025 : Reading values" if($debug ==333);
                          print "\nDBG-PAR-LIB : 026 : values val is" if($debug ==333);
                          my $complex_values = liberty::si2drComplexAttrGetValues($group_4_attr, \$z);
                          while( 1 ) {
                            my $complex_value = liberty::si2drIterNextComplex($complex_values,\$z) ;
                            my $vt = liberty::si2drComplexValGetValueType($complex_value, \$z);
                            if($vt == $liberty::SI2DR_STRING)
                            {
                              my $values_vals = liberty::si2drComplexValGetStringValue($complex_value, \$z);
                              #$values_vals =~ s/\,//g;
                              print "\nDBG-PAR-LIB : 027 : $values_vals" if($debug ==333);
                              push(@valueArray, $values_vals); 
                            } else{ last; }
                          }
                          liberty::si2drIterQuit($complex_values, \$x);
                        }
                      }
                      liberty::si2drIterQuit($group_4_attrs, \$x);
                      if ($group_4_type eq "cell_rise") {
                        $TLDB{$cell_name}->dbTimingLibSetPinDelay($pin_name, $related_pin, $condition, "riseDelay", @valueArray);
                        $TLDB{$cell_name}->dbTimingLibSetPinDelayIndex($pin_name, $related_pin, $condition, "riseDelay", $index, @indexArray);
                      }
                      if ($group_4_type eq "cell_fall") {
                        $TLDB{$cell_name}->dbTimingLibSetPinDelay($pin_name, $related_pin, $condition, "fallDelay", @valueArray);
                        $TLDB{$cell_name}->dbTimingLibSetPinDelayIndex($pin_name, $related_pin, $condition, "fallDelay", $index, @indexArray);
                      }
                    }
                  }
                  liberty::si2drIterQuit($groups_4, \$x);
                }
                if($group_3_type eq "internal_power"){
                  my $internal_related_pin = "";
                  my $internal_condition = "NONE";
                  my $timing_sense = "";
                  my $timing_type = "";
                  my $group_3_internal_attributes = liberty::si2drGroupGetAttrs($group_3,\$z);
                  while( !liberty::si2drObjectIsNull(my $group_3_internal_attribute = liberty::si2drIterNextAttr($group_3_internal_attributes,\$x),\$z) )
                  {
                    my $group_3_internal_attr_name = liberty::si2drAttrGetName($group_3_internal_attribute,\$z);
                    if($group_3_internal_attr_name eq "related_pin"){
                      $internal_related_pin = liberty::si2drSimpleAttrGetStringValue($group_3_internal_attribute, \$x);
                    }
                    if($group_3_internal_attr_name eq "when"){
                      $internal_condition = liberty::si2drSimpleAttrGetStringValue($group_3_internal_attribute, \$x);
                      print "\nDBG-PAR-LIB : 018 : Its condition is $internal_condition" if($debug ==333);
                    }
                  }
                  liberty::si2drIterQuit($group_3_internal_attributes, \$x);
                  my $groups_4_for_internal_power = liberty::si2drGroupGetGroups($group_3,\$x);
                  while( !liberty::si2drObjectIsNull(my $group_4_for_internal = liberty::si2drIterNextGroup($groups_4_for_internal_power,\$x), \$z) )
                  {
                    my $group_4_type_for_internal_power = liberty::si2drGroupGetGroupType($group_4_for_internal,\$z);
                    if (($group_4_type_for_internal_power eq "rise_power") || ($group_4_type_for_internal_power eq "fall_power")){
                      my $group_4_names_for_internal = liberty::si2drGroupGetNames($group_4_for_internal, \$z);
                      my $index = liberty::si2drIterNextName($group_4_names_for_internal,\$z);
                      print "\nDBG-PAR-LIB : 020 : Reading $index" if($debug ==333);
                      liberty::si2drIterQuit($group_4_names_for_internal, \$x);
                      my @valueArray_for_internal = (); 
                      my @indexArray_for_internal = (); 
                      my $group_4_attrs_for_internal = liberty::si2drGroupGetAttrs($group_4_for_internal,\$x);
                      while( !liberty::si2drObjectIsNull(my $group_4_attr_for_internal = liberty::si2drIterNextAttr($group_4_attrs_for_internal,\$x), \$z) )
                      {
                        my $group_4_attr_name_for_internal = liberty::si2drAttrGetName($group_4_attr_for_internal,\$z);
                        if($group_4_attr_name_for_internal eq "index_1") {
                          print "\nDBG-PAR-LIB : 021 : Reading index_1" if($debug ==333);
                          my $complex_values_for_internal = liberty::si2drComplexAttrGetValues($group_4_attr_for_internal, \$z);
                          while( 1 ) {
                            my $complex_value_for_internal = liberty::si2drIterNextComplex($complex_values_for_internal,\$z) ;
                            my $vt_for_internal = liberty::si2drComplexValGetValueType($complex_value_for_internal, \$z);
                            if($vt_for_internal == $liberty::SI2DR_STRING)
                            {
                              my $index_1_vals_for_internal = liberty::si2drComplexValGetStringValue($complex_value_for_internal, \$z);
                              #$index_1_vals =~ s/\,//g;
                              print "\nDBG-PAR-LIB : 022 : index_1 val is  $index_1_vals_for_internal" if($debug ==333);
                              push(@indexArray_for_internal, $index_1_vals_for_internal); 
                            } else{ last; }
                          }
                          liberty::si2drIterQuit($complex_values_for_internal, \$x);
                        }
                        if($group_4_attr_name_for_internal eq "index_2") {
                          print "\nDBG-PAR-LIB : 023 : Reading index_2" if($debug ==333);
                          my $complex_values_for_internal = liberty::si2drComplexAttrGetValues($group_4_attr_for_internal, \$z);
                          while( 1 ) {
                            my $complex_value_for_internal = liberty::si2drIterNextComplex($complex_values_for_internal,\$z) ;
                            my $vt_for_internal = liberty::si2drComplexValGetValueType($complex_value_for_internal, \$z);
                            if($vt_for_internal == $liberty::SI2DR_STRING)
                            {
                              my $index_2_vals_for_internal = liberty::si2drComplexValGetStringValue($complex_value_for_internal, \$z);
                              #$index_2_vals =~ s/\,//g;
                              print "\nDBG-PAR-LIB : 024 : index_2 val is  $index_2_vals_for_internal" if($debug ==333);
                              push(@indexArray_for_internal, $index_2_vals_for_internal); 
                            } else{ last; }
                          }
                          liberty::si2drIterQuit($complex_values_for_internal, \$x);
                        }
                        if($group_4_attr_name_for_internal eq "index_3") {
                          print "\nDBG-PAR-LIB : 023 : Reading index_3" if($debug ==333);
                          my $complex_values_for_internal = liberty::si2drComplexAttrGetValues($group_4_attr_for_internal, \$z);
                          while( 1 ) {
                            my $complex_value_for_internal = liberty::si2drIterNextComplex($complex_values_for_internal,\$z) ;
                            my $vt_for_internal = liberty::si2drComplexValGetValueType($complex_value_for_internal, \$z);
                            if($vt_for_internal == $liberty::SI2DR_STRING)
                            {
                              my $index_3_vals_for_internal = liberty::si2drComplexValGetStringValue($complex_value_for_internal, \$z);
                              #$index_3_vals =~ s/\,//g;
                              print "\nDBG-PAR-LIB : 024 : index_3 val is  $index_3_vals_for_internal" if($debug ==333);
                              push(@indexArray_for_internal, $index_3_vals_for_internal); 
                            } else{ last; }
                          }
                          liberty::si2drIterQuit($complex_values_for_internal, \$x);
                        }
                        if($group_4_attr_name_for_internal eq "values") {
                          print "\nDBG-PAR-LIB : 025 : Reading values" if($debug ==333);
                          print "\nDBG-PAR-LIB : 026 : values val is" if($debug ==333);
                          my $complex_values_for_internal = liberty::si2drComplexAttrGetValues($group_4_attr_for_internal, \$z);
                          while( 1 ) {
                            my $complex_value_for_internal = liberty::si2drIterNextComplex($complex_values_for_internal,\$z) ;
                            my $vt_for_internal = liberty::si2drComplexValGetValueType($complex_value_for_internal, \$z);
                            if($vt_for_internal == $liberty::SI2DR_STRING)
                            {
                              my $values_vals_for_internal = liberty::si2drComplexValGetStringValue($complex_value_for_internal, \$z);
                              #$values_vals =~ s/\,//g;
                              print "\nDBG-PAR-LIB : 027 : $values_vals_for_internal" if($debug ==333);
                              push(@valueArray_for_internal, $values_vals_for_internal); 
                            } else{ last; }
                          }
                          liberty::si2drIterQuit($complex_values_for_internal, \$x);
                        }
                      }
                      liberty::si2drIterQuit($group_4_attrs_for_internal, \$x);
                      if ($group_4_type_for_internal_power eq "rise_power") {
                        $TLDB{$cell_name}->dbTimingLibSetPinPower($pin_name, $internal_related_pin, $internal_condition, "risePower", @valueArray_for_internal);
                        $TLDB{$cell_name}->dbTimingLibSetPinIndexPower($pin_name, $internal_related_pin, $internal_condition, "risePower", $index, @indexArray_for_internal);
                      }
                      if ($group_4_type_for_internal_power eq "fall_power") {
                        $TLDB{$cell_name}->dbTimingLibSetPinPower($pin_name, $internal_related_pin, $internal_condition, "fallPower", @valueArray_for_internal);
                        $TLDB{$cell_name}->dbTimingLibSetPinIndexPower($pin_name, $internal_related_pin, $internal_condition, "fallPower", $index, @indexArray_for_internal);
                      }
                    }
                  }
                  liberty::si2drIterQuit($groups_4_for_internal_power, \$x);
                }
              }
              liberty::si2drIterQuit($groups_3, \$x);
            }
          }
          if(($temp_reg_out1_pin ne "") && ($temp_reg_out2_pin ne "")) {
            if(exists $PLDB{$cell_name}){
            $PLDB{$cell_name}->dbMdbSetPinIsRegOut1($temp_reg_out1_pin);
            $PLDB{$cell_name}->dbMdbSetPinIsRegOut2($temp_reg_out2_pin);
            }#if exists PLDB 
          }elsif ($temp_reg_out1_pin ne "") {
            if(exists $PLDB{$cell_name}){
            $PLDB{$cell_name}->dbMdbSetPinIsRegOut1($temp_reg_out1_pin);
            }#if exists PLDB
          }elsif ($temp_reg_out2_pin ne "") {
           if(exists $PLDB{$cell_name}){
            $PLDB{$cell_name}->dbMdbSetPinIsRegOut1($temp_reg_out2_pin);
           }#if exists PLDB 
          }
          liberty::si2drIterQuit($groups_2, \$x);
          print "\n" if($debug ==333);
        }
      }
      liberty::si2drIterQuit($groups_1, \$x);
    }
}
liberty::si2drIterQuit($groups_0, \$x);

$pi = liberty::si2drPIQuit(\$x);

print "\nDBG-PAR-LIB : 028 : PIInit returns $x" if($debug ==333);

print "\nDBG-PAR-LIB : 029 : Done!\n" if($debug ==333);

my$t1 = new Benchmark;
my $td = timediff($t1, $t0);
print "\nCommand read_lib took:",timestr($td),"\n";
}#sub read_lib

sub dbDisplaySMatrix3DPlot 
{
  print "INFO-PAR-DIS_SMTX_3DPLT : 001 : plotting the placement analysis gui\n";
  my $output_do_file = "${TOP_MODULE}_3d_val.do";
  my $output_txt_file = "${TOP_MODULE}_3d_val.txt";
  my $toOverwriteOP = 0 ;
  my $noOfArguments = @_;
  if ($_[0] eq '-h'){
    print "Usage : dbDisplaySMatrix3DPlot -output <fileName>\n";
    print "      : --overwrite\n";
  } else {
    for (my $i =0;$i< $noOfArguments; $i++){
      if($_[$i] eq "-output"){$output_txt_file = $_[$i+1];}
      if($_[$i] eq "--overwrite"){$toOverwriteOP = 1;}
    }
  }
  if ( exists $PLACE{$TOP_MODULE} ) {
    if( -e $output_txt_file){
       if ($toOverwriteOP == 1){
         print "WARN-PAR-DIS_SMTX_3DPLT : 002 : $output_txt_file exists, overwriting existing file as instructed\n";
       } else {
         print "ERROR-PAR-DIS_SMTX_3DPLT : 003 : $output_txt_file exists, Please change the output name or remove the existing file\n";
         return;
       }
    }
    open (WRITE_3D_TXT, ">$output_txt_file");
    if (!( -w $output_txt_file )){
      print "ERROR-PAR-DIS_SMTX_3DPLT : 004 : Permission denied to write to $output_txt_file\n";
      return;
    }
    my $maxRow = $PLACE{$TOP_MODULE}->dbPlaceGetMaxRow;
    print "DBG-PAR-DIS_SMTX_3DPLT : 005 : max Row is $maxRow\n"if($debug ==333);
    for ( my $yy = 1; $yy <= $maxRow ; $yy++ ) {
      print "DBG-PAR-DIS_SMTX_3DPLT : 006 : processing  Row $yy\n"if($debug ==333);
      my @fanins = $PLACE{$TOP_MODULE}->dbPlaceGetFanIns($yy);
      foreach $xx ( @fanins ) {
        print "DBG-PAR-DIS_SMTX_3DPLT : 007 : processing  fanin $xx\n"if($debug ==333);
        my $val =  $PLACE{$TOP_MODULE}->dbPlaceGetTpathVal($yy,$xx);
        print WRITE_3D_TXT "$xx  $yy  $val \n";
        print "DBG-PAR-DIS_SMTX_3DPLT : 008 : $xx  $yy  $val \n"if($debug ==333);
      }
    }
    close(WRITE_3D_TXT);
    open (WRITE_DO_FILE, ">$output_do_file");
    if (!( -w $output_do_file )){
      print "ERROR-PAR-DIS_SMTX_3DPLT : 009 : Cannot create/write temp file $output_do_file for graph plotting\n";
      return;
    }
    print WRITE_DO_FILE "set contour base\n";
    print WRITE_DO_FILE "set autoscale\n";
    print WRITE_DO_FILE "set xlabel \"Flop From\"\n";
    print WRITE_DO_FILE "set ylabel \"Flop To \"\n";
    print WRITE_DO_FILE "set zlabel \"Cell Val\"\n";
    print WRITE_DO_FILE "set title \"proton : Analysis Graph\"\n";
    print WRITE_DO_FILE "set pm3d scansbackward\n";
    print WRITE_DO_FILE "set dgrid3d 10,10,3\n";
    print WRITE_DO_FILE "splot './eqator_sort_tmp.txt' with pm3d\n";
    print WRITE_DO_FILE "pause -1\n";
    close(WRITE_DO_FILE);
    system "sort -g +0 -1 +1 -2 +2 -3 $output_txt_file >  eqator_sort_tmp.txt" ;
    my $forked_pid_3d_plot ;
    undef $forked_pid_3d_plot ;
    my $no_of_try = 0 ;
    while (!defined ($forked_pid_3d_plot = fork())){
      $no_of_try++;
      if($no_of_try == 10) {
        print "\nERROR-PAR-DIS_SMTX_3DPLT : 010 : Could not plot 3d graph for design analysis" ;
        return ;
      }
      sleep(2) ;
    }
    if ($forked_pid_3d_plot == 0)  {
      exec "gnuplot $output_do_file " ;
    }
  } else {
    print "WARN-PAR-DIS_SMTX_3DPLT : 011 : Please run prePlaceData before running this command\n";
  }
}# sub dbDisplaySMatrix3DPlot

sub write_lib_new {
use Benchmark;
my $t0 = new Benchmark;

$noOfArguments = @_;
my $OUTPUT_LIB;
my $write_power = 0;
if($noOfArguments < 2 || $_[0] eq '-h') {
   print "usage : write_lib -outlib < Output file> \n";
   print "      : --power\n";
}else{
   for(my $i = 0 ; $i < $noOfArguments ;  $i++){
       if($_[$i] eq "-outlib"){$OUTPUT_LIB = $_[$i+1];}
       if($_[$i] eq "--power"){$write_power = 1;} 
   }# for no of arguments

   open ( WRITE_LIB, ">$OUTPUT_LIB");
   foreach my $cell (keys %TLDB){
     print WRITE_LIB "cell \($cell\) \{\n";
     if(exists $PLDB{$cell}){
        my $cellFunc = $PLDB{$cell}->dbMdbGetFunction;
        print WRITE_LIB "  function : $cellFunc\;\n";
     } 
     #my @pins = $PLDB{$cell}->dbMdbGetPins;
     my @pins = $TLDB{$cell}->dbTimingLibGetPins;
     foreach my $pin (@pins){
       #if($pin eq "VDD" || $pin eq "VSS"){next;}
       my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);  
       #my $name = $TLDB{$cell}->dbTimingLibGetCellName;  
       if($pinDir eq ""){next;}
       print WRITE_LIB "  pin \($pin\) \{\n";
       print WRITE_LIB "    direction : $pinDir\;\n";
       if($pinDir eq "output"){
          my $pinFunc = $TLDB{$cell}->dbTimingLibGetPinFunc($pin);
          print WRITE_LIB "    function : \"$pinFunc\"\;\n";
          my @reltdPins = $TLDB{$cell}->dbTimingLibGetPinRPin($pin);
          foreach my $reltdPin(@reltdPins){
             my @conds = $TLDB{$cell}->dbTimingLibGetPinCond($pin,$reltdPin);
             push (@conds, "NONE");     
             foreach my $condition (@conds){
                my $timing_type = $TLDB{$cell}->dbTimingLibGetPinTimingType($pin,$reltdPin,$condition);   
                my $timing_sense = $TLDB{$cell}->dbTimingLibGetPinTimingSense($pin,$reltdPin,$condition);   
                my $sdf_cond = $TLDB{$cell}->dbTimingLibGetPinSdfCond($pin,$reltdPin,$condition);   

                my @cellRiseIndexVal = $TLDB{$cell}->dbTimingLibGetPinDelayIndex($pin,$reltdPin,$condition,"riseDelay");
                my @cellRiseDelayVal = $TLDB{$cell}->dbTimingLibGetPinDelay($pin,$reltdPin,$condition,"riseDelay");
                my @cellFallIndexVal = $TLDB{$cell}->dbTimingLibGetPinDelayIndex($pin,$reltdPin,$condition,"fallDelay");
                my @cellFallDelayVal = $TLDB{$cell}->dbTimingLibGetPinDelay($pin,$reltdPin,$condition,"fallDelay");
                if($write_power == 1){
                  my @cellRisePowerIndexVal = $TLDB{$cell}->dbTimingLibGetPinIndexPower($pin,$reltdPin,$condition,"risePower"); 
                  my @cellRisePowerVal = $TLDB{$cell}->dbTimingLibGetPinPower($pin,$reltdPin,$condition,"risePower"); 
                  my @cellFallPowerIndexVal = $TLDB{$cell}->dbTimingLibGetPinIndexPower($pin,$reltdPin,$condition,"fallPower"); 
                  my @cellFallPowerVal = $TLDB{$cell}->dbTimingLibGetPinPower($pin,$reltdPin,$condition,"fallPower"); 

                  if((@cellRisePowerIndexVal > 0 && @cellRisePowerVal > 0) || (@cellFallPowerIndexVal > 0 && @cellFallPowerVal > 0)){
                    print WRITE_LIB "    internal_power() \{\n";
                    print WRITE_LIB "        related_pin : \"$reltdPin\"\;\n";
                    print WRITE_LIB "        when : \"$condition\"\:\n" if($condition ne "NONE"); 
                    if(@cellRisePowerIndexVal > 0){
                      print WRITE_LIB "      rise_power\($cellRisePowerIndexVal[0]\) \{\n";
                      print WRITE_LIB "        index_1 \(\"$cellRisePowerIndexVal[1]\"\)\;\n";
                      print WRITE_LIB "        index_2 \(\"$cellRisePowerIndexVal[2]\"\)\;\n" if($cellRisePowerIndexVal[2] ne "");
                      print WRITE_LIB "        index_3 \(\"$cellRisePowerIndexVal[3]\"\)\;\n" if($cellRisePowerIndexVal[3] ne "");
                      print WRITE_LIB "        values \( \\\n";
                      foreach my $rpwrVal (@cellRisePowerVal){
                        if($rpwrVal ne $cellRisePowerVal[-1]){
                          print WRITE_LIB "          \"$rpwrVal\"\, \\\n";
                        }else {
                          print WRITE_LIB "          \"$rpwrVal\"\)\;\n";
                        }
                      }
                      print WRITE_LIB "      \}\n";
                    }
                    if(@cellFallPowerVal > 0){
                       print WRITE_LIB "     fall_power\($cellFallPowerIndexVal[0]\) \{\n";
                       print WRITE_LIB "       index_1 \(\"$cellFallPowerIndexVal[1]\"\)\;\n";
                       print WRITE_LIB "       index_2 \(\"$cellFallPowerIndexVal[2]\"\)\;\n" if($cellFallPowerIndexVal[2]  ne "");
                       print WRITE_LIB "       index_3 \(\"$cellFallPowerIndexVal[3]\"\)\;\n" if($cellFallPowerIndexVal[3] ne "");
                       print WRITE_LIB "       values \( \\\n";
                       foreach my $fVal (@cellFallPowerVal){
                         if($fVal ne $cellFallPowerVal[-1]){
                            print WRITE_LIB "          \"$fVal\"\, \\\n";
                         }else{
                            print WRITE_LIB "          \"$fVal\"\)\;\n";
                         }
                       }
                       print WRITE_LIB "      \}\n";
                    }
                     print WRITE_LIB "    \}\n";
                  }
                }#if write power

                if((@cellRiseIndexVal > 0 && @cellRiseDelayVal > 0) || (@cellFallIndexVal > 0 && @cellFallDelayVal > 0)){
                   print WRITE_LIB "    timing() \{\n";
                   print WRITE_LIB "      related_pin : \"$reltdPin\"\;\n";
                   print WRITE_LIB "      timing_type : $timing_type\;\n" if($timing_type ne "");
                   print WRITE_LIB "      timing_sense : $timing_sense\;\n" if($timing_sense ne "");
                   print WRITE_LIB "      when : \"$condition\"\;\n" if($condition ne "NONE");
                   print WRITE_LIB "      sdf_cond : \"$sdf_cond\"\;\n" if($sdf_cond ne "");
                   if(@cellRiseDelayVal > 0){
                      print WRITE_LIB "      cell_rise\($cellRiseIndexVal[0]\) \{\n";
                      print WRITE_LIB "        index_1 \(\"$cellRiseIndexVal[1]\"\)\;\n";
                      print WRITE_LIB "        index_2 \(\"$cellRiseIndexVal[2]\"\)\;\n";
                      print WRITE_LIB "        values \( \\\n";
                      foreach my $rDelVal (@cellRiseDelayVal){
                        if($rDelVal ne $cellRiseDelayVal[-1]){
                           print WRITE_LIB "          \"$rDelVal\"\, \\\n";
                        }else{
                           print WRITE_LIB "          \"$rDelVal\"\)\;\n";
                        }
                      }
                      print WRITE_LIB "      \}\n";
                   }
                   if(@cellFallDelayVal > 0){
                      print WRITE_LIB "      cell_fall\($cellFallIndexVal[0]\) \{\n";
                      print WRITE_LIB "        index_1 \(\"$cellFallIndexVal[1]\"\)\;\n";
                      print WRITE_LIB "        index_2 \(\"$cellFallIndexVal[2]\"\)\;\n";
                      print WRITE_LIB "        values \( \\\n";
                      foreach my $fDelVal (@cellFallDelayVal){
                        if($fDelVal ne $cellFallDelayVal[-1]){
                           print WRITE_LIB "          \"$fDelVal\"\, \\\n";
                        }else{
                           print WRITE_LIB "          \"$fDelVal\"\)\;\n";
                        }
                      }
                      print WRITE_LIB "      \}\n";
                   }
                   print WRITE_LIB "    \}\n";
                }#if values exists in db 
             }#foreach condition
          }#foreach related pin
       }#if output pin
       print WRITE_LIB "  \}\n";
     }#foreach pin
     print WRITE_LIB"\}\n";
   }#for each cell
   close(WRITE_LIB);
}
my$t1 = new Benchmark;
my $td = timediff($t1, $t0);
print "\nCommand write_lib took:",timestr($td),"\n";
}#sub write_lib_new

sub write_lib{
#****f* /write_lib 
# NAME
#   write_lib  
# FUNCTION
#        write_lib command write a .lib model of a cell from its LEF model if --fromlef switch is given. The main purpose of this command is to create a approximate liberty model of the given LEF macro. it contains pin information, direction, capacitance and load attributes. It does not contain the header, so the output needs to be added in an existing libert file with the header.
#    
# SYNOPSIS
# 
# INPUTS
#      case1: if switch --fromlef is given 
#         options :
#                 -outlib < specify the filename in which the lib for macro would be writen>
#                 -cellList {macro1,macro2}   a comma separated list of macronames for which lib has to written
#                 -delay_info_file <delay file>\n";
#                 -listFile < list of macros in a file one macroname per line >\n";
#                 -power_ground < false / true >\n";
#      case2: if switch --fromlef is not given 
#         options :
#                 -outlib < specify the filename in which the lib would be writen>
#
#      switches :
#              --fromlef
#      
#      	-
# OUTPUTS
# 
#****

my $noOfArguments = @_;
if($noOfArguments < 2 || $_[0] eq '-h') {
   print "usage : write_lib --fromlef (optional) \n";
   print "                  --forSynth (optional) \n";
   print "                  -outlib < Output file> \n";
   print "                  -cellList < {tcl list of macroes} >\n";
   print "                  -delay_info_file <delay file>\n";
   print "                  -listFile < list of macros in a file one macroname per line >\n";
   print "                  -power_ground < false / true >\n";
}else {
   my $fromLef = 0;
   for(my $i = 0 ; $i < $noOfArguments ;  $i++){
       if($_[$i] eq "--fromlef"){$fromLef = 1; $yosys = 0; }
       if($_[$i] eq "--forSynth"){$yosys = 1;}
   }# for no of arguments

   if($yosys == 1){
      &write_lib_yosys(@_);
   }elsif($fromLef == 1){
      &write_lib_old(@_);
   }else{
      &write_lib_new(@_);
   }
}
}#sub write_lib

#####################################################################
#################### Combining lib files ############################
#####################################################################
sub combine_lib{
my $noOfArg = @_;
my ($list_str, $path, $outFile) = ("", "", ""); 
my @lib_list = ();
if($noOfArg < 4 || $_[0] eq "-h" || $_[0] eq "-help"){
   print "Usage: combine_lib -lib <lib1,lib2,.....>\n";
   print "                   -path <path having list of lib files>\n";
   print "                   -out  <output lib file>\n";
}else{
   for(my $i=0; $i<$noOfArg; $i++){
       if($_[$i] eq "-lib") {$list_str = $_[$i+1];}
       if($_[$i] eq "-path"){ $path = $_[$i+1];}
       if($_[$i] eq "-out") {$outFile = $_[$i+1];}
   }
   
   #$list_str =~ s/\{(.*)\}/\1/;
   my @list1 = split(/\,/, $list_str);
   push(@lib_list, @list1);

   if($path ne "" && -e $path ){
      my @list2 = `find $path -name \\*\\.lib`;
      $_ =~ s/\s*$//g for @list2;
      push(@lib_list, @list2);
   }
   
   open (WRITE_LIB, ">$outFile");
   my $count = 0;
   foreach my $lib (@lib_list){
     if(-e $lib){
        open(READ_LIB, "$lib");
        my $start_cell_read = 0;
        while(<READ_LIB>){
          chomp();
          if($count == 0){
            print WRITE_LIB "$_\n" if($_ !~ /^\}/);
          }else{
            if($_ =~ /\s+\bcell\b/){$start_cell_read = 1;}
            if($start_cell_read == 1 && $_ !~ /^\}/){
               print WRITE_LIB "$_\n";
            }
          }
        }#while reading
        close READ_LIB;
        #print WRITE_LIB "\n";
        $count++;
     }else {
        print "WARN: $lib does not exist\n";
     }#if file does not exist
   }#foreach 
   print WRITE_LIB "}\n" if($count > 0);
   close WRITE_LIB;
}
}#sub combine_lib

#####################################################################
sub write_hana_lib_file {
use Benchmark;
my $t0 = new Benchmark;
my $noOfArguments = @_;
if($noOfArguments < 2 || $_[0] eq '-h'){
  print "Usage : write_lib\n";
  print "      : -outlib <output file>\n";
}else {
  my $OUTPUT_LIB;
  for(my $i=0;$i < $noOfArguments;$i++){
    if($_[$i] eq "-outlib"){$OUTPUT_LIB = $_[$i+1];}
  }#for
  open(WRITE_LIB,">$OUTPUT_LIB");
  foreach my $cell (keys %TLDB){
    print WRITE_LIB "Cell $cell \{\n";
    my @cellRiseDelayVal = ();
    my @pins = $TLDB{$cell}->dbTimingLibGetPins;
    foreach my $pin (@pins){
      my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
      if($pinDir eq ""){next;}
      if($pinDir eq "output"){
        #print WRITE_LIB "\tpin:\t\tOUTPUT $pin\;\n";	 	 
        my @reltdPins = $TLDB{$cell}->dbTimingLibGetPinRPin($pin);
        my @conds = $TLDB{$cell}->dbTimingLibGetPinCond($pin,$reltdPins[0]);
        push (@conds, "NONE");     
        @cellRiseDelayVal = $TLDB{$cell}->dbTimingLibGetPinDelay($pin,$reltdPins[0],$conds[0],"riseDelay");
      }elsif($pinDir eq "input"){
        #print WRITE_LIB "\tpin:\t\tINPUT $pin\;\n";
      }elsif($pinDir eq "inout"){
        #print WRITE_LIB "\tpin:\t\tINOUT $pin\;\n";
      }
    }#foreach
    if($cell =~ /^and/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){ 
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tAND\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^buf/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){ 
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tBUF\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^tribuf/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          print WRITE_LIB"\tpin:\t\tINPUT $pin\;\n";
        }elsif($pinDir eq "output"){
          print WRITE_LIB"\tpin:\t\tOUTPUT $pin\;\n";
        }
      }#foreach
      print WRITE_LIB "\tfunction:\tTRIBUF\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^inv/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){ 
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tINV\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^or/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){ 
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tOR\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^nand/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tNAND\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^nor/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tNOR\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^xor/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tXOR\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^xnor/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tXOR\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^enc/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tENC\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^dec/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tDEC\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^mux/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tMUX\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^add/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tADD\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^sub/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tSUB\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^mul/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tMUL\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^div/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tDIV\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^dff/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          print WRITE_LIB"\tpin:\t\tINPUT $pin\;\n";
        }elsif($pinDir eq "output"){
          print WRITE_LIB"\tpin:\t\tOUTPUT $pin\;\n";
        }
      }#foreach
      print WRITE_LIB "\tfunction:\tFF\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^rff/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          print WRITE_LIB"\tpin:\t\tINPUT $pin\;\n";
        }elsif($pinDir eq "output"){
          print WRITE_LIB"\tpin:\t\tOUTPUT $pin\;\n";
        }
      }#foreach
      print WRITE_LIB "\tfunction:\tRFF\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^sff/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          print WRITE_LIB"\tpin:\t\tINPUT $pin\;\n";
        }elsif($pinDir eq "output"){
          print WRITE_LIB"\tpin:\t\tOUTPUT $pin\;\n";
        }
      }#foreach
      print WRITE_LIB "\tfunction:\tSFF\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^rsff/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          print WRITE_LIB"\tpin:\t\tINPUT $pin\;\n";
        }elsif($pinDir eq "output"){
          print WRITE_LIB"\tpin:\t\tOUTPUT $pin\;\n";
        }
      }#foreach
      print WRITE_LIB "\tfunction:\tRSFF\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^srff/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          print WRITE_LIB"\tpin:\t\tINPUT $pin\;\n";
        }elsif($pinDir eq "output"){
          print WRITE_LIB"\tpin:\t\tOUTPUT $pin\;\n";
        }
      }#foreach
      print WRITE_LIB "\tfunction:\tSRFF\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^latch/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          print WRITE_LIB"\tpin:\t\tINPUT $pin\;\n";
        }elsif($pinDir eq "output"){
          print WRITE_LIB"\tpin:\t\tOUTPUT $pin\;\n";
        }
      }#foreach
      print WRITE_LIB "\tfunction:\tLD\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^rlatch/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          print WRITE_LIB"\tpin:\t\tINPUT $pin\;\n";
        }elsif($pinDir eq "output"){
          print WRITE_LIB"\tpin:\t\tOUTPUT $pin\;\n";
        }
      }#foreach
      print WRITE_LIB "\tfunction:\tRLD\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^lshift/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tLSH\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^rshift/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }
      if($output_count == 1){
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tRSH\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^cmp/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){    
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tCMP\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^vcc/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          print WRITE_LIB"\tpin:\t\tINPUT $pin\;\n";
        }elsif($pinDir eq "output"){
          print WRITE_LIB"\tpin:\t\tOUTPUT $pin\;\n";
        }
      }#foreach
      print WRITE_LIB "\tfunction:\tVCC\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^gnd/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          print WRITE_LIB"\tpin:\t\tINPUT $pin\;\n";
        }elsif($pinDir eq "output"){
          print WRITE_LIB"\tpin:\t\tOUTPUT $pin\;\n";
        }
      }#foreach
      print WRITE_LIB "\tfunction:\tGND\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }elsif($cell =~ /^inc/i){
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      my $input_count = 0;
      my $output_count = 0;
      foreach my $pin  (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
        if($pinDir eq "input"){
          $input_count++;
        }elsif($pinDir eq "output"){
          $output_count++;
        }
      }#foreach
      if($input_count == 1){
        print WRITE_LIB"\tpin:\t\tINPUT in\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tINPUT [$input_count : 0] in\;\n";
      }
      if($output_count == 1){
        print WRITE_LIB"\tpin:\t\tOUTPUT out\;\n";
      }else {
        print WRITE_LIB"\tpin:\t\tOUTPUT [$output_count : 0] out\;\n";
      }
      print WRITE_LIB "\tfunction:\tINC\;\n";
      my $area = $TLDB{$cell}->dbTimingLibGetCellArea;
      print WRITE_LIB "\tarea:\t\t$area\;\n";
      my @temp_dealy_list = ();
      my $delay_first_value  = (split(/,/,$cellRiseDelayVal[0]))[0];
      if($delay_first_value ne ""){
        print WRITE_LIB "\tdelay:\t\t$delay_first_value\;\n";
      }
    }
    print WRITE_LIB"\}\n";
  }#foreach
}#else
my $t1 = new Benchmark;
my $td = timediff($t1,$t0);
print "\nCommand write_hana_lib_file took:",timestr($td),"\n";
}#sub write_hana_lib_file
#####################################################################
sub port_blast {
my $portName = $_[0];
my $busWidth = $portName;
$busWidth =~ s/^.*\[|<//;
$busWidth =~ s/\]|>.*$//;
$portName =~ s/\[.*$//;
my @PORT_BIT_BLAST = ();
my ($min,$max) = (split(/:/,$busWidth));
if($min < $max){
  for(my $i = $min;$i <=$max;$i++){
    push(@PORT_BIT_BLAST,$portName."[".$i."]");
  }#for
}elsif($min > $max){
  for(my $i = $min;$i>=$max;$i--){
    push(@PORT_BIT_BLAST,$portName."[".$i."]");
  }#for
}elsif($min == $max){
  $i =  $min;
  push(@PORT_BIT_BLAST,$portName."[".$i."]");
}
return(@PORT_BIT_BLAST);
}#sub port_blast
#####################################################################
sub create_cell_info_frm_lib {
use Benchmark;
my $t0 = new Benchmark;

my $noOfArguments = @_;

if($noOfArguments < 0 || $_[0] eq '-h') {
   print "Usage : create_cell_info_frm_lib\n";
}else{
  my $file_name;
  my %FUNC_VS_CELL = ();

  open(WRITE_TXT,">cell_info.txt");
  foreach my $cell (keys %TLDB){
    my @input_list = ();
    my @output_list = ();
    my $function = $TLDB{$cell}->dbTimingLibGetCellFootPrint;
    if($function ne "UND"){
      if(!exists $FUNC_VS_CELL{$function}){
        $FUNC_VS_CELL{$function} = $cell;
        print WRITE_TXT "$cell ";
        print WRITE_TXT "$function ";
        my @pins = $TLDB{$cell}->dbTimingLibGetPins;
        foreach my $pin (@pins){
          my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);  
          if($pinDir eq "input"){
             push (@input_list,$pin);
          }elsif($pinDir eq "output"){
             push (@output_list,$pin);
          }
        }#foreach 
        my $input_str = join ",",@input_list;
        my $output_str = join ",",@output_list;
        my $num_of_input = @input_list; 
        my $num_of_output = @output_list; 
        print WRITE_TXT "input=$input_str $num_of_input output=$output_str $num_of_output\n";
      }
    }else {
      print WRITE_TXT "$cell ";
      print WRITE_TXT "$function ";
      my @pins = $TLDB{$cell}->dbTimingLibGetPins;
      foreach my $pin (@pins){
        my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);  
        if($pinDir eq "input"){
           push (@input_list,$pin);
        }elsif($pinDir eq "output"){
           push (@output_list,$pin);
        }
      }#foreach 
      my $input_str = join ",",@input_list;
      my $output_str = join ",",@output_list;
      my $num_of_input = @input_list; 
      my $num_of_output = @output_list; 
      print WRITE_TXT "input=$input_str $num_of_input output=$output_str $num_of_output\n";
    }
  }#foreach 
  close(WRITE_TXT);
}#else
my $t1 = new Benchmark;
my $td = timediff($t1, $t0);
print "Command create_cell_info_frm_lib took:",timestr($td),"\n";
}#sub create_cell_info_frm_lib
#####################################################################
sub write_footprint_for_netlistgen {
use Benchmark;
my $t0 = new Benchmark;   
open(WRITE,">footprint");
foreach my $macroName(keys %TLDB){
  my @pins = $TLDB{$macroName}->dbTimingLibGetPins;
  if(exists $PLDB{$macroName}){
    print WRITE "$macroName ";
    my $func = $PLDB{$macroName}->dbMdbGetFunction;
    if($func eq "flop" || $func eq "latch"){
      print WRITE "$func seq "; 
    }else {
      print WRITE "$func combi ";
    }
  }
  foreach my $pin (@pins){
    if(exists $PLDB{$macroName}){ 
      my $in = $PLDB{$macroName}->dbMdbGetPinIsRegIn1($pin);
      if($in == 1){print WRITE "$pin ";}  
      my $out = $PLDB{$macroName}->dbMdbGetPinIsRegOut1($pin);
      if($out == 1){print WRITE "$pin ";}
      my $clock = $PLDB{$macroName}->dbMdbGetPinIsClock($pin);
      if($clock == 1){print WRITE "$pin ";}
    }
  }#foreach
print WRITE "\n";
}#foreach
close(WRITE);
my $t1 = new Benchmark;
my $td = timediff($t1, $t0);
print "Command write_footprint_for_netlistgen took:",timestr($td),"\n";
}#sub write_footprint_for_netlistgen
#####################################################################

sub write_lib_yosys {
use Benchmark;
my $t0 = new Benchmark;

$noOfArguments = @_;
my $OUTPUT_LIB;
my $write_power = 0;
my $noSeqCells = 0 ;
if($noOfArguments < 2 || $_[0] eq '-h') {
   print "usage : write_lib -outlib < Output file> \n";
}else{
   for(my $i = 0 ; $i < $noOfArguments ;  $i++){
       if($_[$i] eq "-outlib"){$OUTPUT_LIB = $_[$i+1];}
       if($_[$i] eq "--power"){$write_power = 1;} 
       if($_[$i] eq "--noseq"){$noSeqCells = 1;} 
   }# for no of arguments

   my $buffer_found = 0;
   my $inverter_found = 0;
   my @cells = ();
   foreach $cell_name(keys %TLDB){
      my $func;
      if(exists $PLDB{$cell_name}){
         $func = $PLDB{$cell_name}->dbMdbGetFunction;
      }#if exists PLDB 
      #print "cell:$cell_name func:$func\n";
      if($func eq 'buf' && $buffer_found == 0) {
        push ( @cells , $cell_name);
        $buffer_found = 1;
      }elsif($func eq 'inv' && $inverter_found == 0) {
        push ( @cells , $cell_name);
        $inverter_found = 1;
      }
      #print "buf_found:$buffer_found inv_found:$inverter_found\n";
      if( $buffer_found == 1 && $inverter_found == 1){
        last;
      }
   }
   foreach my $cell_name (keys %TLDB){
      if($cell_name ne $cells[0] && $cell_name ne $cells[1]){
         push ( @cells, $cell_name);
      }
   }

   open ( WRITE_LIB, ">$OUTPUT_LIB");
     print WRITE_LIB "library\(demo\) \{\n";
   foreach my $cell (@cells){
    my $skipCell = 0 ; 
    my @cellBufferData = ();
       if ( $noSeqCells == 1 ) {
      if ( exists $PLDB{$cell} ) {
       my $cellType = $PLDB{$cell}->dbMdbGetType;
       print "$cell is $cellType\n";
       next if ( $PLDB{$cell}->dbMdbGetType == "1");
       print "$cell is $cellType\n";
                                 }
                               }
#     print WRITE_LIB "  cell \($cell\) \{\n";
#     print WRITE_LIB "        area: 4 ;\n";
      push(@cellBufferData,"  cell \($cell\) \{");
      push(@cellBufferData,"        area: 4 ;");
     my @pins = $TLDB{$cell}->dbTimingLibGetPins;
     foreach my $pin (@pins){
       my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);  
       #my $name = $TLDB{$cell}->dbTimingLibGetCellName;  
       if($pinDir eq "" || $pinDir eq "internal"){next;}
      # print WRITE_LIB "  pin \($pin\) \{";
      push(@cellBufferData,"  pin \($pin\) \{");
      # print WRITE_LIB "    direction : $pinDir\;";
      push(@cellBufferData,"    direction : $pinDir\;");
       if($pinDir eq "output"){
          my $pinFunc = $TLDB{$cell}->dbTimingLibGetPinFunc($pin);
         if ($pinFunc eq "UND") { 
                                #print WRITE_LIB "  \}\n"; 
                                $skipCell = 1 ;  next;
                                }
          #print WRITE_LIB "\n    function : \"$pinFunc\"\;\n";
      push(@cellBufferData,"\n    function : \"$pinFunc\"\;");
       }#if output pin
       #print WRITE_LIB "  \}\n";
      push(@cellBufferData,"  \}");
     }#foreach pin
     #print WRITE_LIB"\}\n";
      push(@cellBufferData,"\}");
     #------- pint the cell data ---#
    if ( $skipCell == 0 ) {
    while (defined ($o = shift @cellBufferData ) ) { print WRITE_LIB "$o\n"; }
                          }
 
   }#for each cell
     print WRITE_LIB"\}\n";
   close(WRITE_LIB);
}
my$t1 = new Benchmark;
my $td = timediff($t1, $t0);
print "\nCommand write_lib took:",timestr($td),"\n";
}#sub write_lib_yosys


1;

